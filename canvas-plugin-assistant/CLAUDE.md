# Canvas Plugin Assistant - Coding Standards

These standards apply to all Canvas plugin code generated by this assistant.

## Imports: Use Absolute Paths Only

**CRITICAL: Canvas plugins MUST use absolute imports with the full package path.**

Relative imports will fail in the Canvas runtime. Always use the full package path starting with the inner folder name (snake_case).

### What NOT to do

```python
# BAD - relative imports (will fail in Canvas)
from ..clients.aws_s3 import AwsS3
from .handler import MyHandler
from ...utils.helpers import format_date
```

### What to do instead

```python
# GOOD - absolute import with full package path
from my_plugin_name.clients.aws_s3 import AwsS3
from my_plugin_name.protocols.handler import MyHandler
from my_plugin_name.utils.helpers import format_date
```

The package name must match the inner folder name:
- Inner folder: `vitals_alert/`
- Import: `from vitals_alert.protocols.handler import ...`

## Error Handling: Let Exceptions Propagate

**CRITICAL: Do NOT use try-except blocks in Canvas plugin code.**

Exceptions must bubble up so they appear in the Canvas logs for debugging. Swallowing exceptions with try-except makes plugins impossible to debug in production.

### What NOT to do

```python
# BAD - exceptions are swallowed, nothing appears in logs
def compute(self) -> list[Effect]:
    try:
        patient_id = self.event.context["patient"]["id"]
        # logic here
    except Exception as e:
        log.error(f"Error: {e}")  # This is NOT enough - we need the full traceback
        return []
```

### What to do instead

```python
# GOOD - exceptions propagate, full traceback appears in Canvas logs
def compute(self) -> list[Effect]:
    patient_id = self.event.context["patient"]["id"]
    # logic here - if this fails, the exception bubbles up with full traceback
    return []
```

### Handling missing/optional data

Use early returns for expected missing data, not try-except:

```python
# GOOD - explicit checks for optional data
def compute(self) -> list[Effect]:
    patient = self.event.context.get("patient")
    if not patient:
        return []  # Expected case: no patient context

    patient_id = patient["id"]
    vitals = self.event.target.instance

    if not vitals.blood_pressure_systolic:
        return []  # Expected case: no BP recorded

    # Continue with logic...
```

### When try-except IS acceptable

Only use try-except when:
1. Calling external APIs where you need to handle network failures gracefully
2. Parsing user-provided data that may be malformed
3. You explicitly re-raise or want to add context to the exception

```python
# ACCEPTABLE - external API with re-raise
def fetch_external_data(self, patient_id: str) -> dict:
    try:
        response = httpx.get(f"{self.api_url}/patient/{patient_id}")
        response.raise_for_status()
        return response.json()
    except httpx.HTTPError as e:
        # Re-raise with context so it still appears in logs
        raise RuntimeError(f"Failed to fetch data for patient {patient_id}") from e
```

## Git Operations: Scope to Current Directory

**CRITICAL: All git add commands MUST be scoped to the current directory.**

```bash
# CORRECT - scoped to current directory
git add -A .

# WRONG - stages changes across entire repository
git add --all
git add -A
git add .   # This is also risky if not in the right directory
```

The `-A .` flag combination ensures:
- `-A` stages all changes (new, modified, deleted files)
- `.` limits the scope to the current directory and below

**Never use `git add --all` or `git add -A` without a path.** These commands can accidentally stage and commit files outside the plugin directory, which is extremely difficult to unwind.

## Code Style

- Keep handlers simple and focused
- Use early returns for guard clauses
- Validate data existence with explicit checks, not exception handling
- Log important business events with `log.info()`, not errors that aren't errors
- Avoid single letter variable names (prefer `[for questionnaire.name in questionnaires]` instead of `[for q.name in questionnaires]`, except for loop counters (e.g. `for i in range(...)`)
