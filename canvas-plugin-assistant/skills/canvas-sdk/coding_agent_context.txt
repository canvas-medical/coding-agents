----- BEGIN PAGE https://docs.canvasmedical.com/guides/appointments-additional_fields/
This guide explains how to add additional fields that will appear when scheduling an appointment. With this, you can define custom fields, and the information will be stored as appointments metadata.
##  What you'll learn: 
  - Use the [`AppointmentMetadataCreateForm`](/sdk/appointment-metadata-create-form-effect) effect to display additional fields when scheduling an appointment.
  - Use the [`FormField`](/sdk/appointment-metadata-create-form-effect/#formfield) class to create fields
##  Appointment Metadata Create form plugin 
####  1\. FormField 
To create the form, we need to specify which items will be included. For this, we use the [`FormField`](/sdk/appointment-metadata-create-form-effect/#formfield) class, where we can define our inputs and their attributes.
    ```python
    from canvas_sdk.effects.appointments_metadata import FormField, InputType
    FormField(
        key='state',
        label='State',
        type=InputType.TEXT,
        required=False,
        editable=True,
        value="CA"
    ),
    ```
####  2\. AppointmentMetadataCreateFormEffect 
The next step is to add these fields to the effect so they can be used to build the form.
    ```python
    from canvas_sdk.effects.appointments_metadata import AppointmentsMetadataCreateFormEffect, FormField, InputType
    AppointmentsMetadataCreateFormEffect(form_fields=[
        FormField(
            key='state',
            label='State',
            type=InputType.TEXT,
            required=False,
            editable=True,
            value="CA"
        ),
        ...,
    ])
    ```
####  3\. The plugin 
Here's an example of a complete plugin showcasing the different input types.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.appointments_metadata import AppointmentsMetadataCreateFormEffect, InputType, FormField
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    # Inherit from BaseHandler to properly get registered for events
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.APPOINTMENT__FORM__GET_ADDITIONAL_FIELDS)
        def compute(self) -> list[Effect]:
            form = AppointmentsMetadataCreateFormEffect(form_fields=[
                FormField(
                    key='state',
                    label='State',
                    type=InputType.TEXT,
                    required=False,
                    editable=True,
                ),
                FormField(
                    key='occupation',
                    label='Occupation',
                    type=InputType.SELECT,
                    required=False,
                    editable=True,
                    options=["Engineer", "Teacher", "Other"]
                )
            ])
            return [form.apply()]
    ```
####  4\. The Output 
Below, you can see how it will appear in the app — these fields will be stored as appointments metadata.
![appointments-additional-fields](/assets/images/appointments-additional-fields.png)
----- END PAGE https://docs.canvasmedical.com/guides/appointments-additional_fields/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/creating-webhooks-with-the-canvas-sdk/
Webhooks are user-defined callbacks that make a request to an API. You may want to create a webhook to notify a system you control that some event has occurred in Canvas. This guide shows how to create a webhook that sends an API request containing the ID of a Task upon its creation.
> **Info:** This guide assumes pre-existing knowledge of the Canvas SDK. If you're starting from scratch, you may want to read and implement [Your First Plugin (with Claude Code)](/guides/your-first-plugin-with-claude-code/) before working through this exercise. 
##  Initialize a new plugin 
The Canvas CLI gives you a great head start when creating a plugin. Simply run `canvas init`, and answer the prompt to name your plugin.
    ```sh
    $ canvas init
      [1/1] project_name (My Cool Plugin): Task Webhook
    Project created in /Users/andrew/src/canvas-plugins/task-webhook
    ```
This output shows the location of our freshly generated plugin.
##  Edit the plugin code 
The default content of this file shows you the information you have available to you in the comments. I've stripped it down to almost nothing so we can layer in the functionality step by step.
###  Log a message when a task is created. 
The code below listens for the `TASK_CREATED` event and logs the string "A Task was created!".
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created, log a message
        """
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            """
            Log a message as tasks are created.
            """
            log.info("A Task was created!")
            return []
    ```
You can see this log output by first streaming logs with `canvas logs` and then creating a task. You can create this task with Canvas Chat, a Task Command, or our [FHIR Task Create endpoint](/api/task/#create).
After you've [installed your plugin](/sdk/canvas_cli/#canvas-install) and created a task, you should see this in your log stream:
    ```sh
    INFO 2024-09-26 17:04:08,396 Starting server, listening on port 50051
    INFO 2024-09-26 17:04:08,396 Loading custom-plugins/task_webhook
    INFO 2024-09-26 17:04:08,396 Loading plugin 'task_webhook:task_webhook.protocols.my_protocol:Protocol'
    INFO 2024-09-26 17:04:24,410 A Task was created!
    INFO 2024-09-26 17:04:24,410 task_webhook:task_webhook.protocols.my_protocol:Protocol.compute() completed (0 ms)
    INFO 2024-09-26 17:04:24,411 Responded to Event TASK_CREATED (1 ms)
    ```
Awesome! But we're not here to log, we need to make an API request. To do that, we need to use the HTTP client found in the Canvas SDK's [Utils module](/sdk/utils/)
###  Make an HTTP request when a Task is created 
We can use <https://webhook.site/> for a quick way to test our webhook and see the requests it receives. Here is the updated code that uses the HTTP client to make the request:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.utils import Http
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created, hit a webhook
        """
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            """
            Notify our server of tasks as they are created.
            """
            url = "https://webhook.site/ee7aed78-b652-4d9e-b858-04465c409d15"
            payload = {
                "message": "A Task was created!"
            }
            http = Http()
            response = http.post(url, json=payload)
            if response.ok:
                log.info("Successfully notified API of task creation!")
            else:
                log.info("Notification unsuccessful. =[")
            return []
    ```
After you've [installed your updated plugin](/sdk/canvas_cli/#canvas-install) and created a task, you should see this in your log stream:
    ```sh
    INFO 2024-09-26 17:18:23,206 Loading custom-plugins/task_webhook
    INFO 2024-09-26 17:18:23,207 Reloading plugin 'task_webhook:task_webhook.protocols.my_protocol:Protocol'
    INFO 2024-09-26 17:18:33,850 Successfully notified API of task creation!
    INFO 2024-09-26 17:18:33,851 task_webhook:task_webhook.protocols.my_protocol:Protocol.compute() completed (693 ms)
    INFO 2024-09-26 17:18:33,851 Responded to Event TASK_CREATED (696 ms)
    ```
This log output is a great reminder for me to mention that making HTTP requests to external servers will slow plugin execution while it waits on the external server to respond. It's a good idea to make sure the servers you're hitting have a sufficiently quick response time.
Checking in on our webhook.site logs shows it received our request! ![Log of web
request](/assets/images/webhook-guide/webhook-guide-first-request.png)
Awesome, but you aren't sending these requests to a server that allows unauthenticated requests! And this request doesn't even tell you anything about the task it's notifying you about. This isn't useful at all!
Let's do another iteration, this time using the information provided along with the event so that we can send a usable message, securely. We're specifically going to incorporate the event's `target` and `secrets`.
###  Make an authenticated HTTP request that includes the newly created Task's ID 
Within your `Protocol` class, you have access to `self.target`, which represents the ID of the subject of the event. In our case, it will be the Task's ID. This is the same ID used in the [FHIR Task endpoints](/api/task/), so you can use it to make FHIR API requests.
You also have access to `self.secrets`, which is a python dictionary containing the key-value pairs from your plugins configuration page. You declare the keys in your `CANVAS_MANIFEST.json`, and can then set the values after the plugin is installed.
We'll set two secrets, one for the unique id of the webhook, and one for an auth token. Here's what the manifest file looks like with secrets declared:
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "task_webhook",
        "description": "Webhooks for task creation",
        "components": {
            "protocols": [
                {
                    "class": "task_webhook.protocols.my_protocol:Protocol",
                    "description": "Hit an API when a task is created",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
           ]
        },
        "secrets": ["WEBHOOK_ID", "AUTH_TOKEN"],
        "tags": {},
        "license": "",
        "readme": "./README.md"
    }
    ```
The line `"secrets": ["WEBHOOK_ID", "AUTH_TOKEN"],` declares two secrets, `WEBHOOK_ID` and `AUTH_TOKEN`. After we update the plugin, we can set values for these in the plugin configuration page. This allows for different values to be used across different installations.
Here's how that configuration looks:
![Plugin secrets
configuration](/assets/images/webhook-guide/webhook-guide-secrets.png)
With those values set, we can use them in our code:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.utils import Http
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created, hit a webhook
        """
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            """
            Notify our server of tasks as they are created.
            """
            url = f"https://webhook.site/{self.secrets['WEBHOOK_ID']}"
            headers = {
                "Authorization": f"Bearer {self.secrets['AUTH_TOKEN']}"
            }
            payload = {
                "message": "A Task was created!",
                "resource_id": self.target
            }
            http = Http()
            response = http.post(url, json=payload, headers=headers)
            if response.ok:
                log.info("Successfully notified API of task creation!")
            else:
                log.info("Notification unsuccessful. =[")
            return []
    ```
And checking once more on our webhook.site logs shows it received our updated request, including our `AUTH_TOKEN` value and the created task's ID.
![Log of web
request](/assets/images/webhook-guide/webhook-guide-second-request.png)
##  Listening for multiple events 
A single plugin handler can listen for multiple event types. The event type will be available in `self.event.type`, which will contain a member of the `EventType` enum. The [full list of events is available](/sdk/events/#event-types). Here is a short example that listens for two different events:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.utils import Http
    from logger import log
    class Protocol(BaseProtocol):
        """
        When a task is created or updated, hit a webhook
        """
        RESPONDS_TO = [
            EventType.Name(EventType.TASK_CREATED),
            EventType.Name(EventType.TASK_UPDATED),
        ]
        def compute(self):
            """
            Notify our server of tasks as they are created.
            """
            url = f"https://webhook.site/{self.secrets['WEBHOOK_ID']}"
            headers = {"Authorization": f"Bearer {self.secrets['AUTH_TOKEN']}"}
            # self.event.type is a member of the EventType enum corresponding to
            # one of the event types in the plugin's RESPONDS_TO attribute
            verb = 'created' if self.event.type == EventType.TASK_CREATED else 'updated'
            payload = {
                "message": f"A Task was {verb}!",
                "resource_id": self.target,
            }
            http = Http()
            response = http.post(url, json=payload, headers=headers)
            # You can also get the name of the event as as string using EventType.Name()
            event_name = EventType.Name(self.event.type)
            if response.ok:
                log.info(f"Successfully notified API of {event_name}")
            else:
                log.info(f"Notification of {event_name} unsuccessful. =[")
            return []
    ```
Alternatively, you could include several classes, each resposible for some specific request type. When including several classes in one plugin, they all have access to the same secrets dictionary, you just need to declare each class in the manifest file.
##  Conclusion 
I hope you found this helpful. Happy coding, we can't wait to see what you build!
----- END PAGE https://docs.canvasmedical.com/guides/creating-webhooks-with-the-canvas-sdk/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/custom-landing-page/
This guide provides examples of how to leverage patient data to personalize the portal landing page, and explains how to integrate the ready-made widgets provided by Canvas.
> **Info:** This guide assumes pre-existing knowledge of the Canvas SDK. If you're starting from scratch, you may want to read and implement [Your First Plugin (with Claude Code)](/guides/your-first-plugin-with-claude-code/) before working through this exercise. 
##  What Are Widgets in the Patient Portal? 
[Widgets](/sdk/layout-effect/#portal-landing-page-widgets) in the patient portal are interactive components that enhance the user experience by providing quick access to information and functionalities. They can display key details like upcoming appointments. Widgets can be fully customized with unique content or leverage ready-made components—such as Appointments and Messaging provided by Canvas to ensure consistency and ease of use. These widgets are organized on the landing page using a grid layout, which supports various sizes to optimize the visual presentation and responsiveness across different devices.
##  How to add a Widget? 
A widget can be added by listening to the `PATIENT_PORTAL__WIDGET_CONFIGURATION` event and returning one or several `PortalWidget`
###  Step 1: Initialize a plugin 
The Canvas CLI gives you a great head start when creating a plugin. Simply run
    ```bash
      canvas init
    ```
Then, follow the prompts to name and configure your new plugin project.
###  Step 2: Update you protocol 
Modify your protocol to handle the widget configuration event. For example:
    ```python
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        def compute(self):
            widget = PortalWidget(
              content="Hello World", 
              size=PortalWidget.Size.COMPACT, 
              priority=10
            )
            return [widget.apply()]
    ```
This code listens for the `PATIENT_PORTAL__WIDGET_CONFIGURATION` event and, when triggered, creates a new widget with a simple "Hello World" message, a compact size, and a priority of 10.
##  Patient medication widget 
This widget will show the last medication and CTA to request a refill.
So let's update the example above to:
  - Fetch the patient's medication.
  - Leverage [HTML templating](/sdk/layout-effect/#custom-html-and-django-templates) to display the necessary information
###  Step 1: Fetch patient medication 
Since the event includes the patient object, you can easily access all the necessary data. Add the following snippet to your compute method to retrieve the patient's details:
    ```python
    patient = Patient.objects.get(id=self.target)
    last_medication = patient.medications.last()
    ```
###  Step 2: Prepare HTML template 
Create a `templates` folder inside your plugin's folder:
    ```bash
      mkdir templates
    ```
Add the HTML file:
    ```bash
      touch medication_widget.html
    ```
And add the following HTML:
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body, html {
          height: 100%;
          width: 100%;
          margin: 0;
          font-family: "Roboto","Helvetica","Arial",sans-serif;
          font-size: 16px;
        }
      </style>
    </head>
    <body>
    </body>
    </html>
    ```
###  Step 3: Design your widget 
> **Info:** Developers are responsible for providing all the necessary CSS to style their widget. The widget does not include default styles, so you should include custom CSS—either inline or via an external stylesheet—to define the layout, typography, colors, spacing, and interactive elements. 
While you can design your widget in any way that suits your needs, for this example we'll create one featuring a header and a card component. The card will display the medication name, the prescription date, and a clear call-to-action (CTA) button that redirects the patient to the messaging page to request a refill.
####  Header 
A light gray background color and a blue text to ensure it matches the patient portal aesthetic.
    ```html
    <style>
      .header {
          padding: 8px;
          background: #E5E5E5;
          color: #2185D0;
          text-align: left;
          margin: 0;
          font-weight: 500;
          font-size: 18px;
          line-height: 1.6;
        }
    </style>
    <body>
        <div class="header">My Health</div>
    </body>
    ```
####  Card Component 
We will add template variables for the medication name and start date, allowing these values to be dynamically updated in the plugin.
    ```html
    <body>
      <div class="widget">
        <div class="medication-info">
          <span class="material-icons">medication</span>
          <span>{{name}}</span>
        </div>
        <p style="padding: 0 12px">This medication was prescribed on {{start_date}}. Do you need a refill?</p>
        <button onclick="onClick()">Ask for a refill</button>
      </div>
      <script>
        function onClick() {
          window.top.location.href = "http://localhost:8000/app/messaging"
        }
      </script>
    </body>
    ```
Let's dive in and add some styles to the card.
Our `widget` class ensures that all elements are both vertically and horizontally centered, creating a sleek card design with rounded borders and a subtle shadow for a modern, elevated look.
    ```css
    .widget {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 98%;
      height: 80%;
      border-radius: 4px;
      box-shadow: 0 2px 1px -1px rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 1px 3px 0 rgba(0, 0, 0, 0.12);
      background-color: #f9f9f9;
      text-align: center;
      margin: 4px auto auto;
    }
    ```
Our medication info section will feature a Material UI icon next to the medication name, providing a clear and modern visual representation consistent with the portal's design aesthetic.
    ```css
    .medication-info {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      padding: 0 8px;
      font-size: 14px;
    }
    .material-icons {
      font-size: 50px;
    }
    ```
And finally, we style the CTA button to mimic a Material UI button, ensuring it aligns perfectly with the portal's overall design aesthetic.
    ```css
    button {
      margin-top: 16px;
      background-color: #1976d2;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 16px 16px;
      font-size: 14px;
      min-width: 64px;
      text-transform: uppercase;
      box-shadow: 0 3px 1px -2px rgba(0,0,0,0.2),
                  0 2px 2px 0 rgba(0,0,0,0.14),
                  0 1px 5px 0 rgba(0,0,0,0.12);
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #115293;
    }
    ```
###  Step 4: Tying everything together 
Update your plugin's `compute` method to pass the desired values for medication name and start date using `render_to_string` function
    ```python
    medication_info = {
        "start_date": last_medication.start_date.strftime("%B %d, %Y"),
        "name": last_medication.codings.first().display
    }
    widget = PortalWidget(content=render_to_string("templates/medication_widget.html", medication_info), size=PortalWidget.Size.COMPACT, priority=10)
    ```
![medication widget](/assets/images/sdk/widgets/patient_medication_widget.png)
###  Full Example 
    ```python
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.templates import render_to_string
    from canvas_sdk.v1.data import Patient
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        def compute(self):
            patient = Patient.objects.get(id=self.target)
            last_medication = patient.medications.last()
            medication_info = {
                "start_date": last_medication.start_date.strftime("%B %d, %Y"),
                "name": last_medication.codings.first().display
            }
            medication_widget = PortalWidget(
              content=render_to_string("templates/medication_widget.html", medication_info), 
              size=PortalWidget.Size.COMPACT, 
              priority=10
            )
            return [medication_widget.apply()]
    ```
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
      <style>
        body, html {
          height: 100%;
          width: 100%;
          margin: 0;
          font-family: "Roboto","Helvetica","Arial",sans-serif;
          font-size: 16px;
        }
        .widget {
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          width: 98%;
          height: 80%;
          border-radius: 4px;
          box-shadow: 0 2px 1px -1px rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 1px 3px 0 rgba(0, 0, 0, 0.12);
          background-color: #f9f9f9;
          text-align: center;
          margin: 4px auto auto;
        }
        .header {
          padding: 8px;
          background: #E5E5E5;
          color: #2185D0;
          text-align: left;
          margin: 0;
          font-weight: 500;
          font-size: 18px;
          line-height: 1.6;
        }
        .medication-info {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 15px;
          padding: 0 8px;
          font-size: 14px;
        }
        .material-icons {
          font-size: 50px;
        }
        button {
          margin-top: 16px;
          background-color: #1976d2;
          color: #fff;
          border: none;
          border-radius: 4px;
          padding: 16px 16px;
          font-size: 14px;
          min-width: 64px;
          text-transform: uppercase;
          box-shadow: 0 3px 1px -2px rgba(0,0,0,0.2),
                      0 2px 2px 0 rgba(0,0,0,0.14),
                      0 1px 5px 0 rgba(0,0,0,0.12);
          cursor: pointer;
          transition: background-color 0.3s ease;
        }
        button:hover {
          background-color: #115293;
        }
      </style>
    </head>
    <body>
      <div class="header">My Health</div>
      <div class="widget">
        <div class="medication-info">
          <span class="material-icons">medication</span>
          <span>{{name}}</span>
        </div>
        <p style="padding: 0 12px">This medication was prescribed on {{start_date}}. Do you need a refill?</p>
        <button onclick="onClick()">Ask for a refill</button>
      </div>
      <script>
        function onClick() {
          window.top.location.href = "http://localhost:8000/app/messaging"
        }
      </script>
    </body>
    </html>
    ```
##  Upcoming appointments Widget provided by Canvas 
This is one of the ready-made widgets provided by Canvas that you can add to your patient portal. It will show upcoming appointments.
###  Step 1: Add a new protocol to your plugin 
Create a new protocol in your plugin with the following content:
    ```python
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class UpcomingAppointmentWidget(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        def compute(self):
            widget = PortalWidget(component=PortalWidget.Component.APPOINTMENTS, priority=25)
            return [widget.apply()]
    ```
![medication widget](/assets/images/sdk/widgets/upcoming_appointments_widget.png)
----- END PAGE https://docs.canvasmedical.com/guides/custom-landing-page/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/customize-panel-buttons/
This guide is intended to help you customize which buttons are shown on the main page and the patient page. It allows you to add, order, or hide specific buttons as needed.
##  Getting Started 
To achieve this, you'll use the [PANEL_SECTIONS_CONFIGURATION](/sdk/events) event, which sends both the patient and the user attributes.
If you need to identify where the event is coming from, you can check if the patient attributes are present — on the global (main) page, the patient will be empty.
##  Defining the Sections 
In the SDK, you'll use the [PanelConfiguration](/sdk/layout-effect/#panel-configuration) effect. This effect takes in the sections you want to display and specifies the page where they should appear.
You'll use:
  - PanelPatientSection – for sections shown on the patient page
  - PanelGlobalSection – for sections shown on the main (global) page
The SDK has built-in safeguards to prevent you from mixing them up or placing a section on the wrong page.
That's It!
Once you apply the effect, your panel is configured — go check your page to see the changes in action!
##  The Complete Example 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.panel_configuration import PanelConfiguration
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    class CustomizePatientSection(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PANEL_SECTIONS_CONFIGURATION)
        def compute(self) -> list[Effect]:
            patient = self.target
            # user = self.context["user"]
            if patient:
                return [PanelConfiguration(sections=[
                    PanelConfiguration.PanelPatientSection.REFILL_REQUEST,
                    PanelConfiguration.PanelPatientSection.LAB_REPORT,
                    PanelConfiguration.PanelPatientSection.CHANGE_REQUEST,
                    PanelConfiguration.PanelPatientSection.TASK,
                ], page=PanelConfiguration.Page.PATIENT if patient else PanelConfiguration.Page.GLOBAL).apply()]
            else:
                return []
    class CustomizeGlobalSection(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PANEL_SECTIONS_CONFIGURATION)
        def compute(self) -> list[Effect]:
            patient = self.target
            # user = self.context["user"]
            if not patient:
                return [PanelConfiguration(sections=[
                    PanelConfiguration.PanelGlobalSection.LAB_REPORT,
                    PanelConfiguration.PanelGlobalSection.TASK,
                    PanelConfiguration.PanelGlobalSection.CHANGE_REQUEST,
                ], page=PanelConfiguration.Page.PATIENT if patient else PanelConfiguration.Page.GLOBAL).apply()]
            else:
                return []
    ```
----- END PAGE https://docs.canvasmedical.com/guides/customize-panel-buttons/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/customize-search-results/
In a typical visit note, it's common for clinicians to make 20, 30, even 50 or more selections from structured terminologies with commands like Diagnose, Prescribe, Family History, and many more. You can help clinicians make faster and more accurate selections with Canvas plugins. Write simple plugin code to apply custom filtering, sorting, and search result annotations in real time with near zero latency.
This search modification can help clinicians:
  - Choose the most appropriate medication that is also covered by insurance
  - Prioritize in-network specialists
  - Consider appropriate risk adjustment factors when selecting diagnosis codes
Canvas supports modifying search results in [all refactored commands](/product-updates/commands-module/#progress).
First, we'll show you a complete example of customizing the search results for choosing a medication in a Medication Statement command, then we'll break it down piece by piece so you can adapt the example to your own needs.
##  The Complete Example 
This example checks for the presence of a particular medication in the search results and, if present, annotates that medication option with additional information and adjusts its position to the top of the search results.
For reference, here's the difference in behavior with the plugin inactive vs active:
**Inactive (normal behavior):**
![With the plugin inactive, the results are unaltered](/assets/images/customize-search-results/plugin-inactive.png)
**Active (modified behavior):**
![With the plugin active, the preferred result is listed first, and with additional context](/assets/images/customize-search-results/plugin-active.png)
Here's the code in its entirety:
    ```python
    import json
    from canvas_sdk.events import EventType
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.MEDICATION_STATEMENT__MEDICATION__POST_SEARCH)
        def compute(self):
            results = self.context.get("results")
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            post_processed_results = []
            for result in results:
                should_float_to_top = False
                for coding in result.get("extra", {}).get("coding", []):
                    if (
                        coding.get("code") == 554704
                        and coding.get("system") == "http://www.fdbhealth.com/"
                    ):
                        if result.get("annotations") is None:
                            result["annotations"] = []
                        result["annotations"].append("Kirkland Signature")
                        should_float_to_top = True
                if should_float_to_top:
                    post_processed_results.insert(0, result)
                else:
                    post_processed_results.append(result)
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
    ```
##  Anatomy of the Example 
This code can be broken down into the following sections:
  - Register interest in the correct search event
  - Decide whether to make any changes
  - Loop through the results, making modifications as appropriate
  - Return the modified results as a properly typed effect
###  Register interest in the correct search event 
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.MEDICATION_STATEMENT__MEDICATION__POST_SEARCH)
        def compute(self):
            results = self.context.get("results")
    ```
The class inherits from `BaseProtocol`, which clues the plugin-runner into registering your code as interested in the event or events listed in the `RESPONDS_TO` class constant. We only specify one event here, `MEDICATION_STATEMENT__MEDICATION__POST_SEARCH`, but you could make this value a list to fire on multiple events. The event we've chosen to listen for can be read backwards to understand when it fires. This event is emitted after (" _post_ ") the normal _search_ results are found for the _medication_ autocomplete field of the _medication statement_ command. This event comes with a context that contains the search results that would be served to the user if there were no modifications.
###  Decide whether to make any changes 
    ```python
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
    ```
If the value of the results `is None`, we bail out early. There is a subtle difference between results of `None` and an empty result set (`[]`). Results being `None` means "make no changes, present the results without modification", whereas an empty result set means "present no options to the user".
###  Loop through the results, making modifications as appropriate 
    ```python
            post_processed_results = []
            for result in results:
                should_float_to_top = False
                for coding in result.get("extra", {}).get("coding", []):
                    if (
                        coding.get("code") == 554704
                        and coding.get("system") == "http://www.fdbhealth.com/"
                    ):
                        if result.get("annotations") is None:
                            result["annotations"] = []
                        result["annotations"].append("Kirkland Signature")
                        should_float_to_top = True
                if should_float_to_top:
                    post_processed_results.insert(0, result)
                else:
                    post_processed_results.append(result)
    ```
In this block of code, we create a new list named `post_processed_results` to hold our modified result set. We then loop through each result in the unmodified results set, and check to see if the current medication result matches our chosen criteria (FDB code 554704).
If it does match, we first check to see if any annotations already exist and initialize the annotations list if needed. We then append our chosen annotation to the result's annotation list and flag it as needing to be floated to the top (we had defaulted it to not be floated earlier on).
Finally, we add the result to our parallel list, `post_processed_results`. If it matched and was marked as being floated to the top, we insert it into the list at position 0. If it did not match, we append the result to the end of the list.
###  Return the modified results as a properly typed effect 
    ```python
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
    ```
With our list of modified results in place, we just need to return an effect of type `AUTOCOMPLETE_SEARCH_RESULTS` with our modified list as the payload.
The dropdown of options presented to the user now reflects our modifications!
##  Understanding Search Result Data Structures 
The search results in this example follow the MedicationSearchResult structure. Each result contains fields like `text`, `disabled`, `description`, `annotations`, `extra`, and `value` that provide detailed information about the medication option.
For complete details about medication search result data contracts and other search result structures, see the [Search Result Data Structures](/sdk/events/#search-result-data-structures) section in the Events documentation.
##  Accessing User Context 
All command-related PRE_SEARCH and POST_SEARCH events include information about the user performing the search in the event context. This includes search events for fields like prescriber, medication, diagnosis, pharmacy, and many others across various commands.
You can access the user's staff key from the context:
    ```python
    def compute(self):
        user_context = self.context.get("user", {})
        staff_key = user_context.get("staff")
        # Use the staff key to customize search results
        # based on the user's role, preferences, or permissions
    ```
This can be useful for customizing search results based on:
  - User-specific preferences or settings
  - Role-based filtering (e.g., showing different prescriber options based on the user's specialty)
  - Permission-based access control
  - User's organization or practice location
##  Watch Me Build It 
----- END PAGE https://docs.canvasmedical.com/guides/customize-search-results/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/growth-charts/
The Canvas SDK gives you access to real-time patient data and allows you to create custom UIs accessible from a patient's chart. The combination of these capabilities allows you to create rich, interactive data visualizations your clinicians can access directly in the charting interface. This example will show you how we've used this approach to implement a pediatric growth charts feature.
##  In this guide you will learn how to: 
  - Use the [`ActionButton`](/sdk/handlers-action-buttons) handler to provide a button, specify its location, and define its action in the UI.
  - Use the [`LaunchModalEffect`](/sdk/layout-effect/#modals) to display your custom visualization.
  - Fetch patient [observations](/sdk/data-observation/), such as height and weight, from the [data module](/sdk/data/).
  - Use the patient observation data within an HTML template.
  - Combine all of the above to surface a pediatric growth chart visualization right in the chart.
##  Growth Charts 
Growth charts are percentile curves showing the distribution of selected body measurements in children. A growth chart shows how a child's height, weight, and head circumference (for infants) compare to other children of the same age and sex. It helps track a child's growth over time and can indicate whether they are growing at an expected rate. Growth charts are commonly used by doctors to monitor development and identify potential health concerns. In this guide we will use charts from the [Center for Disease Control and Prevention (CDC)](https://www.cdc.gov/growthcharts/who-data-files.htm) to demonstrate how you can create your own.
The complete plugin is open-source and can be found in the [Medical Software Foundation GitHub repo](https://github.com/Medical-Software-Foundation/canvas/tree/main/extensions/growth_charts/).
The plugin adds a button on the Vital Signs section of the patient chart that, when clicked, launches a modal displaying the patient's height, weight, and head circumference measurements graphed against various percentile curves.
![vitals action button](/assets/images/vitals-action-button.png)
![chart template](/assets/images/growth-charts.png)
In the following steps, we'll show you how we used the Canvas SDK to create it.
##  Adding a button 
To add a button to the vital signs section, you'll implement an [`ActionButton`](/sdk/handlers-action-buttons) handler. In your handler class, you'll set the `BUTTON_LOCATION` constant to `ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION` to make the action button appear in the corresponding summary section of the chart.
    ```python
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.effects import Effect
    class GenerateVitalsGraphs(ActionButton):
        BUTTON_TITLE = "Growth Charts"
        BUTTON_KEY = "show_growth_charts"
        BUTTON_LOCATION = ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION
        def handle(self) -> list[Effect]:
            # This method is invoked when the button is clicked.
            pass
    ```
##  Launching a modal when the button is clicked 
Now that you have your button showing in the chart section, you can launch a modal when it's clicked using the [`LaunchModalEffect`](/sdk/layout-effect/#modals)
In this guide, we are launching a modal, but this click action can result in any [effect](/sdk/effects/) your handling code returns.
Here's an example of a simple plugin using the `LaunchModalEffect` to display a "Hello World" message.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.templates import render_to_string
    class HelloWorld(ActionButton):
        BUTTON_TITLE = "Hello World"
        BUTTON_KEY = "show_hello_world"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_HEADER
        def handle(self) -> list[Effect]:
            launch_modal = LaunchModalEffect(content=render_to_string("protocols/hello-world.html", { "title": "hello world" }))
            return [launch_modal.apply()]
    ```
And here's the result!
![action button](/assets/images/action-button-hello-world.png)
![hello world](/assets/images/template-hello-world.png)
##  Using HTML templates in the modal 
The use of templates allows us to render any kind of information from the data we have. We can even import external libraries from CDNs and add CSS styles to customize and enhance our modal.
To draw our graphs we use d3js, a free, open-source JavaScript library for visualizing data. How to use d3js is outside the scope of this guide, but you can find great documentation and tutorials on the d3 website [here](https://d3js.org/getting-started)
Here's an example of a template file name `hello-world.html` that receives a variable called title, which will be used inside the template.
    ```html
    <!DOCTYPE html>
    <style>
        body {
            font-family: Arial, sans-serif;
            font-size: 30px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <html lang="en">
        <h1 id="main"></h1>
    </html>
    <script>
        const div = document.getElementById('main');
        div.textContent = ``;
    </script>
    ```
##  Fetching the observations 
To retrieve the patient data we use the [Data Module](/sdk/data/). Specifically, the [`Observation`](/sdk/data-observation/) model.
Here, we can use `self.target`, which is the patient's `id`, to retrieve the patient and their observations by filtering for the values we need — such as weight, height, etc.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.v1.data.observation import Observation
    from canvas_sdk.v1.data.patient import Patient
    def handle(self) -> list[Effect]:
        patient = Patient.objects.get(id=self.target)
        sex_at_birth = patient.sex_at_birth
        birth_date = patient.birth_date
        observation_weight = Observation.objects.for_patient(self.target).filter(name="weight")
        observation_length = Observation.objects.for_patient(self.target).filter(name="length")
        observation_bmi = Observation.objects.for_patient(self.target).filter(name="bmi")
        observation_head_circumference = Observation.objects.for_patient(self.target).filter(name="head_circumference")
    ```
##  Tying it all together 
We now know:
  1. How to put a button in the chart
  2. How to launch a modal when that button is clicked
  3. How to create an HTML template to render within that modal
  4. How to retrieve data to use within that HTML template
All that's left is combining these actions into a useful data visualization for our clinical users.
You can see our HTML template [here](https://github.com/Medical-Software-Foundation/canvas/blob/main/extensions/growth_charts/templates/chart.html), which draws many charts based on the observations provided and the percentile curve data provided by the CDC. To make that percentile data usable in our template, we transformed the Excel files from the CDC website into structured data we could use programatically. You can find those python representations of the percentile data [here](https://github.com/Medical-Software-Foundation/canvas/tree/main/extensions/growth_charts/graphs).
Here's an excerpt:
    ```python
    who_boys_length_age = [
        { "x": 0, "y": 46.77032, "z": "5th" },
        { "x": 1, "y": 51.52262, "z": "5th" },
        { "x": 2, "y": 55.13442, "z": "5th" },
        ...,
        { "x": 23, "y": 92.93123, "z": "98th" },
        { "x": 24, "y": 93.92634, "z": "98th" }
    ]
    ```
In addition to the percentile data series, we of course need to plot the patient observation data series. To do this, we create a lists of x and y values corresponding to the patient's age and measurements. You can see this in more detail in the [GitHub repo](https://github.com/Medical-Software-Foundation/canvas/blob/5e8a3dfdb18307e596d2da2d9fce33a3e379cd11/extensions/growth_charts/protocols/growth_charts.py#L80), but here's an excerpt:
    ```python
    import arrow
    import datetime
    from canvas_sdk.effects import Effect
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.observation import Observation
    from canvas_sdk.v1.data.patient import Patient
    def convert_oz_to_kg(oz: str) -> float:
        return float(oz) * 0.0283495
    def get_age_in_months(birth_date: datetime.date, date: datetime.date = datetime.datetime.now()) -> int:
        now = arrow.get(date)
        date = arrow.get(birth_date)
        year_difference = now.year - date.year
        month_difference = now.month - date.month
        return year_difference * 12 + month_difference
    def handle(self) -> list[Effect]:
        graphs = []
        patient = Patient.objects.get(id=self.target)
        sex_at_birth = patient.sex_at_birth
        birth_date = patient.birth_date
        age_in_months = get_age_in_months(birth_date)
        is_less_than_24_months_old = age_in_months < 24
        is_less_than_36_months_old = age_in_months < 36
        observation_weight = Observation.objects.for_patient(self.target).filter(name="weight")
        observation_height = Observation.objects.for_patient(self.target).filter(name="height")
        observation_length = Observation.objects.for_patient(self.target).filter(name="length")
        observation_bmi = Observation.objects.for_patient(self.target).filter(name="bmi")
        observation_head_circumference = Observation.objects.for_patient(self.target).filter(name="head_circumference")
        weight_for_age = {}
        length_for_age = {}
        weight_for_length = {}
        head_for_age = {}
        bmi_for_age = {}
        for obs in observation_weight:
            if obs.value:
                note = Note.objects.get(dbid=obs.note_id)
                age_in_months = get_age_in_months(birth_date, note.datetime_of_service)
                weight_in_kg = convert_oz_to_kg(obs.value)
                weight_for_age[age_in_months] = weight_in_kg
        # ... repeat for other data series
    ```
Finally, we create a list of graphs with the necessary variables and data, which are passed to the template to generate and render the graph.
    ```python
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.templates import render_to_string
    who_boys_length_age = ... # from growth_charts.graphs.who_boys_length_age
    class Protocol(BaseHandler):
        def compute(self):
            # list of graphs
            length_for_age = {} # filled in the actual implementation, see linked GitHub repository
            graphs = [
                {
                    "data": who_boys_length_age, # the data from the graph file
                    "title": 'Length for age (Boys 0 - 2 years)', # graph title
                    "xType": 'Generic', # the type of x axis (Generic, Length, Weight) - We need this info to convert the values 
                    "yType": 'Length', # the type of y axis (Generic, Length, Weight)
                    "xLabel": 'Age', # label for the x axis
                    "yLabel": 'Length', # label for the y axis
                    "zLabel": 'Percentile', # label for the z axis
                    "layerData": length_for_age, # the patient's data that will be plotted on the graph
                    "tab": "WHO" # the section where the graph should be rendered (WHO or CDC)
                },
                # ...repeat for other data series
            ]
            launch_modal = LaunchModalEffect(
                content=render_to_string("templates/chart.html", {"graphs": graphs}),
            )
            return [launch_modal.apply()]
    ```
![chart template](/assets/images/growth-charts.png)
By combining action buttons, the data module, and the `LaunchModalEffect`, you can create unique visualizations to help contextualize patient data for your clinical users.
----- END PAGE https://docs.canvasmedical.com/guides/growth-charts/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/patient-chart-group-items/
This guide explains how to group items on a patient chart section. With this, you can define custom groups to organize medications, conditions, or detected issues.
Currently, this is supported for the Conditions, Medications, and Detected Issues sections.
##  What you'll learn: 
  - Use the [`PatientChartGroup`](/sdk/patient-chart-group-effect) effect to group items in a section by priority.
  - Group conditions based on ICD-10 code ranges
  - Group detected issues (such as coding gaps) by custom criteria
##  Patient Chart Group 
The `PatientChartGroup` effect allows you to group items in a patient chart section. You can define multiple groups with a name, priority, and the items that belong to each group.
####  3\. The plugin 
Here's an example of a plugin that groups conditions based on their codes - here we are creating a "Psychiatry" group for ICD-10 codes F01-F99 and R45.x and placing all matching conditions in that group.
    ```python
    from canvas_sdk.effects.patient_chart_group import PatientChartGroup
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.group import Group
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.commands.constants import CodeSystems
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART__CONDITIONS)
        def compute(self) -> list[Effect]:
            groups: dict[str, Group] = {}
            groups.setdefault("Psychiatry", Group(priority=100, items=[], name="Psychiatry"))
            for condition in self.event.context:
               for coding in condition["codings"]:
                   if coding["system"] == CodeSystems.ICD10 and ("F01" <= coding["code"] <= "F99" or coding["code"].startswith("R45.")):
                       groups["Psychiatry"].items.append(condition)
                       break
            return [PatientChartGroup(items=groups).apply()]
    ```
####  4\. The Output 
Below, you can see how it will appear in the app.
![patient chart group](/assets/images/patient-chart-group.png)
##  Grouping Detected Issues 
You can also group detected issues, such as coding gaps, using the same approach. Here's an example that groups detected issues by their status or other criteria:
    ```python
    from canvas_sdk.effects.patient_chart_group import PatientChartGroup
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.group import Group
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    class GroupDetectedIssues(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART__DETECTED_ISSUES)
        def compute(self) -> list[Effect]:
            groups: dict[str, Group] = {}
            groups.setdefault("High Priority", Group(priority=200, items=[], name="High Priority"))
            groups.setdefault("Standard", Group(priority=100, items=[], name="Standard"))
            for detected_issue in self.event.context:
                # Group by custom logic - for example, based on evidence or other attributes
                # Note: The context for detected issues contains only the "id" field
                # You may need to query additional data using the SDK if needed
                # Example: place first 5 in high priority, rest in standard
                if len(groups["High Priority"].items) < 5:
                    groups["High Priority"].items.append(detected_issue)
                else:
                    groups["Standard"].items.append(detected_issue)
            return [PatientChartGroup(items=groups).apply()]
    ```
**Note:** The context structure for detected issues differs from conditions and medications. The `PATIENT_CHART__DETECTED_ISSUES` event context includes only the `id` field for each detected issue. If you need additional information (such as evidence, status, or code) to determine grouping logic, you'll need to query the detected issue data using the Canvas SDK's data models.
----- END PAGE https://docs.canvasmedical.com/guides/patient-chart-group-items/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/patient-portal-forms/
The Canvas SDK enables custom patient engagement workflows by dynamically displaying forms (questionnaires) within the Patient Portal. This guide walks through implementing a plugin that automatically assigns forms based on a patient's appointment type and previously completed forms. The patient's responses are stored as Interviews, and the developer can choose to generate a Questionnaire Command within a Note.
##  What you'll learn: 
  - Use the [`FormResult`](/sdk/form-result-effect) effect to display questionnaires dynamically.
  - Fetch patient [appointments](/sdk/data-appointment/) and [interviews](/sdk/data-questionnaire/).
  - Control when forms should be shown or hidden.
  - Optionally create a Questionnaire Command inside a Note.
##  Example 
This example assigns intake questionnaires based on the presence of upcoming appointments and adds the completed questionnaires to the visit, authored by the patient.
    ```python
    from canvas_sdk.effects.patient_portal.form_result import FormResult
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import Patient, Appointment, Interview, Note, Questionnaire
    from canvas_sdk.v1.data.appointment import AppointmentProgressStatus
    import arrow
    # 1
    INTAKE_QUESTIONNAIRES = [
      "Insurance Details",
      "Preferred Pharmacy Details",
      "Social History",
    ]
    class Protocol(BaseHandler):
      """Protocol for processing Patient Portal form requests and generating form effects."""
      RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__GET_FORMS)
      def _get_upcoming_appointment_note_id(self, appointments, note_type_names):
        """Retrieve the note_id for the first confirmed future appointment matching given note type names."""
        now = arrow.now().date()
        return appointments.filter(
          status=AppointmentProgressStatus.CONFIRMED,
          start_time__gt=now,
          note_type__name__in=note_type_names
        ).values_list("note__id", flat=True).first()
      def compute(self):
        """Compute and return a list of FormResult effects based on upcoming appointments."""
        # 2
        patient = Patient.objects.get(id=self.target)
        patient_appointments = patient.appointments
        completed_forms = set(
          Interview.objects.filter(
            patient=patient,
            entered_in_error_id__isnull=True,
            questionnaires__name__in=INTAKE_QUESTIONNAIRES
          ).values_list("questionnaires__name", flat=True)
        )
        forms = []
        # Assign Intake Forms for new patients
        if note_id := self._get_upcoming_appointment_note_id(patient_appointments, ["Telehealth", "Office visit"]):
          missing_intake_forms = [qname for qname in INTAKE_QUESTIONNAIRES if qname not in completed_forms]
          missing_intake_questionnaire_ids = Questionnaire.objects.filter(name__in=missing_intake_forms).values_list("id",
                                                                                                                     flat=True)
          #3
          forms = [
            FormResult(questionnaire_id=qid, create_command=True, note_id=note_id).apply()
            for qid in missing_intake_questionnaire_ids
          ]
        return forms
    ```
###  How It Works 
  1. **On each Patient Portal page load** , the plugin evaluates which forms to show. 
     - The example above defines the questionnaire by name. This is an effective way to leverage the same plugin across instances, as questionnaire IDs will differ. You could also filter based on a prefix so that all questionnaires that start with `Portal_` show.
  2. Forms are automatically assigned based on: 
     - **Upcoming Appointments**
     - **Previously completed forms**
  3. If applicable, the response can create a Questionnaire Command inside a Note using the [form result effect](/sdk/form-result-effect/).
  4. The developer is responsible for ensuring that forms do not persist unnecessarily.
##  Adding Form Logic in a Protocol Handler 
We define a **Protocol** that listens for `PATIENT_PORTAL__GET_FORMS` events and determines which forms need to be displayed.
##  Best Practices 
  - **Prevent Duplicate Forms:** Since this logic runs on every page load, check **existing responses** before assigning new forms.
##  Summary 
  - This plugin **automatically assigns Patient Portal forms** based on upcoming appointments.
  - Forms are created as **Questionnaires** , and responses are stored as **Interviews**.
  - The developer can **optionally** create a **Questionnaire Command** inside a **Note**.
  - **Forms are re-evaluated on each page load** , so plugin developers must ensure they don't persist unnecessarily.
----- END PAGE https://docs.canvasmedical.com/guides/patient-portal-forms/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/profile-additional-fields/
This guide explains how to create additional fields that will appear on the patient profile demographics form. With this, you can define custom fields, and the information will be stored as patient metadata.
##  What you'll learn: 
  - Use the [`PatientMetadataCreateForm`](/sdk/patient-metadata-create-form-effect) effect to display additional fields on the patient profile.
  - Use the [`FormField`](/sdk/patient-metadata-create-form-effect/#formfield) class to create fields
##  Patient Metadata Create form plugin 
####  1\. FormField 
To create the form, we need to specify which items will be included. For this, we use the [`FormField`](/sdk/patient-metadata-create-form-effect/#formfield) class, where we can define our inputs and their attributes.
    ```python
    from canvas_sdk.effects.patient_metadata import InputType, FormField
    FormField(
        key='musicGenre',
        label='Preferred music genre',
        type=InputType.TEXT,
        required=False,
        editable=True,
    )
    ```
####  2\. PatientMetadataCreateFormEffect 
The next step is to add these fields to the effect so they can be used to build the form.
    ```python
    from canvas_sdk.effects.patient_metadata import PatientMetadataCreateFormEffect, InputType, FormField
    PatientMetadataCreateFormEffect(form_fields=[
        FormField(
            key='musicGenre',
            label='Preferred music genre',
            type=InputType.TEXT,
            required=False,
            editable=True,
        ),
        ...,
    ])
    ```
####  3\. The plugin 
Here's an example of a complete plugin showcasing the different input types.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient_metadata import PatientMetadataCreateFormEffect, InputType, FormField
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    # Inherit from BaseHandler to properly get registered for events
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_METADATA__GET_ADDITIONAL_FIELDS)
        def compute(self) -> list[Effect]:
            form = PatientMetadataCreateFormEffect(form_fields=[
                FormField(
                    key='musicGenre',
                    label='Preferred music genre',
                    type=InputType.TEXT,
                    required=False,
                    editable=True,
                ),
                FormField(
                    key='occupation',
                    label='Occupation',
                    type=InputType.SELECT,
                    required=False,
                    editable=True,
                    options=["Engineer", "Teacher", "Other"]
                ),
                FormField(
                    key='date',
                    label='Date',
                    type=InputType.DATE,
                    required=False,
                    editable=True,
                ),
            ])
            return [form.apply()]
    ```
####  4\. The Output 
And that's it! Below, you can see how it will appear in the app — these fields will be stored as patient metadata.
![medication widget](/assets/images/additional-fields.png)
----- END PAGE https://docs.canvasmedical.com/guides/profile-additional-fields/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/scribe-ai-parser/
The [AI Scribe Parser Plugin](https://github.com/Medical-Software-Foundation/canvas/tree/main/extensions/ai-scribe) was designed to help streamline clinical documentation by parsing structured transcripts into commands. With healthcare providers increasingly adopting AI-driven solutions, this guide provides developers with the insights and instructions needed to integrate and extend our example plugin to meet diverse documentation needs. In this guide, you'll learn how to:
  - Intercept [`CLIPBOARD_COMMAND__POST_INSERTED_INTO_NOTE`](/sdk/events/#clipboard-command).
  - Use `ScribeParser` (or custom parsers) to process transcripts.
  - Generate commands for each section.
  - Add or replace section parsers for custom sections.
  - Implement a fully custom parser for alternate formats.
##  Understanding the Transcript Parsing Flow. 
The workflow is triggered by pasting a transcript into a note. Doing so will automatically insert the content in the form of a clipboard command. We can then respond to that event and transform the content into the appropriate commands.
###  Input Transcript Example 
Our example transcript includes many structured sections. The sections listed below were flagged as being formatted in a way that makes them easy to translate into Canvas commands.
  - Chief complaint
  - History of present illness
  - Past medical history
  - Vitals
  - Plan
Each section contains specific information that can be parsed. For example:
  - The **Vitals** section includes data like weight, heart rate, and blood pressure, which can be converted into a `VitalsCommand`.
  - The **Assessment** section provides diagnoses and clinical impressions, which can be mapped to an `AssessCommand`.
**Complete Example**
    ```plaintext
    Chief complaint
    - Concern about potential diabetes
    - Hypertension
    History of present illness
    - Patient named Ken, age and gender not mentioned
    - Has sleep apnea, uses CPAP machine
    - Has hyperlipidemia
    - Has hypertension, on medication but doesn't remember the names
    - No other symptoms or issues reported
    - No shortness of breath or pain reported
    Past medical history
    - Sleep apnea
    - Hyperlipidemia
    - Hypertension
    Family history
    No known family history of hypertension
    Social history
    Travels a lot
    Current medications
    Medication for hypertension, names not provided
    Vitals
    - Weight: 244 lbs
    - Height: 5'10"
    - Heart rate: 80
    - Oxygen saturation: 94%
    - Blood pressure: 167/106
    Lab results
    A1C: 5.2 (Normal range, neither prediabetic nor diabetic)
    Physical exam
    CARDIOVASCULAR: Heart sounds good.
    LUNGS: Lungs sound good.
    Assessment
    - Hypertension, not well controlled
    - Sleep apnea, using CPAP machine
    - Hyperlipidemia
    - Elevated BMI, potential for weight loss intervention
    - No diabetes or prediabetes
    Plan
    - Recommendation for weight loss services
    - Recommendation to address hypertension, either at this clinic or with primary care
    - Potential adjustment of hypertension medication
    - Offered subscription program with unlimited office visits and access to a nutritionist
    - Potential telemedicine consultations due to patient's frequent travel
    Appointments
    No specific appointment made, patient to contact clinic after discussing with wife
    ICD-10 codes (3)
    - Sleep apnea, unspecified [G47.30]
    - Hyperlipidemia, unspecified [E78.5]
    - Essential (primary) hypertension [I10]
    ```
###  AI Scribe Plugin Architecture 
Once the content is pasted in, the plugin does the rest. Here's how.
####  1\. Protocol Class 
The `Protocol` class intercepts events and processes the transcript using a parser.
    ```python
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    class ScribeParser: ...  # explained in section 2 below, "ScribeParser"
    class Protocol(BaseProtocol):
        """A Plugin for interpreting transcripts."""
        RESPONDS_TO = EventType.Name(EventType.CLIPBOARD_COMMAND__POST_INSERTED_INTO_NOTE)
        def compute(self) -> list[Effect]:
            """Parse the transcript and generate effects to originate commands."""
            transcript = self.context["fields"]["text"]
            parser = ScribeParser()
            parsed_transcript = parser.parse(transcript, self.context)
            note_uuid = self.context["note"]["uuid"]
            effects = []
            for commands in parsed_transcript.values():
                for command in commands:
                    command.note_uuid = note_uuid
                    effects.append(command.originate(line_number=1))
            effects.reverse()
            return effects
    ```
####  2\. ScribeParser 
The `ScribeParser` delegates the parsing of each transcript section to specific section parsers.
    ```python
    from ai_scribe.parsers.base import TranscriptParser
    # explained in section 3 below, "Section Parsers"
    class ChiefComplaintParser: ...
    class HistoryOfPresentIllnessParser: ...
    class PastMedicalHistoryParser: ...
    class PlanParser: ...
    class VitalsParser: ...
    class ScribeParser(TranscriptParser):
        """A parser for scribe transcripts."""
        section_parsers = {
            "chief_complaint": ChiefComplaintParser(),
            "history_of_present_illness": HistoryOfPresentIllnessParser(),
            "past_medical_history": PastMedicalHistoryParser(),
            "vitals": VitalsParser(),
            "plan": PlanParser(),
        }
        def parse(self, transcript: str, context: dict) -> dict:
            """Parse the transcript into commands grouped by sections."""
            parsed_sections = {}
            for section, parser in self.section_parsers.items():
                parsed_sections[section] = parser.parse(transcript, context)
            return parsed_sections
    ```
####  3\. Section Parsers 
Each section parser extracts relevant information from its section and produces commands.
    ```python
    from typing import Any, Sequence
    from ai_scribe.parsers.base import CommandParser, ParsedContent
    from canvas_sdk.commands.commands.plan import PlanCommand
    class PlanParser(CommandParser):
        """Parses the plan section of a transcript."""
        def parse(self, content: ParsedContent, context: Any = None) -> Sequence[PlanCommand]:
            """Parses the plan section of a transcript."""
            return [PlanCommand(narrative=line) for line in content["arguments"]]
    ```
##  Extending the Parser 
###  1\. Adding a New Section Parser 
Suppose you want to parse the "Appointments" section into a `TaskCommand` for follow-up tasks.
####  Define the Parser 
    ```python
    from typing import Sequence, Any
    from canvas_sdk.commands import TaskCommand
    from ai_scribe.parsers.base import CommandParser, ParsedContent
    class AppointmentsParser(CommandParser):
        """Parses the 'Appointments' section of a transcript."""
        def parse(self, content: ParsedContent, context: Any = None) -> Sequence[TaskCommand]:
            """Parses the Appointments section and generates TaskCommands."""
            tasks = []
            for line in content["arguments"]:
                tasks.append(TaskCommand(title=line))
            return tasks
    ```
####  Register the Parser 
Add the `AppointmentsParser` to the `section_parsers` dictionary.
    ```python
    class AppointmentsParser: ... # defined above
    class ScribeParser:
        """A parser for transcripts."""
        section_parsers = {
            "appointments": AppointmentsParser()
        }
    ```
###  2\. Customizing the Entire Parser 
To replace `ScribeParser`, define your custom parser.
    ```python
    from ai_scribe.parsers.base import (
        ParsedContent,
        TranscriptParser,
        TranscriptParserOutput,
    )
    class CustomParser(TranscriptParser):
        """Custom parser for alternative transcript formats."""
        def parse(self, transcript: str, context: dict) -> dict:
            """Parse the transcript and produce commands."""
            # Implement custom parsing logic
            ...
    ```
Replace the parser in the `Protocol` class:
    ```python
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    class CustomParser: ... # defined above
    class Protocol(BaseProtocol):
        """Protocol using a custom parser."""
        def compute(self) -> list[Effect]:
            transcript = self.context["fields"]["text"]
            parser = CustomParser()  # Use custom parser
            parsed_transcript = parser.parse(transcript, self.context)
            note_uuid = self.context["note"]["uuid"]
            effects = []
            for commands in parsed_transcript.values():
                for command in commands:
                    command.note_uuid = note_uuid
                    effects.append(command.originate(line_number=1))
            effects.reverse()
            return effects
    ```
##  Watch the Workflow in Action 
##  Conclusion 
With robust parsing capabilities and extensibility, this example plugin equips developers to support clinicians in reclaiming their time for what matters most: patient care. By following the steps in this guide, developers can ensure seamless integration into clinical workflows, while also tailoring the tool to suit specific needs.
----- END PAGE https://docs.canvasmedical.com/guides/scribe-ai-parser/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/set-default-homepage/
This guide explains how to set a default homepage for the provider application. By setting a default homepage, you can control which page users see when they first log in to the provider application, ensuring they have quick access to the most relevant information or features.
##  What you'll learn: 
  - Use the [`Application`](/sdk/data/application) model to get a specific application.
  - Use the [`DefaultHomepageEffect`](/sdk/effects/default-homepage-effect) to set the default homepage.
##  Default homepage plugin 
####  1\. Set an application as the homepage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.default_homepage import DefaultHomepageEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import Application
    class Homepage(BaseHandler):
        """Handler for homepage configuration events."""
        RESPONDS_TO = EventType.Name(EventType.GET_HOMEPAGE_CONFIGURATION)
        def compute(self) -> list[Effect]:
            """Set an application as the default homepage."""
            application = Application.objects.filter(name="custom_homepage").first()
            return [DefaultHomepageEffect(application_identifier=application.identifier).apply()]
    ```
####  2\. Set a specific page as the homepage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.default_homepage import DefaultHomepageEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    class Homepage(BaseHandler):
        """Handler for homepage configuration events."""
        RESPONDS_TO = EventType.Name(EventType.GET_HOMEPAGE_CONFIGURATION)
        def compute(self) -> list[Effect]:
            """Set the Patients page as the default homepage."""
            return [DefaultHomepageEffect(page=DefaultHomepageEffect.Pages.PATIENTS).apply()]
    ```
----- END PAGE https://docs.canvasmedical.com/guides/set-default-homepage/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/tailoring-the-chart-to-the-patient/
Different patients have different needs, and your tools should reflect that. EMRs are able to be used in a wide variety of scenarios. In order to be able to do just about anything, your EMR is packed to the gills with features and options. While you might need all of these features for all of your patients, you almost certainly don't need _every_ feature for _each_ of your patients.
This guide shows a few examples of using a patient's data to customize their chart so the EMR features most relevant to them are front-and-center, while minimizing or hiding what you don't need in the moment. Tailoring the interface based on the patient in front of you creates a focused environment for you to deliver care without irrelevant options getting between you and your patient.
> **Info:** This guide assumes pre-existing knowledge of the Canvas SDK. If you're starting from scratch, you may want to read and implement [Your First Plugin (with Claude Code)](/guides/your-first-plugin-with-claude-code/) before working through this exercise. 
##  Chart Customizations for Pediatric Patients 
We will make two simple changes to the charting interface when the selected patient is a child:
  1. Move the Immunization list to the top of the patient summary
  2. Prevent adult-only diagnosis choices from appearing in searches
First, we'll need to initialize a new plugin.
The Canvas CLI gives you a great head start when creating a plugin. Simply run `canvas init`, and answer the prompt to name your plugin.
    ```sh
    $ canvas init
      [1/1] project_name (My Cool Plugin): Pediatric Patient Chart Customizations
    Project created in /Users/andrew/src/canvas-plugins/pediatric-patient-chart-customizations
    ```
This output shows the location of our freshly generated plugin project. In this directory, you'll see a default class (`pediatric_patient_chart_customizations/protocols/my_protocol.py`) provided as a starting point for your code.
    ```sh
    $ tree pediatric_patient_chart_customizations/
    pediatric_patient_chart_customizations/
    ├── CANVAS_MANIFEST.json
    ├── README.md
    └── protocols
        ├── __init__.py
        └── my_protocol.py
    2 directories, 4 files
    ```
You can use this file as a starting point, or you can start fresh with a new file. At minimum, I recommend renaming `my_protocol.py` to something more descriptive, and you'll need to update the references to the file in `CANVAS_MANIFEST.json` as well.
###  Move Immunizations to the Top of the Patient Summary 
I've created a new file, `protocols/pediatric_chart_layout.py`, and I've updated my `CANVAS_MANIFEST.json` to reflect it.
    ```sh
    $ tree pediatric_patient_chart_customizations/
    pediatric_patient_chart_customizations/
    ├── CANVAS_MANIFEST.json
    ├── README.md
    └── protocols
        ├── __init__.py
        └── pediatric_chart_layout.py
    2 directories, 4 files
    ```
Here is a pretty empty class with some comments that will guide our development:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class PediatricChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section to focus on the
        parts most relevant to pediatric patients when it detects that the patient
        for the current chart is <= 17 years old.
        """
        # This event fires when a patient chart's summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            """
            Check to see if the patient is <= 17 years old. If so, move their
            immunization list to the top of the patient summary.
            """
            # Look up the patient whose chart is being loaded right now
            # See if the patient is younger than 18 years old
            # If they are not younger than 18, do nothing
            # If they are younger than 18, re-arrange the layout of their summary
            # sections to put immunizations at the top.
            # BaseHandler subclasses must return a list, but it can be empty. It
            # is empty here since we aren't doing anything just yet.
            return []
    ```
Pretty straightforward logic. Do nothing or do something based on their age.
####  Looking Up the Patient 
In order to determine if we are on a pediatric chart, we'll need to know the patient and their birth date. We can use the [Patient class](/sdk/data-patient/) in the [Data Module](/sdk/data/) for this.
The `PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` event is accompanied by the id of the patient whose chart is being loaded. You can find it using `self.target`. The patient is the target of the event.
    ```python
    import arrow
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.patient import Patient
    class PediatricChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section to focus on the
        parts most relevant to pediatric patients when it detects that the patient
        for the current chart is <= 17 years old.
        """
        # This event fires when a patient chart's summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            """
            Check to see if the patient is <= 17 years old. If so, move their
            immunization list to the top of the patient summary.
            """
            eighteen_years_ago = arrow.now().shift(years=-18).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=self.target, birth_date__gt=eighteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the layout.
            if not patient_is_pediatric:
                return []
            # TODO: Alter the layout
            return []
    ```
In the code above, you'll see I didn't actually retrieve the patient's information. Since I don't plan to use any of the data from the patient record, I instead let the database answer the question: "Does the patient with this id have a birth date more recent than 18 years ago?" This is a performance optimization. The less data transmitted, the faster your plugins execute, and the faster your charts load. This is not strictly necessary, but over time and with enough plugins installed the inefficiencies could add up. If you'd like you could alternately retrieve the patient and make a direct comparison to their `birth_date` attribute.
####  Altering the Layout 
When loading the patient's summary, the front-end consults a list of sections to retrieve data for and render. Our plugin influences this list, and it does so using the [`PatientChartSummaryConfiguration`](https://github.com/canvas-medical/canvas-plugins/blob/main/canvas_sdk/effects/patient_chart_summary_configuration.py) effect. Using the list of possible sections, we construct the ordered list of sections we want to see. In this example we're just moving one to the top, but you could also omit sections to hide them entirely if there are sections you do not use or need for your [Care Model](https://www.canvasmedical.com/articles/care-modeling-the-secret-to-success-in-care-delivery).
    ```python
    import arrow
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.effects.patient_chart_summary_configuration import PatientChartSummaryConfiguration
    from canvas_sdk.v1.data.patient import Patient
    class PediatricChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section to focus on the
        parts most relevant to pediatric patients when it detects that the patient
        for the current chart is <= 17 years old.
        """
        # This event fires when a patient chart's summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            """
            Check to see if the patient is <= 17 years old. If so, move their
            immunization list to the top of the patient summary.
            """
            eighteen_years_ago = arrow.now().shift(years=-18).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=self.target, birth_date__gt=eighteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the layout.
            if not patient_is_pediatric:
                return []
            layout = PatientChartSummaryConfiguration(sections=[
              PatientChartSummaryConfiguration.Section.IMMUNIZATIONS,
              PatientChartSummaryConfiguration.Section.SOCIAL_DETERMINANTS,
              PatientChartSummaryConfiguration.Section.GOALS,
              PatientChartSummaryConfiguration.Section.CONDITIONS,
              PatientChartSummaryConfiguration.Section.MEDICATIONS,
              PatientChartSummaryConfiguration.Section.ALLERGIES,
              PatientChartSummaryConfiguration.Section.CARE_TEAMS,
              PatientChartSummaryConfiguration.Section.VITALS,
              PatientChartSummaryConfiguration.Section.SURGICAL_HISTORY,
              PatientChartSummaryConfiguration.Section.FAMILY_HISTORY,
            ])
            return [layout.apply()]
    ```
Once installed, pediatric patients will have their immunization section at the top of their summary, while adult patients will continue to have social determinants as their initial section.
###  Prevent adult-only diagnosis choices from appearing in searches 
Some diagnosis codes are restricted to adult patients. CMS provides a [list](https://www.cms.gov/Medicare/Coding/OutpatientCodeEdit/Downloads/ICD-10-IOCE-Code-Lists.pdf) of these "Adult Diagnoses". We can reference this list and filter them out of the diagnosis search results for pediatric patients. This increases the quality of your search and makes it easier for you to find the right choice.
I've created a new file, `protocols/pediatric_condition_search.py`, and I've updated my `CANVAS_MANIFEST.json` to reflect it.
Here's the updated plugin file structure:
    ```sh
    $ tree pediatric_patient_chart_customizations/
    pediatric_patient_chart_customizations/
    ├── CANVAS_MANIFEST.json
    ├── README.md
    └── protocols
        ├── __init__.py
        ├── pediatric_chart_layout.py
        └── pediatric_condition_search.py
    2 directories, 5 files
    ```
And here's the updated `CANVAS_MANIFEST.json`:
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "pediatric_patient_chart_customizations",
        "description": "Customizations for pediatric patients",
        "components": {
            "protocols": [
                {
                    "class": "pediatric_patient_chart_customizations.protocols.pediatric_chart_layout:PediatricChartLayout",
                    "description": "Moves the immunization section to the top of the patient summary on pediatric charts.",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                },
                {
                    "class": "pediatric_patient_chart_customizations.protocols.pediatric_condition_search:PediatricConditionSearch",
                    "description": "Filters the condition search to eliminate adult-only conditions on pediatric charts.",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
And here's the very basic outline we'll start out with:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    ADULT_ONLY_ICD_CODES = {
        # There are many, many more. Limiting this example for brevity.
        # ...
        "Z561",   # Change of job
        "Z5682",  # Military deployment status
        # ...
    }
    class PediatricConditionSearch(BaseHandler):
        """
        Filter condition searches for pediatric patients.
        """
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
        ]
        def compute(self):
            """
            Remove condition search results representing codings that are resevered
            for adults if the patient is <= 15 years old.
            """
            # This event's target is the command we are searching within. Look up
            # the patient id from the command, and use that to look up the patient.
            # If the patient is not pediatric, do not alter the search.
            # If the patient is pediatric, loop through the search results, and
            # compare the codings of the options with our list of adult-only
            # diagnosis codes. If it's an adult only code, remove it from the
            # list.
            return []
    ```
Using the list provided by CMS, we can create a set of ICD-10 codes that should be restricted to adults. According to CMS, these diagnoses are only relevant to patients 15 or older.
While the layout altering class responded to a single event, we're listening for two different events here: diagnose command search and past medical history command search. Both of these commands include a diagnosis code search box, so we'll want to affect both. We wouldn't want to impact a family history command diagnosis search, since the family members recorded there are often adults.
####  Looking Up the Patient 
In the previous example, the target of the `PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` event was the patient. For the events we're responding to here, the target is the [command](/sdk/data-command/) that the search is occurring within. In order to determine if the patient is young enough for our code to be invoked, we'll first look up the patient's id from the command, then assess their age in a similar manner as before.
    ```python
    import arrow
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    ADULT_ONLY_ICD_CODES = {
        # There are many, many more. Limiting this example for brevity.
        # ...
        "Z561",   # Change of job
        "Z5682",  # Military deployment status
        # ...
    }
    class PediatricConditionSearch(BaseHandler):
        """
        Filter condition searches for pediatric patients.
        """
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
        ]
        def compute(self):
            """
            Remove condition search results representing codings that are resevered
            for adults if the patient is <= 15 years old.
            """
            # This event's target is the command we are searching within. Look up
            # the patient id from the command.
            patient_id = Command.objects.filter(id=self.target).values_list('patient__id', flat=True).first()
            fifteen_years_ago = arrow.now().shift(years=-15).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=patient_id, birth_date__gt=fifteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the search.
            # If the patient is pediatric, loop through the search results, and
            # compare the codings of the options with our list of adult-only
            # diagnosis codes. If it's an adult only code, remove it from the
            # list.
            return []
    ```
Once again you see some code that optimizes for performance over readability. If you're not familiar with the Django ORM, this code:
    ```python
    patient_id = Command.objects.filter(id=self.target).values_list('patient__id', flat=True).first()
    ```
Is equivalent to this code, which you may find more readable:
    ```python
    command = Command.objects.get(id=self.target)
    patient_id = command.patient.id
    ```
However you get to the patient's id is up to you. Once you have it, the code is nearly identical to the previous example, the only difference being the age we're targeting. We are asking the database "Does the patient with this id have a birth date more recent than 15 years ago?"
####  Altering the Layout 
Now that we know when we should act, we need to write the code for filtering the list of search results. When the search is performed, the raw results are sent to our code before being ultimately delivered to the dropdown box in the front-end. We have the opportunity to modify that list before it hits the dropdown. While we're focused on removing irrelevant choices, you could also add labels to certain ones you wish to highlight or alter the search order to guide users to preferred options.
Our code loops through the ICD-10 codes associated with the search results, checks for their presence in the set of adult ICD-10 codes, and only includes them in the post-processed set if they are not in the adult code list. The raw search results are in the event's context object under the `results` key.
Here's the full code:
    ```python
    import json
    import arrow
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    ADULT_ONLY_ICD_CODES = {
        # There are many, many more. Limiting this example for brevity.
        # ...
        "Z561",   # Change of job
        "Z5682",  # Military deployment status
        # ...
    }
    class PediatricConditionSearch(BaseHandler):
        """
        Filter condition searches for pediatric patients.
        """
        RESPONDS_TO = [
            EventType.Name(EventType.DIAGNOSE__DIAGNOSE__POST_SEARCH),
            EventType.Name(EventType.MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH),
        ]
        def compute(self):
            """
            Remove condition search results representing codings that are resevered
            for adults if the patient is <= 15 years old.
            """
            results = self.context.get("results")
            if results is None:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            # This event's target is the command we are searching within. Look up
            # the patient id from the command.
            patient_id = Command.objects.filter(id=self.target).values_list('patient__id', flat=True).first()
            fifteen_years_ago = arrow.now().shift(years=-15).date().isoformat()
            patient_is_pediatric = Patient.objects.filter(
                id=patient_id, birth_date__gt=fifteen_years_ago).exists()
            # If the patient is not pediatric, do not alter the search.
            if not patient_is_pediatric:
                return [Effect(type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS, payload=json.dumps(None))]
            # Create our container for modified search results
            post_processed_results = []
            # Loop through the ICD 10 codes associated with the results
            for result in self.context["results"]:
                for coding in result.get("extra", {}).get("coding", []):
                    if not coding.get("system") in ("http://hl7.org/fhir/sid/icd-10", "ICD-10"):
                        continue
                    # If the ICD 10 code is not in the list of Adult-only codes,
                    # we can add this result to what will ultimately be returned.
                    if coding.get("code") not in ADULT_ONLY_ICD_CODES:
                        post_processed_results.append(result)
                        break
            # Return our modified search results
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
    ```
Once installed, certain diagnosis codes will not clutter up search results in commands for pediatric patients, but will continue to show as expected for patients over the age of 15.
##  Watch the Workflow in Action 
View and deploy the Pediatric Patient Chart Customization Extension [here](https://www.canvasmedical.com/extensions/pediatric-patient-chart-customizations).
##  Conclusion 
Age is one differentiator that changes the relevance of EMR features, but there are many, many others. Using the Canvas SDK can help keep clinicians focused, with the features they need front-and-center and the ones they don't need out of the way.
----- END PAGE https://docs.canvasmedical.com/guides/tailoring-the-chart-to-the-patient/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/your-first-application/
This guide will walk you through the process of installing, initializing, and customizing embeddable applications in Canvas.
##  What Are Applications in Canvas? 
Applications in Canvas are embeddable plugins that enhance the functionality of the Canvas platform. They allow developers to create custom features accessible directly from within the Canvas interface, such as interactive tools, data visualizations, or workflow integrations. These applications can be configured to appear globally or within specific contexts, such as the patient chart page.
##  Step 1: Install and Configure the Canvas CLI 
Follow the instructions in the [Canvas documentation](https://docs.canvasmedical.com/guides/your-first-plugin/#1-install-the-canvas-cli) to install and configure the Canvas CLI. Once complete, ensure that you can successfully run `canvas` commands from your terminal.
##  Step 2: Initialize an Application 
To create a new application, run the following command:
    ```bash
    canvas init application
    ```
This will generate a boilerplate application along with a `CANVAS_MANIFEST.json` file.
##  Step 3: Understanding the `CANVAS_MANIFEST.json` File 
The `CANVAS_MANIFEST.json` file describes your application and its components. Below is an example of a manifest and a description of the customizable properties:
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "my_cool_application",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "url_permissions": [
            {
                "url": "https://my-application.com",
                "permissions": []
            }
        ],
        "components": {
            "applications": [
                {
                    "class": "my_cool_application.applications.my_application:MyApplication",
                    "name": "My Application",
                    "description": "An Application that does xyz...",
                    "scope": "global",
                    "icon": "assets/python-logo.png",
                    "menu_position": "top",
                    "menu_order": "100",
                    "show_in_panel": false,
                    "panel_priority": 100
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
###  Customizable Properties 
  1. **name** : The display name of the application.
  2. **description** : A brief description of the application.
  3. **icon** : The icon for the application. This can be a URL to an image or a path inside the plugin package.
  4. **scope** : 
     - `global`: The app will appear across all contexts.
     - `patient_specific`: The app will appear only in the patient chart page.
     - `provider_menu_item`: The app button will be displayed on the provider's menu.
     - `portal_menu_item`: The app button will be displayed on the patient portal menu.
  5. **url_permissions** : The allowed urls and permissions for the application. This is used for security purposes. For more info check the [Application Handler](/sdk/
handlers-applications).
  6. **menu_position** : Determines where the menu item will be placed within the menu (this configuration applies only to the providers menu) 
     - `top`: The item will be placed on the top section.
     - `bottom`: The item will be placed in the bottom section - this section should display items that open in a new window.
  7. **menu_order** : How the items will be ordered in the menu. e.g 100, 200
  8. **show_in_panel** : If you want to increase your application's visibility and display it alongside other panel buttons (instead of in the applications drawer), you can set this attribute
  9. **panel_priority** : How the applications will be ordered in the panel section. e.g 100, 200
##  Step 4: Overriding the Application Behavior 
Developers must extend the `Application` class and override the `on_open` method to define the behavior when the app icon is clicked. Below is an example implementation:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class MyApplication(Application):
        """An embeddable application that can be registered to Canvas."""
        def on_open(self) -> Effect:
            """Handle the on_open event."""
            # Implement this method to handle the application on_open event.
            return LaunchModalEffect(
                url="http://localhost:8000",
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL
            ).apply()
    ```
###  Key Details 
  - **`on_open` Method**: 
    - Called when the user clicks on the app icon.
    - Should return a `LaunchModalEffect` that specifies: 
      - **url** : The URL to open.
      - **target** : The display target.
###  Target Options 
  - `DEFAULT_MODAL`: Opens the URL in a modal centered on the screen.
  - `NEW_WINDOW`: Opens the URL in a new browser window.
  - `PAGE`: Opens the URL as a page in the app
  - `RIGHT_CHART_PANE`: Opens the URL in the right-hand pane of the patient chart.
  - `RIGHT_CHART_PANE_LARGE`: Opens the URL in an enlarged right-hand pane of the patient chart.
##  Step 5: Installing the Application 
To install your application, run:
    ```bash
    canvas install <path/to/application>
    ```
----- END PAGE https://docs.canvasmedical.com/guides/your-first-application/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/your-first-plugin-with-claude-code/
Canvas plugins let you customize the EHR — reacting to events, reading patient data, and returning effects that alter workflows. This guide uses an AI-assisted approach powered by Claude Code and the Canvas Plugin Assistant (CPA), getting you from idea to deployed plugin in minutes.
> **Info:** Haven't yet advanced to AI-assisted coding? See [Your First Plugin (Manual)](/guides/your-first-plugin/) to build your plugin by hand. 
##  Background: AI-Assisted Plugin Development 
[Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) is Anthropic's agentic coding tool — it can read, write, and execute code autonomously in your terminal. Rather than copying and pasting snippets from documentation or typing code by hand, you can describe what you want in plain English and Claude Code does the programming with your supervision.
Claude Code supports a plugin marketplace. We built the Canvas Plugin Assistant (CPA) Claude Code plugin (yes, a plugin to make plugins!) with deep knowledge of the Canvas SDK, common plugin patterns, and best-practice workflows in plugin development.
CPA accelerates the entire plugin development lifecycle — from brainstorming requirements and scaffolding code, to running tests and deploying to your instance and rapidly cycling through user acceptance testing and enhancements.
Together, Claude Code with CPA lets developers go from an idea to a working, deployed plugin through natural conversation at warp speed.
##  Prerequisites 
  - Python 3.12+ installed
  - A Canvas instance with admin access
  - [OAuth credentials configured](/api/customer-authentication/) and saved locally in `~/.canvas/credentials.ini` (register an application with `confidential` client type and `client-credentials` grant type). For more, see [these configuration steps](/guides/your-first-plugin/#2-configure-the-canvas-cli-for-your-instances)
  - [Claude Code installed](https://docs.anthropic.com/en/docs/claude-code/overview)
##  1\. Install the Canvas Plugin Assistant and Set Up Your Environment 
Follow the installation and setup instructions in the [Canvas Plugin Assistant README](https://github.com/canvas-medical/coding-agents/tree/main/canvas-plugin-assistant). Once complete, run `/cpa:check-setup` to verify everything is ready.
##  2\. Describe Your First Plugin 
Run `/cpa:new-plugin` to start building. CPA will ask clarifying questions via an interactive chip interface. Describe what you want in plain English. You can find examples of what's possible [here](https://github.com/Medical-Software-Foundation/canvas/tree/main/extensions), [here](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins), and [here](https://www.canvasmedical.com/plugins). For example:
> I want a plugin that adds a button to the note header. When clicked, the button should inject a Reason for Visit command into the note with the text "hello world".
Here's what happens next:
  1. **Brainstorm** — CPA asks follow-up questions to refine your requirements
  2. **Specification** — CPA generates a `plugin-spec.md` for your review. Read through it and approve or request changes
  3. **Scaffold** — CPA creates the [plugin project structure](/guides/your-first-plugin/#4-navigate-the-structure-of-a-plugin), manifest, and handler files
  4. **Implement** — CPA writes the protocol/handler code based on the spec
  5. **Test** — CPA generates and runs tests to verify the plugin works correctly
At any point, if you have more detail and direction to give, in any format (other markdown files, PDF files, images), you can simply instruct Claude to read those files and use them in formulating the plan.
##  3\. Deploy and Test 
When you're at the point of completion where you need to try the plugin yourself, run:
    ```text
    /cpa:deploy
    ```
CPA validates the plugin, bumps the version, deploys it to your Canvas instance, and starts log monitoring so you can see output in real time.
To test our example first plugin, open a patient chart in your Canvas instance, create a new note, and click the button in the note header. You should see a Reason for Visit command appear with the text "hello world".
##  4\. Next Steps: Keep Iterating in Conversation with Claude 
The real power of AI-assisted development is iterating. Now that your plugin is deployed, enhance it with follow-up prompts:
###  Make it dynamic and patient-specific 
Ask CPA to update the plugin so the RFV text follows the classic clinical one-liner format, pulling patient data dynamically from the Canvas data module:
> Update the plugin so instead of "hello world", the RFV text is a clinical one-liner: "{patient first and last name} is a {age} year old {sex} presenting with ___". Pull the patient data dynamically.
###  Handle existing RFV 
Ask CPA to handle the case where the note already has a Reason for Visit command — editing the existing one instead of creating a duplicate:
> Update the plugin to check if the note already has a Reason for Visit command. If it does, edit the existing one instead of creating a new one.
###  Ask Claude to check logs and troubleshoot 
The `/cpa:deploy` command will start a subagent called `deploy-uat`, which runs a background task to access the `canvas logs` stream. Ask Claude to look at them anytime you need help troubleshooting. You can also of course view logs in the shell manually with:
    ```bash
    uv run canvas logs <your-instance>
    ```
###  Keep going 
Continue exploring the [SDK documentation](/sdk/) and browse other [guides](/guides/) to see what's possible with Canvas plugins. When you're ready to harden your plugin for production, run `/cpa:coverage` to check test coverage and improve tests, `/cpa:security-review` to audit for common security issues, and `/cpa:database-performance-review` to ensure efficient data retrieval. When you feel everything is ready to finalize, use the `/cpa:wrap-up` command.
----- END PAGE https://docs.canvasmedical.com/guides/your-first-plugin-with-claude-code/


----- BEGIN PAGE https://docs.canvasmedical.com/guides/your-first-plugin/
Plugins are your tool for customizing the Canvas experience. By using the modules of the Canvas SDK, you can react to [events](/sdk/events/) emitted from the EHR, request additional [data](/sdk/data/) if needed, and respond with [effects](/sdk/effects/) that alter workflows and add or change data in Canvas. You can also use [utils](/sdk/utils/) to do things like call out to web services with our provided HTTP client.
> **Warning:** This guide is for manual coding. Want a faster, AI-assisted approach? Check out [Your First Plugin (with Claude Code)](/guides/your-first-plugin-with-claude-code/), which uses an AI assistant to guide you through building and deploying your plugin. 
##  Video 
The video below showcases a Canvas engineer working through this guide step-by-step.
##  1\. Install the Canvas CLI 
To install the Canvas CLI, simply `pip install canvas`. Python 3.11 or 3.12 is required. You can find additional detail on the features of the Canvas CLI [here](/sdk/canvas_cli/).
##  2\. Configure the Canvas CLI for your instances 
The Canvas CLI uses OAuth credentials to connect to your Canvas instance. If you've used our FHIR API, you'll be very familiar with the process for [registering credentials](/api/customer-authentication/). Register a separate OAuth application, choosing `confidential` for the Client type, and `client-credentials` for the Authorization grant type. Redirect URIs can be left blank, and the Algorithm should be `No OIDC support`. Note the client_id and client_secret for the next step.
Create a file at the path `~/.canvas/credentials.ini`. Here is what its contents should look like:
    ```ini
    [buttered-popcorn]
    client_id=butter
    client_secret=salt
    [buttered-popcorn-dev]
    client_id=devbutter
    client_secret=devsalt
    is_default=true
    ```
Each section represents credentials for a different Canvas instance. Replace the section headers with your Canvas subdomains. The example configuration provided would be valid for instances with URLs `https://buttered-popcorn.canvasmedical.com` and `https://buttered-popcorn-dev.canvasmedical.com`.
You can optionally set the `is_default` flag for the instance you wish to be implied when using the CLI. If no section is set as default, the first one will be considered default.
##  3\. Initialize a new plugin 
The Canvas CLI gives you a great head start when creating a plugin. Simply run `canvas init`, and answer the prompt to name your plugin.
    ```sh
    $ canvas init
      [1/1] project_name (My Cool Plugin): Paperwork Eviscerator
    Project created in /Users/andrew/src/canvas-plugins/paperwork-eviscerator
    ```
This output shows the location of our freshly generated plugin project.
##  4\. Navigate the structure of a plugin 
Let's take a look at what was generated for us.
    ```sh
    $ tree paperwork-eviscerator/
    paperwork-eviscerator/
    ├── paperwork_eviscerator
    │    ├── CANVAS_MANIFEST.json
    │    ├── README.md
    │    └── protocols
    │         ├── __init__.py
    │         └── my_protocol.py
    ├── pyproject.toml
    └── tests
        ├── __init__.py
        └── test_models.py
    5 directories, 9 files
    ```
###  CANVAS_MANIFEST.json 
The CANVAS_MANIFEST.json is particularly important. It is used during the installation of the plugin.
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "paperwork_eviscerator",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "components": {
            "protocols": [
                {
                    "class": "paperwork_eviscerator.protocols.my_protocol:Protocol",
                    "description": "A protocol that does xyz...",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": ["my_secret_code"],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
The name, plugin version, and description are all surfaced in your Canvas instance when viewing installed plugins.
Only protocols declared here are invoked by the plugin runner. If they are not declared, they will be ignored.
Secrets can be declared (though not defined) here. Any secrets declared here will be initialized on plugin install, and can be set in the plugin listing in the Settings section of your Canvas instance.
###  README.md 
Share details about the purpose of your plugins and how it works in this README file.
###  protocols/my_protocol.py 
This file contains the protocol class declared in the manifest file. We've included some sample content and copious comments for inspiration.
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    # Inherit from BaseProtocol to properly get registered for events
    class Protocol(BaseProtocol):
        """
        You should put a helpful description of this protocol's behavior here.
        """
        # Name the event type you wish to run in response to
        RESPONDS_TO = EventType.Name(EventType.ASSESS_COMMAND__CONDITION_SELECTED)
        NARRATIVE_STRING = "I was inserted from my plugin's protocol."
        def compute(self):
            """
            This method gets called when an event of the type RESPONDS_TO is fired.
            """
            # This class is initialized with several pieces of information you can
            # access.
            #
            # `self.event` is the event object that caused this method to be
            # called.
            #
            # `self.target` is an identifier for the object that is the subject of
            # the event. In this case, it would be the identifier of the assess
            # command. If this was a patient create event, it would be the
            # identifier of the patient. If this was a task update event, it would
            # be the identifier of the task. Etc, etc.
            #
            # `self.context` is a python dictionary of additional data that was
            # given with the event. The information given here depends on the
            # event type.
            #
            # `self.secrets` is a python dictionary of the secrets you defined in
            # your CANVAS_MANIFEST.json and set values for in the uploaded
            # plugin's configuration page: <emr_base_url>/admin/plugin_io/plugin/<plugin_id>/change/
            # Example: self.secrets['WEBHOOK_URL']
            # You can log things and see them using the Canvas CLI's log streaming
            # function.
            log.info(self.NARRATIVE_STRING)
            # Craft a payload to be returned with the effect(s).
            payload = {
                "note": {"uuid": self.context["note"]["uuid"]},
                "data": {"narrative": self.NARRATIVE_STRING},
            }
            # Return zero, one, or many effects.
            # Example:
            # return [Effect(type=EffectType.LOG, payload=json.dumps(payload))]
            return []
    ```
##  5\. Listen for an Event 
Set the `RESPONDS_TO` value to the [Event Type](/sdk/events/#event-types) you're interested in.
##  6\. Return an Effect 
Form an [Effect](/sdk/effects/#effect-types) to return to your Canvas instance.
##  7\. Deploy and use your plugin 
When your plugin is just the way you'd like it, deploying is simple. Navigate to the root of your plugin project (i.e. `paperwork-eviscerator/`) and run `canvas install <path/to/plugin_package>` (i.e. `canvas install paperwork_eviscerator`) and your plugin will be packaged, uploaded, installed, and enabled. As you make changes to your plugin, run the same command to update the code of the installed plugin.
##  8\. Tail the logs 
To view logs and to surface any errors with your plugin, run `canvas logs --host buttered-popcorn-dev` (replace with your Canvas instance name). This will tail the logs for all plugins installed on that instance.
----- END PAGE https://docs.canvasmedical.com/guides/your-first-plugin/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/
##  Get started 
Here are some step-by-step guides to get you started:
[ Your First Plugin (with Claude Code) Use an AI assistant to build and deploy your first Canvas plugin through natural conversation. ](/guides/your-first-plugin-with-claude-code) [ Your First Plugin (Manual) This guide steps you through installing the Canvas SDK, creating a plugin, and deploying it to a Canvas instance. ](/guides/your-first-plugin) [ Creating Webhooks Make automatic API requests based on Canvas events ](/guides/creating-webhooks-with-the-canvas-sdk) [ Customize Search Results Add your own logic to surface the right options with the appropriate context ](/guides/customize-search-results)
And here are some other [guides](/guides)
##  What is the Canvas SDK? 
The Canvas SDK is your toolkit for customizing workflows natively across the full Canvas platform: scheduling, charting, billing, and more. It is a [python package](https://pypi.org/project/canvas/) used to develop and deploy plugins, which then run in this [open source runtime environment](https://github.com/canvas-medical/canvas-plugins) on your Canvas instance.
Plugins, the custom packages you author with the Canvas SDK, run in a sandboxed process directly on the Canvas instance. The Canvas application emits many [events](/sdk/events) at runtime, which you can choose to respond to and produce some number of [effects](/sdk/effects). These effects are then interpreted by the Canvas application, which applies the changes your plugin returned. Events are accompanied by contextual information, and your plugin has access to additional information through the [data module](/sdk/data), which exposes a subset of the Canvas application database through a series of [Django ORM classes](https://docs.djangoproject.com/en/5.1/ref/models/querysets/) backed by read-only views. The SDK also includes a [clients module](/sdk/clients/) with pre-built integrations for third-party services like AI/ML providers, cloud storage, email, and messaging.
##  Where can I get additional help? 
Our [open-source GitHub repo](https://github.com/canvas-medical/canvas-plugins) has a [discussions](https://github.com/canvas-medical/canvas-plugins/discussions) section, where you can request help or suggest improvements. We also welcome [issue reports](https://github.com/canvas-medical/canvas-plugins/issues) and [pull requests](https://github.com/canvas-medical/canvas-plugins/pulls)!
Ready? Get started!
----- END PAGE https://docs.canvasmedical.com/sdk/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/appointment-metadata-create-form-effect/
##  Overview 
This allows developers to dynamically display additional fields when scheduling an appointment.
    ```python
    from canvas_sdk.effects.appointments_metadata import (
        FormField,
        InputType,
        AppointmentsMetadataCreateFormEffect,
    )
    AppointmentsMetadataCreateFormEffect(form_fields=[
        FormField(
            key='status',
            label='Status',
            type=InputType.SELECT,
            required=False,
            editable=True,
            options=["open", "close"],
            value=""
        ),
    ])
    ```
##  Structure 
###  **FormField**
A FormField consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`key` | `str` | unique identifier of the field - appointment metadata key  
`label` | `str` | the label that will be displayed on the field  
`type` | `InputType` | the type of the input - TEXT, SELECT, DATE.  
`required` | `bool` | if the input is required.  
`editable` | `bool` | if the input can be editabled.  
`options` | `list[str]` | possible options for when the input type is set to "SELECT"  
`value` | `str` | default value for the field  
###  **AppointmentsMetadataCreateFormEffect**
An AppointmentsMetadataCreateFormEffect consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`form_fields` | `list[FormField]` | list of fields.  
----- END PAGE https://docs.canvasmedical.com/sdk/appointment-metadata-create-form-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/caching/
The Canvas SDK provides a caching API for plugin developers to store and retrieve temporary data efficiently.
* * *
##  Getting the Cache Client 
To use the cache in your plugin, simply import and call:
    ```python
    from canvas_sdk.caching.plugins import get_cache
    cache = get_cache()
    ```
* * *
##  TTL and Expiration 
  - By default, all cached keys expire after **14 days**.
  - You can set a shorter TTL when writing to the cache via the `timeout_seconds` parameter.
  - If a longer TTL is provided, a `CachingException` will be raised.
* * *
##  Supported Methods 
###  `get(key: str, default: Any | None = None) -> Any`
Retrieve a value from the cache:
    ```python
    user = cache.get("key")
    ```
You can specify a fallback if the key doesn't exist:
    ```python
    user = cache.get("key", default="default_value")
    ```
* * *
###  `set(key: str, value: Any, timeout_seconds: int | None = None) -> None`
Store a value in the cache:
    ```python
    cache.set("key", {"name": "Alice"}, timeout_seconds=600)
    ```
* * *
###  `get_or_set(key: str, default: Any | Callable, timeout_seconds: int | None = None) -> Any`
Fetch a value or set it if not present:
    ```python
    value = cache.get_or_set("key", default=lambda: compute_value(), timeout_seconds=300)
    ```
* * *
###  `set_many(data: dict[str, Any], timeout_seconds: int | None = None) -> list[str]`
Set multiple values at once:
    ```python
    cache.set_many({
        "key1": {"name": "Alice"},
        "key2": {"name": "Bob"}
    }, timeout_seconds=900)
    ```
* * *
###  `get_many(keys: Iterable[str]) -> dict[str, Any]`
Fetch multiple values in one operation:
    ```python
    users = cache.get_many(["key1", "key2"])
    ```
* * *
###  `delete(key: str) -> None`
Remove a key from the cache:
    ```python
    cache.delete("key")
    ```
* * *
###  `__contains__(key: str) -> bool`
Check if a key exists in cache:
    ```python
    if "key" in cache:
        ...
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/caching/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/calendar-create-effect/
##  Overview 
This allows developers to create calendars for providers in Canvas. Calendars can be either Clinic or Administrative type and can optionally be associated with a location.
    ```python
    from canvas_sdk.effects.calendar import Calendar, CalendarType
    Calendar(
       provider="provider-uuid",
       type=CalendarType.Clinic,
       location="location-uuid",
       description="Primary clinic calendar"
    ).create()
    ```
##  Structure 
###  **CalendarType**
An enumeration of calendar types:
Value | Description  
---|---  
`Clinic` | Calendar for clinical appointments  
`Administrative` | Calendar for administrative tasks  
###  **Calendar**
A Calendar effect consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`id` | `str \| UUID \| None` | Optional unique identifier for the calendar.  
`provider` | `str \| UUID` | The provider UUID  
`type` | `CalendarType` | The type of calendar - either `CalendarType.Clinic` or `CalendarType.Administrative`  
`location` | `str \| UUID \| None` | location UUID to associate with the calendar.  
`description` | `str \| None` | description of the calendar's purpose.
----- END PAGE https://docs.canvasmedical.com/sdk/calendar-create-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/calendar-event-management-effects/
##  Overview 
This allows developers to create, update, and delete calendar events for providers in Canvas. Events can be one-time or recurring, with support for daily and weekly recurrence patterns.
    ```python
    from canvas_sdk.effects.calendar import Event, EventRecurrence, DaysOfWeek
    from datetime import datetime
    # Create a one-time event
    Event(
        calendar_id="calendar-uuid",
        title="Patient Consultation",
        starts_at=datetime(2025, 1, 15, 9, 0),
        ends_at=datetime(2025, 1, 15, 10, 0)
    ).create()
    # Create a recurring event
    Event(
        calendar_id="calendar-uuid",
        title="Weekly Team Meeting",
        starts_at=datetime(2025, 1, 15, 14, 0),
        ends_at=datetime(2025, 1, 15, 15, 0),
        recurrence_frequency=EventRecurrence.Weekly,
        recurrence_interval=1,
        recurrence_days=[DaysOfWeek.Monday, DaysOfWeek.Wednesday],
        recurrence_ends_at=datetime(2025, 12, 31, 23, 59),
        allowed_note_types=["100", "101"]
    ).create()
    # Update an existing event
    Event(
        event_id="event-uuid",
        title="Updated Meeting Title",
        starts_at=datetime(2025, 1, 15, 15, 0),
        ends_at=datetime(2025, 1, 15, 16, 0)
    ).update()
    # Delete an event
    Event(event_id="event-uuid").delete()
    ```
##  Structure 
###  **EventRecurrence**
An enumeration of recurrence frequency options:
Value | Description  
---|---  
`Daily` | Event recurs daily  
`Weekly` | Event recurs weekly  
###  **DaysOfWeek**
An enumeration of days of the week for recurring events:
Value | Description  
---|---  
`MO` | Monday  
`TU` | Tuesday  
`WE` | Wednesday  
`TH` | Thursday  
`FR` | Friday  
`SA` | Saturday  
`SU` | Sunday  
###  **Event**
An Event effect consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`calendar_id` | `str \| UUID \| None` | The calendar UUID where the event will be created.  
`event_id` | `str \| UUID \| None` | The event UUID to update.  
`title` | `str \| None` | The title of the event.  
`starts_at` | `datetime \| None` | The start date and time of the event.  
`ends_at` | `datetime \| None` | The end date and time of the event.  
`recurrence_frequency` | `EventRecurrence \| None` | The frequency of recurrence - either `EventRecurrence.Daily` or `EventRecurrence.Weekly`.  
`recurrence_interval` | `int \| None` | The interval between recurrences (e.g., 1 for every week, 2 for every other week).  
`recurrence_days` | `list[DaysOfWeek] \| None` | List of days when the event should recur (used with weekly recurrence).  
`recurrence_ends_at` | `datetime \| None` | The date and time when the recurrence pattern ends.  
`allowed_note_types` | `list[str] \| None` | List of note types that are allowed for this event.
----- END PAGE https://docs.canvasmedical.com/sdk/calendar-event-management-effects/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/canvas_cli/
##  Getting Started 
###  Installation using `pip`
To install the Canvas CLI using `pip`, execute `pip install canvas`. Python 3.11, 3.12, or 3.13 is required.
To upgrade the Canvas CLI if you installed using `pip`, execute `pip install --upgrade canvas`.
###  Installation using `uv`
To install the Canvas CLI using `uv`, execute `uv tool install canvas`. `uv` will find or procure an acceptable Python version.
To upgrade the Canvas CLI if you installed using `uv`, execute `uv tool upgrade canvas`.
###  Configuration and Authenticating to Your Canvas Instance 
Create a file `~/.canvas/credentials.ini` with sections for each of your Canvas instance subdomains, and add client_id and client_secret credentials to each section. For example, if your Canvas instance url is `https://buttered-popcorn.canvasmedical.com/`, you would have a section `[buttered-popcorn]` with key-value pairs for `client_id` and `client_secret`.
> **Info:** **Getting Credentials:** Learn how to get register a client_id and client_secret [here](/api/customer-authentication/#registering-a-third-party-application-on-canvas).  
> The Canvas CLI uses OAuth, just like the FHIR API. 
**Example:**
    ```ini
    [buttered-popcorn]
    client_id=butter
    client_secret=salt
    [dev-buttered-popcorn]
    client_id=devbutter
    client_secret=devsalt
    is_default=true
    [localhost]
    client_id=localclientid
    client_secret=localclientsecret
    ```
You can define your default host with `is_default=true`. If no default is explicitly defined, the Canvas CLI will use the first instance in the file as the default for each of the CLI commands.
**You are now ready to use the Canvas CLI**
##  Usage 
    ```console
    $ canvas [OPTIONS] COMMAND [ARGS]...
    ```
**Options** :
  - `--version`
  - `--help`: Show this message and exit.
##  Commands 
  - `init`: Create a new plugin
  - `install`: Install a plugin into a Canvas instance
  - `uninstall`: Uninstall a plugin from a Canvas instance
  - `enable`: Enable a plugin from a Canvas instance
  - `disable`: Disable a plugin from a Canvas instance
  - `list`: List all plugins from a Canvas instance
  - `validate-manifest`: Validate the Canvas Manifest json file
  - `logs`: Listen and print log streams from a Canvas instance
  - `config list`: List all secrets from a plugin
  - `config set`: Configure plugin secrets
###  `canvas init`
Create a new plugin.
**Usage** :
    ```console
    $ canvas init [OPTIONS]
    ```
**Options** :
  - `--help`: Show this message and exit.
###  `canvas install`
Install a plugin into a Canvas instance.
**Usage** :
    ```console
    $ canvas install [OPTIONS] PLUGIN_NAME
    ```
**Arguments** :
  - `PLUGIN_NAME`: Path to plugin to install [required]
**Options** :
  - `--secret TEXT`: Secrets to set, e.g. Key=value
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
**Notes** :
Files can be excluded from the packaged plugin using a `.canvasignore` in the current working directory. The file behaves similarly to [.gitignore](https://git-scm.com/docs/gitignore)
Example
    ```md
    # Exclude test files
    test_*.py
    ```
###  `canvas uninstall`
Uninstall a plugin from a Canvas instance.
**Usage** :
    ```console
    $ canvas uninstall [OPTIONS] NAME
    ```
**Arguments** :
  - `NAME`: Plugin name to delete [required]
**Options** :
  - `--force`: Force uninstallation of the plugin
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
###  `canvas enable`
Enable a plugin from a Canvas instance..
**Usage** :
    ```console
    $ canvas enable [OPTIONS] NAME
    ```
**Arguments** :
  - `NAME`: Plugin name to enable [required]
**Options** :
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
###  `canvas disable`
Disable a plugin from a Canvas instance..
**Usage** :
    ```console
    $ canvas disable [OPTIONS] NAME
    ```
**Arguments** :
  - `NAME`: Plugin name to disable [required]
**Options** :
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
###  `canvas list`
List all plugins on a Canvas instance.
**Usage** :
    ```console
    $ canvas list [OPTIONS]
    ```
**Options** :
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
###  `canvas validate-manifest`
Validate the Canvas Manifest json file.
**Usage** :
    ```console
    $ canvas validate-manifest [OPTIONS] PLUGIN_NAME
    ```
**Arguments** :
  - `PLUGIN_NAME`: Path to plugin to validate [required]
**Options** :
  - `--help`: Show this message and exit.
###  `canvas logs`
Subscribes to a log stream and prints to your console. Optionally fetches historical logs first.
**Usage** :
    ```console
    $ canvas logs [OPTIONS]
    ```
**Options** :
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
  - `--since TEXT`: Lookback window (e.g. '24h', '2h30m'). Mutually exclusive with –start/–end.
  - `--start TEXT`: Start time (ISO/RFC3339) or 'now'.
  - `--end TEXT`: End time (ISO/RFC3339) or 'now'. Defaults to now if start is provided.
  - `--no-follow`: Historical only; do not stream live logs.
  - `--level TEXT`: Repeatable. –level ERROR –level WARN
  - `--source TEXT`: Filter by source/service.
  - `--page-size INTEGER`: Fetch size per page (historical). [default: 200]
  - `--limit INTEGER`: Max historical logs to print.
  - `--all`: Fetch all pages until exhausted (historical).
  - `--interactive`: After each page, prompt to load more.
  - `--cursor TEXT`: Resume token from a previous run.
  - `--help`: Show this message and exit.
###  `canvas config list`
List all secrets from a plugin.
**Usage** :
    ```console
    $ canvas config list [OPTIONS] PLUGIN
    ```
**Arguments** :
  - `PLUGIN`: Plugin name to list secrets for
**Options** :
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
###  `canvas config set`
Configure plugin secrets.
**Usage** :
    ```console
    $ canvas config set [OPTIONS] PLUGIN
    ```
**Arguments** :
  - `PLUGIN`: Plugin name to list secrets for
  - `SECRETS...`: Secrets to set, e.g. Key=value
**Options** :
  - `--host TEXT`: Canvas instance to connect to
  - `--help`: Show this message and exit.
----- END PAGE https://docs.canvasmedical.com/sdk/canvas_cli/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/clients-aws-s3/
The Canvas SDK AWS S3 client provides a simple interface for interacting with Amazon S3 storage, including uploading, downloading, listing, and deleting objects, as well as generating presigned URLs for temporary access.
##  Requirements 
  - **AWS Access Key ID** : Your AWS access key
  - **AWS Secret Access Key** : Your AWS secret key
  - **AWS Region** : The region where your bucket is located (e.g., `us-east-1`)
  - **S3 Bucket Name** : The name of your S3 bucket
##  Imports 
The AWS S3 client is included in the Canvas SDK. Import the necessary components:
    ```python
    from canvas_sdk.clients.aws import S3, Credentials, S3Item
    ```
Or import from specific modules:
    ```python
    from canvas_sdk.clients.aws.libraries import S3
    from canvas_sdk.clients.aws.structures import Credentials, S3Item
    ```
##  Initialize the Client 
    ```python
    from canvas_sdk.clients.aws import S3, Credentials
    credentials = Credentials(
        key="your_aws_access_key_id",
        secret="your_aws_secret_access_key",
        region="us-east-1",
        bucket="your-bucket-name"
    )
    client = S3(credentials)
    ```
##  Check if Client is Ready 
    ```python
    if client.is_ready():
        print("S3 client is configured and ready")
    else:
        print("Missing credentials")
    ```
##  Upload a Text File 
    ```python
    from canvas_sdk.clients.aws import S3, Credentials
    credentials = Credentials(
        key="your_access_key",
        secret="your_secret_key",
        region="us-east-1",
        bucket="my-bucket"
    )
    client = S3(credentials)
    # Upload text content
    response = client.upload_text_to_s3("path/to/file.txt", "Hello, World!")
    if response and response.status_code == 200:
        print("Text file uploaded successfully!")
    ```
##  Upload a Binary File 
    ```python
    # Upload binary content (e.g., an image)
    with open("local_image.png", "rb") as f:
        binary_data = f.read()
    response = client.upload_binary_to_s3(
        "images/uploaded_image.png",
        binary_data,
        "image/png"
    )
    if response and response.status_code == 200:
        print("Binary file uploaded successfully!")
    ```
##  Download a File 
    ```python
    response = client.access_s3_object("path/to/file.txt")
    if response:
        content = response.content
        print(f"Downloaded content: {content.decode('utf-8')}")
    ```
##  List Objects in Bucket 
    ```python
    # List all objects with a prefix
    items = client.list_s3_objects("documents/")
    if items:
        for item in items:
            print(f"Key: {item.key}, Size: {item.size} bytes, Modified: {item.last_modified}")
    ```
##  Delete an Object 
    ```python
    response = client.delete_object("path/to/file.txt")
    if response and response.status_code == 204:
        print("Object deleted successfully!")
    ```
##  Generate a Presigned URL 
    ```python
    # Generate a URL valid for 1 hour (3600 seconds)
    url = client.generate_presigned_url("path/to/file.txt", expiration=3600)
    if url:
        print(f"Presigned URL: {url}")
    ```
##  S3 
The main class for interacting with AWS S3.
###  Constructor 
    ```python
    S3(credentials: Credentials)
    ```
Parameter | Type | Description  
---|---|---  
`credentials` | `Credentials` | AWS credentials for S3 access  
###  Methods 
####  `is_ready() -> bool`
Check if all required credentials are provided.
**Returns:** `True` if all credentials (key, secret, region, bucket) are non-empty, `False` otherwise.
####  `access_s3_object(object_key: str) -> Response | None`
Download an object from S3.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`object_key` | `str` | S3 object key (path) to access  
**Returns:** `requests.Response` containing the object data, or `None` if credentials are not ready.
####  `upload_text_to_s3(object_key: str, data: str) -> Response | None`
Upload text data to S3 as `text/plain`.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`object_key` | `str` | S3 object key (path) to create/update  
`data` | `str` | Text content to upload  
**Returns:** `requests.Response` from S3, or `None` if credentials are not ready.
####  `upload_binary_to_s3(object_key: str, binary_data: bytes, content_type: str) -> Response | None`
Upload binary data to S3.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`object_key` | `str` | S3 object key (path) to create/update  
`binary_data` | `bytes` | Binary content to upload  
`content_type` | `str` | MIME type (e.g., `image/png`)  
**Returns:** `requests.Response` from S3, or `None` if credentials are not ready.
####  `delete_object(object_key: str) -> Response | None`
Delete an object from S3.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`object_key` | `str` | S3 object key (path) to delete  
**Returns:** `requests.Response` from S3, or `None` if credentials are not ready.
####  `list_s3_objects(prefix: str) -> list[S3Item] | None`
List all objects in S3 with the given prefix. Handles pagination automatically.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`prefix` | `str` | S3 key prefix to filter objects  
**Returns:** List of `S3Item` objects with metadata, or `None` if credentials are not ready.
**Raises:** `Exception` if S3 returns a non-200 status code.
####  `generate_presigned_url(object_key: str, expiration: int) -> str | None`
Generate a presigned URL for temporary access to an S3 object.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`object_key` | `str` | S3 object key (path)  
`expiration` | `int` | URL expiration time in seconds  
**Returns:** Presigned URL string, or `None` if credentials are not ready.
##  Data Structures 
###  Credentials 
AWS credentials for S3 access.
Field | Type | Description  
---|---|---  
`key` | `str` | AWS access key ID  
`secret` | `str` | AWS secret access key  
`region` | `str` | AWS region (e.g., `us-east-1`)  
`bucket` | `str` | S3 bucket name  
**Example:**
    ```python
    from canvas_sdk.clients.aws import Credentials
    credentials = Credentials(
        key="AKIAIOSFODNN7EXAMPLE",
        secret="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
        region="us-west-2",
        bucket="my-application-bucket"
    )
    ```
###  S3Item 
S3 object metadata returned by `list_s3_objects`.
Field | Type | Description  
---|---|---  
`key` | `str` | Object key (path) in the S3 bucket  
`size` | `int` | Object size in bytes  
`last_modified` | `datetime` | Timestamp of the last modification  
**Example:**
    ```python
    items = client.list_s3_objects("documents/")
    for item in items:
        print(f"File: {item.key}")
        print(f"Size: {item.size} bytes")
        print(f"Last Modified: {item.last_modified}")
    ```
##  Complete Plugin Example 
Here's a complete example of using the S3 client in a Canvas plugin:
    ```python
    from http import HTTPStatus
    from canvas_sdk.clients.aws import S3, Credentials
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, PlainTextResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials as APICredentials, SimpleAPI, api
    class S3Handler(SimpleAPI):
        """Simple API handler for S3 operations."""
        def authenticate(self, credentials: APICredentials) -> bool:
            return True
        def _s3_client(self) -> S3:
            """Create S3 client from plugin secrets."""
            return S3(
                Credentials(
                    key=self.secrets["S3Key"],
                    secret=self.secrets["S3Secret"],
                    region=self.secrets["S3Region"],
                    bucket=self.secrets["S3Bucket"],
                )
            )
        @api.get("/list")
        def list_files(self) -> list[Response | Effect]:
            """List all files in the bucket."""
            client = self._s3_client()
            if client.is_ready():
                items = client.list_s3_objects("")
                content = [{"key": p.key, "size": p.size} for p in items]
                return [JSONResponse(content, status_code=HTTPStatus.OK)]
            return []
        @api.get("/download/<file_key>")
        def download_file(self) -> list[Response | Effect]:
            """Download a file by key."""
            file_key = self.request.path_params["file_key"]
            client = self._s3_client()
            if client.is_ready() and file_key:
                response = client.access_s3_object(file_key)
                return [Response(response.content, status_code=HTTPStatus.OK)]
            return []
        @api.post("/upload/<file_key>")
        def upload_file(self) -> list[Response | Effect]:
            """Upload a file."""
            file_key = self.request.path_params["file_key"]
            client = self._s3_client()
            content = self.request.body
            content_type = self.request.content_type
            if client.is_ready() and file_key:
                if content_type == "text/plain":
                    response = client.upload_text_to_s3(file_key, content.decode("utf-8"))
                else:
                    response = client.upload_binary_to_s3(file_key, content, content_type)
                return [Response(response.content, status_code=response.status_code)]
            return []
        @api.delete("/delete/<file_key>")
        def delete_file(self) -> list[Response | Effect]:
            """Delete a file by key."""
            file_key = self.request.path_params["file_key"]
            client = self._s3_client()
            if client.is_ready() and file_key:
                response = client.delete_object(file_key)
                return [Response(response.content, status_code=HTTPStatus.OK)]
            return []
        @api.get("/presigned/<file_key>")
        def get_presigned_url(self) -> list[Response | Effect]:
            """Generate a presigned URL for temporary access."""
            file_key = self.request.path_params["file_key"]
            client = self._s3_client()
            if client.is_ready() and file_key:
                url = client.generate_presigned_url(file_key, 3600)  # 1 hour
                return [PlainTextResponse(url, status_code=HTTPStatus.OK)]
            return []
    ```
##  Error Handling 
The S3 client methods return `None` when credentials are not ready. For list operations, an `Exception` is raised if S3 returns an error status code.
    ```python
    # Check credentials before operations
    if not client.is_ready():
        print("S3 credentials are not configured")
        return
    # Handle list errors
    try:
        items = client.list_s3_objects("prefix/")
    except Exception as e:
        print(f"S3 error: {e}")
    # Check response status for uploads/downloads
    response = client.upload_text_to_s3("file.txt", "content")
    if response:
        if response.status_code == 200:
            print("Upload successful")
        else:
            print(f"Upload failed with status {response.status_code}")
    else:
        print("Credentials not ready")
    ```
##  AWS Signature V4 Authentication 
The S3 client implements AWS Signature Version 4 for request authentication. This is handled automatically - you only need to provide valid credentials. The client:
  - Signs all requests with HMAC-SHA256
  - Generates proper canonical requests
  - Handles date/time formatting for AWS
  - Supports presigned URLs for temporary access
##  Additional Resources 
  - [AWS S3 Documentation](https://docs.aws.amazon.com/s3/)
  - [AWS Signature Version 4](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html)
  - [S3 REST API Reference](https://docs.aws.amazon.com/AmazonS3/latest/API/Welcome.html)
  - [Example Plugin](/sdk/example-aws_s3/) \- Documentation for the example plugin
  - [Source Code](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/aws_s3) \- View the source on GitHub
----- END PAGE https://docs.canvasmedical.com/sdk/clients-aws-s3/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/clients-extend-ai/
The Canvas SDK Extend AI client provides an interface for document processing using AI-powered extraction, classification, and splitting capabilities through the Extend AI API.
##  Requirements 
  - **Extend AI API Key** : Obtain from your [Extend AI dashboard](https://app.extend.ai/)
##  What is Extend AI? 
Extend AI provides intelligent document processing (IDP) capabilities:
  - **Extraction** : Extract structured data from documents based on a defined schema
  - **Classification** : Classify documents into predefined categories
  - **Splitting** : Split multi-page documents into logical sections
##  Imports 
The Extend AI client is included in the Canvas SDK. Import the necessary components:
    ```python
    from canvas_sdk.clients.extend_ai.libraries import Client
    from canvas_sdk.clients.extend_ai.constants import RunStatus, VersionName
    from canvas_sdk.clients.extend_ai.structures import RequestFailed
    ```
##  Initialize the Client 
    ```python
    client = Client(key="your_extend_ai_api_key")
    ```
##  Extract Data from a Document (Using an Existing Processor) 
The most common use case is running an existing processor on a document. Here's a complete example:
    ```python
    import time
    from canvas_sdk.clients.extend_ai.libraries import Client
    from canvas_sdk.clients.extend_ai.constants import RunStatus
    from canvas_sdk.clients.extend_ai.structures import RequestFailed
    # Initialize the client
    client = Client(key="your_api_key")
    # Your processor ID (created in the Extend AI dashboard)
    processor_id = "proc_xxxxxxxxxxxxxxxxx"
    # URL to the document (must be publicly accessible)
    document_url = "https://your-bucket.s3.amazonaws.com/document.pdf"
    try:
        # Start the processor run
        run = client.run_processor(
            processor_id=processor_id,
            file_name="my-document.pdf",
            file_url=document_url,
            config=None,  # Use processor's default configuration
        )
        print(f"Run started! ID: {run.id}, Status: {run.status.value}")
        # Poll for completion
        while run.status in (RunStatus.PENDING, RunStatus.PROCESSING):
            time.sleep(2)  # Wait 2 seconds between checks
            run = client.run_status(run.id)
            print(f"Status: {run.status.value}")
        # Check result
        if run.status == RunStatus.PROCESSED:
            print("Extraction successful!")
            print(f"Extracted data: {run.output.value}")
        else:
            print(f"Processing failed with status: {run.status.value}")
    except RequestFailed as e:
        print(f"Error: {e.message} (HTTP {e.status_code})")
    ```
##  List Available Processors 
    ```python
    # List all processors in your account
    for processor in client.list_processors():
        print(f"ID: {processor.id}")
        print(f"Name: {processor.name}")
        print(f"Type: {processor.type.value}")
        print("---")
    ```
##  Get Processor Configuration 
    ```python
    from canvas_sdk.clients.extend_ai.constants import VersionName
    # Get the draft version of a processor
    processor_version = client.processor(
        processor_id="proc_xxxxxxxxxxxxxxxxx",
        version=VersionName.DRAFT.value
    )
    print(f"Processor: {processor_version.processor.name}")
    print(f"Version: {processor_version.version}")
    print(f"Type: {processor_version.processor.type.value}")
    # Access the schema (for extraction processors)
    if hasattr(processor_version.config, 'schema'):
        print(f"Schema: {processor_version.config.schema}")
    ```
##  Check Run Status and Get Results 
    ```python
    # Check the status of a run
    run = client.run_status("run_xxxxxxxxxxxxxxxxx")
    print(f"Status: {run.status.value}")
    print(f"Credits used: {run.usage}")
    if run.status == RunStatus.PROCESSED:
        # For extraction processors
        if hasattr(run.output, 'value'):
            extracted_data = run.output.value
            print(f"Extracted: {extracted_data}")
        # For classification processors
        if hasattr(run.output, 'type'):
            print(f"Classification: {run.output.type}")
            print(f"Confidence: {run.output.confidence}")
        # For splitter processors
        if hasattr(run.output, 'splits'):
            for split in run.output.splits:
                print(f"Split: {split.type}, Pages {split.startPage}-{split.endPage}")
    ```
##  Clean Up Files After Processing 
    ```python
    # After processing, delete the uploaded files to save storage
    run = client.run_status("run_xxxxxxxxxxxxxxxxx")
    if run.status == RunStatus.PROCESSED:
        for file in run.files:
            deleted = client.delete_file(file.id)
            print(f"Deleted file {file.name}: {deleted}")
    ```
##  Complete Workflow Example 
    ```python
    import time
    from canvas_sdk.clients.extend_ai.libraries import Client
    from canvas_sdk.clients.extend_ai.constants import RunStatus
    from canvas_sdk.clients.extend_ai.structures import RequestFailed
    def extract_from_document(api_key: str, processor_id: str, document_url: str) -> dict:
        """
        Extract structured data from a document using Extend AI.
        Args:
            api_key: Your Extend AI API key
            processor_id: The processor ID to use
            document_url: Public URL to the document
        Returns:
            Dictionary containing the extracted data
        Raises:
            RequestFailed: If the API request fails
            RuntimeError: If processing fails or times out
        """
        client = Client(key=api_key)
        # Start processing
        run = client.run_processor(
            processor_id=processor_id,
            file_name="document.pdf",
            file_url=document_url,
            config=None,
        )
        # Wait for completion (with timeout)
        max_attempts = 30  # 60 seconds max
        attempts = 0
        while run.status in (RunStatus.PENDING, RunStatus.PROCESSING):
            if attempts >= max_attempts:
                raise RuntimeError("Processing timed out")
            time.sleep(2)
            run = client.run_status(run.id)
            attempts += 1
        # Handle result
        if run.status == RunStatus.PROCESSED:
            # Clean up files
            for file in run.files:
                client.delete_file(file.id)
            return run.output.value if hasattr(run.output, 'value') else run.output.to_dict()
        raise RuntimeError(f"Processing failed: {run.status.value}")
    # Usage
    result = extract_from_document(
        api_key="your_api_key",
        processor_id="proc_xxxxxxxxxxxxxxxxx",
        document_url="https://example.com/document.pdf"
    )
    print(result)
    ```
##  Client 
The main class for interacting with the Extend AI API.
###  Constructor 
    ```python
    Client(key: str)
    ```
Parameter | Type | Description  
---|---|---  
`key` | `str` | Extend AI API key  
###  File Management 
####  `list_files() -> Iterator[StoredFile]`
List all files stored in Extend AI.
    ```python
    for file in client.list_files():
        print(f"{file.id}: {file.name} ({file.type})")
    ```
**Returns:** Iterator of `StoredFile` objects
**Raises:** `RequestFailed` on error
####  `delete_file(file_id: str) -> bool`
Delete a file from Extend AI storage.
    ```python
    deleted = client.delete_file("file_xxxxxxxxxxxxxxxxx")
    print(f"Deleted: {deleted}")
    ```
Parameter | Type | Description  
---|---|---  
`file_id` | `str` | Unique identifier of the file  
**Returns:** `True` on success
**Raises:** `RequestFailed` on error
###  Processor Management 
####  `list_processors() -> Iterator[ProcessorMeta]`
List all processors in the account.
    ```python
    for processor in client.list_processors():
        print(f"{processor.name}: {processor.type.value}")
    ```
**Returns:** Iterator of `ProcessorMeta` objects
**Raises:** `RequestFailed` on error
####  `processor(processor_id: str, version: str) -> ProcessorVersion`
Get details for a specific processor version.
    ```python
    from canvas_sdk.clients.extend_ai.constants import VersionName
    # Get draft version
    processor = client.processor("proc_xxx", VersionName.DRAFT.value)
    # Get latest published version
    processor = client.processor("proc_xxx", VersionName.LATEST.value)
    # Get specific version
    processor = client.processor("proc_xxx", "v1")
    ```
Parameter | Type | Description  
---|---|---  
`processor_id` | `str` | Unique identifier of the processor  
`version` | `str` | Version name (`draft`, `latest`, or `vN`)  
**Returns:** `ProcessorVersion` object
**Raises:** `RequestFailed` on error
####  `create_processor(name: str, config: ConfigBase) -> ProcessorMeta`
Create a new processor with the specified configuration.
    ```python
    from canvas_sdk.clients.extend_ai.constants import BaseProcessor
    from canvas_sdk.clients.extend_ai.structures.config import (
        ConfigExtraction,
        AdvancedOptionsExtraction,
        Parser,
    )
    config = ConfigExtraction(
        base_processor=BaseProcessor.EXTRACTION_PERFORMANCE,
        extraction_rule="Extract all relevant fields",
        schema={
            "type": "object",
            "properties": {
                "name": {"type": "string"},
                "date": {"type": "string"},
                "amount": {"type": "number"},
            }
        },
        advanced_options=AdvancedOptionsExtraction.from_dict({}),
        parser=Parser.from_dict({}),
    )
    processor = client.create_processor("Invoice Extractor", config)
    print(f"Created: {processor.id}")
    ```
Parameter | Type | Description  
---|---|---  
`name` | `str` | Name for the new processor  
`config` | `ConfigBase` | Processor configuration object  
**Returns:** `ProcessorMeta` object
**Raises:** `RequestFailed` on error
###  Running Processors 
####  `run_processor(processor_id, file_name, file_url, config) -> ProcessorRun`
Execute a processor on a document.
    ```python
    run = client.run_processor(
        processor_id="proc_xxxxxxxxxxxxxxxxx",
        file_name="invoice.pdf",
        file_url="https://bucket.s3.amazonaws.com/invoice.pdf",
        config=None,  # Use processor defaults
    )
    print(f"Run ID: {run.id}, Status: {run.status.value}")
    ```
Parameter | Type | Description  
---|---|---  
`processor_id` | `str` | Processor to run  
`file_name` | `str` | Name for the file  
`file_url` | `str` | Public URL to the document  
`config` | `ConfigExtraction \| None` | Optional config override (extraction only)  
**Returns:** `ProcessorRun` object with initial status
**Raises:** `RequestFailed` on error
####  `run_status(run_id: str) -> ProcessorRun`
Get the current status and results of a processor run.
    ```python
    run = client.run_status("run_xxxxxxxxxxxxxxxxx")
    if run.status == RunStatus.PROCESSED:
        print(f"Result: {run.output.to_dict()}")
    elif run.status == RunStatus.FAILED:
        print("Processing failed")
    else:
        print(f"Still processing: {run.status.value}")
    ```
Parameter | Type | Description  
---|---|---  
`run_id` | `str` | Unique identifier of the run  
**Returns:** `ProcessorRun` object with current status and results
**Raises:** `RequestFailed` on error
##  Data Structures 
###  ProcessorMeta 
Metadata about a processor.
Field | Type | Description  
---|---|---  
`id` | `str` | Unique processor identifier  
`name` | `str` | Processor name  
`type` | `ProcessorType` | Type (EXTRACT, CLASSIFY, SPLITTER)  
`created_at` | `datetime \| None` | Creation timestamp  
`updated_at` | `datetime \| None` | Last update timestamp  
###  ProcessorVersion 
A specific version of a processor with full configuration.
Field | Type | Description  
---|---|---  
`id` | `str` | Version identifier  
`version` | `str` | Version name (draft, v1, etc.)  
`description` | `str` | Version description  
`processor` | `ProcessorMeta` | Processor metadata  
`config` | `ConfigClassification \| ConfigExtraction \| ConfigSplitter` | Processor configuration  
`created_at` | `datetime` | Creation timestamp  
`updated_at` | `datetime` | Last update timestamp  
###  ProcessorRun 
Represents a single execution of a processor.
Field | Type | Description  
---|---|---  
`id` | `str` | Run identifier  
`processor` | `ProcessorMeta` | Processor that was executed  
`output` | `ResultClassification \| ResultExtraction \| ResultSplitter \| None` | Processing results  
`status` | `RunStatus` | Current run status  
`files` | `list[StoredFile]` | Associated files  
`usage` | `int` | Total credits consumed  
###  StoredFile 
A file stored in Extend AI.
Field | Type | Description  
---|---|---  
`id` | `str` | Unique file identifier  
`type` | `str` | MIME type / file type  
`name` | `str` | File name  
###  Classification 
A classification category definition.
Field | Type | Description  
---|---|---  
`id` | `str` | Classification identifier  
`type` | `str` | Classification type/category name  
`description` | `str` | Description of this classification  
##  Result Structures 
###  ResultExtraction 
Output from an extraction processor.
Field | Type | Description  
---|---|---  
`value` | `dict` | Dictionary of extracted field values  
**Example:**
    ```python
    if run.status == RunStatus.PROCESSED:
        extracted = run.output.value
        print(f"Name: {extracted.get('name')}")
        print(f"Amount: {extracted.get('amount')}")
    ```
###  ResultClassification 
Output from a classification processor.
Field | Type | Description  
---|---|---  
`type` | `str` | Assigned classification type  
`confidence` | `float` | Confidence score (0.0 to 1.0)  
`insights` | `list[Insight]` | Extracted insights  
**Example:**
    ```python
    if run.status == RunStatus.PROCESSED:
        print(f"Type: {run.output.type}")
        print(f"Confidence: {run.output.confidence:.2%}")
        for insight in run.output.insights:
            print(f"  {insight.type}: {insight.content}")
    ```
###  ResultSplitter 
Output from a splitter processor.
Field | Type | Description  
---|---|---  
`splits` | `list[Split]` | List of identified splits  
**Example:**
    ```python
    if run.status == RunStatus.PROCESSED:
        for split in run.output.splits:
            print(f"Section: {split.type}")
            print(f"  Pages: {split.startPage} - {split.endPage}")
            print(f"  Observation: {split.observation}")
    ```
###  Split 
A document split/section identified by a splitter.
Field | Type | Description  
---|---|---  
`id` | `str` | Split identifier  
`type` | `str` | Split type/category  
`observation` | `str` | Observations about this split  
`identifier` | `str` | Unique identifier  
`startPage` | `int` | Starting page number  
`endPage` | `int` | Ending page number  
`classificationId` | `str` | Associated classification ID  
`fileId` | `str` | File this split belongs to  
`name` | `str` | Split name  
###  Insight 
An insight extracted during classification.
Field | Type | Description  
---|---|---  
`type` | `str` | Insight type/category  
`content` | `str` | Insight text content  
##  Configuration Structures 
###  ConfigExtraction 
Configuration for extraction processors.
Field | Type | Description  
---|---|---  
`base_processor` | `BaseProcessor` | Performance or light variant  
`extraction_rule` | `str` | Custom extraction instructions  
`schema` | `dict` | JSON Schema for extracted data  
`advanced_options` | `AdvancedOptionsExtraction` | Advanced settings  
`parser` | `Parser` | Document parser settings  
###  ConfigClassification 
Configuration for classification processors.
Field | Type | Description  
---|---|---  
`classifications` | `list[Classification]` | Possible classification categories  
`base_processor` | `BaseProcessor` | Performance or light variant  
`classification_rule` | `str` | Custom classification rules  
`advanced_options` | `AdvancedOptionsClassification` | Advanced settings  
`parser` | `Parser` | Document parser settings  
###  ConfigSplitter 
Configuration for splitter processors.
Field | Type | Description  
---|---|---  
`split_classifications` | `list[Classification]` | Classification categories for splits  
`base_processor` | `BaseProcessor` | Performance or light variant  
`split_rules` | `str` | Custom splitting rules  
`advanced_options` | `AdvancedOptionsSplitter` | Advanced settings  
`parser` | `Parser` | Document parser settings  
##  Constants (Enums) 
###  ProcessorType 
Types of processors available.
Value | Description  
---|---  
`EXTRACT` | Extracts structured data based on a schema  
`CLASSIFY` | Classifies documents into categories  
`SPLITTER` | Splits documents into sections  
###  RunStatus 
Status values for processor runs.
Value | Description  
---|---  
`PENDING` | Run is queued and waiting to start  
`PROCESSING` | Run is currently being processed  
`PROCESSED` | Run completed successfully  
`FAILED` | Run encountered an error  
`CANCELLED` | Run was cancelled before completion  
###  VersionName 
Standard version names for processors.
Value | Description  
---|---  
`LATEST` | Latest published version  
`DRAFT` | Draft/working version  
###  BaseProcessor 
Base processor variants (performance vs speed trade-off).
Value | Description  
---|---  
`CLASSIFICATION_PERFORMANCE` | High accuracy classification  
`CLASSIFICATION_LIGHT` | Fast classification  
`EXTRACTION_PERFORMANCE` | High accuracy extraction  
`EXTRACTION_LIGHT` | Fast extraction  
`SPLITTING_PERFORMANCE` | High accuracy splitting  
`SPLITTING_LIGHT` | Fast splitting  
##  Error Handling 
###  RequestFailed 
Exception raised when an Extend AI API request fails (extends `RuntimeError`).
Attribute | Type | Description  
---|---|---  
`status_code` | `int` | HTTP status code  
`message` | `str` | Error message from Extend AI  
**Example:**
    ```python
    try:
        run = client.run_processor(...)
    except RequestFailed as e:
        print(f"API Error {e.status_code}: {e.message}")
    ```
##  Polling Pattern 
Since document processing is asynchronous, use this pattern to wait for results:
    ```python
    import time
    from canvas_sdk.clients.extend_ai.constants import RunStatus
    def wait_for_completion(client, run_id: str, timeout_seconds: int = 120) -> ProcessorRun:
        """
        Wait for a processor run to complete.
        Args:
            client: Extend AI client instance
            run_id: The run ID to monitor
            timeout_seconds: Maximum time to wait
        Returns:
            ProcessorRun with final status
        Raises:
            TimeoutError: If processing exceeds timeout
        """
        start_time = time.time()
        poll_interval = 2  # seconds
        while True:
            run = client.run_status(run_id)
            # Check if done
            if run.status not in (RunStatus.PENDING, RunStatus.PROCESSING):
                return run
            # Check timeout
            if time.time() - start_time > timeout_seconds:
                raise TimeoutError(f"Processing timed out after {timeout_seconds}s")
            time.sleep(poll_interval)
    # Usage
    run = client.run_processor(processor_id, file_name, file_url, None)
    final_run = wait_for_completion(client, run.id)
    if final_run.status == RunStatus.PROCESSED:
        print(final_run.output.to_dict())
    ```
##  Additional Resources 
  - [Extend AI Documentation](https://docs.extend.ai/)
  - [Example Plugin](/sdk/example-extend_ai_pdf/) \- Documentation for the example plugin
  - [Source Code](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/extend_ai_pdf) \- View the source on GitHub
----- END PAGE https://docs.canvasmedical.com/sdk/clients-extend-ai/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/clients-llms/
The Canvas SDK LLMs client provides a unified interface for interacting with multiple Large Language Model (LLM) providers including OpenAI (GPT Models), Anthropic (Claude), and Google (Gemini). It supports text conversations, file attachments (images, PDFs, text), and structured JSON output.
##  Requirements 
Depending on which LLM provider you use:
  - **OpenAI** : API key from https://platform.openai.com/api-keys
  - **Anthropic** : API key from https://console.anthropic.com/settings/keys
  - **Google** : API key from https://aistudio.google.com/apikey
##  Imports 
The LLMs client is included in the Canvas SDK. Import the necessary components:
    ```python
    from canvas_sdk.clients.llms import (
        LlmOpenai,
        LlmAnthropic,
        LlmGoogle,
        LlmResponse,
        LlmTokens,
        LlmTurn,
    )
    from canvas_sdk.clients.llms.structures.settings import (
        LlmSettingsGpt4,
        LlmSettingsAnthropic,
        LlmSettingsGemini,
    )
    from canvas_sdk.clients.llms.constants import FileType
    from canvas_sdk.clients.llms.structures import LlmFileUrl, FileContent, BaseModelLlmJson
    ```
##  Initialize the Clients 
###  OpenAI (GPT Models) 
    ```python
    from canvas_sdk.clients.llms import LlmOpenai
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGpt4
    client = LlmOpenai(LlmSettingsGpt4(
        api_key="your_openai_api_key",
        model="gpt-4o",
        temperature=0.7,
    ))
    ```
###  Anthropic (Claude) 
    ```python
    from canvas_sdk.clients.llms import LlmAnthropic
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsAnthropic
    client = LlmAnthropic(LlmSettingsAnthropic(
        api_key="your_anthropic_api_key",
        model="claude-sonnet-4-5-20250929",
        temperature=0.7,
        max_tokens=8192,
    ))
    ```
###  Google (Gemini) 
    ```python
    from canvas_sdk.clients.llms import LlmGoogle
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGemini
    client = LlmGoogle(LlmSettingsGemini(
        api_key="your_google_api_key",
        model="models/gemini-2.0-flash",
        temperature=0.7,
    ))
    ```
##  Simple Text Conversation 
    ```python
    from http import HTTPStatus
    from canvas_sdk.clients.llms import LlmOpenai
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGpt4
    # Initialize client
    client = LlmOpenai(LlmSettingsGpt4(
        api_key="your_api_key",
        model="gpt-4o",
        temperature=0.7,
    ))
    # Set up the conversation
    client.set_system_prompt(["You are a helpful assistant."])
    client.set_user_prompt(["What is the capital of France?"])
    # Make the request
    response = client.request()
    if response.code == HTTPStatus.OK:
        print(f"Response: {response.response}")
        print(f"Tokens used - Prompt: {response.tokens.prompt}, Generated: {response.tokens.generated}")
    else:
        print(f"Error: {response.response}")
    ```
##  Multi-turn Conversation 
    ```python
    # Initialize client
    client = LlmOpenai(LlmSettingsGpt4(
        api_key="your_api_key",
        model="gpt-4o",
        temperature=0.7,
    ))
    # Build a multi-turn conversation
    client.set_system_prompt(["You are a helpful math tutor."])
    client.set_user_prompt(["What is 2 + 2?"])
    client.set_model_prompt(["2 + 2 equals 4."])
    client.set_user_prompt(["And what is that multiplied by 3?"])
    # Get the response
    response = client.request()
    print(response.response)  # "4 multiplied by 3 equals 12."
    ```
##  Using Retry Logic 
    ```python
    # Attempt multiple requests until success or max attempts
    responses = client.attempt_requests(attempts=3)
    # Check the last response
    last_response = responses[-1]
    if last_response.code == HTTPStatus.OK:
        print(f"Success: {last_response.response}")
    else:
        print(f"Failed after {len(responses)} attempts")
    ```
##  Analyze an Image 
    ```python
    from canvas_sdk.clients.llms import LlmOpenai
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGpt4
    from canvas_sdk.clients.llms.constants import FileType
    from canvas_sdk.clients.llms.structures import LlmFileUrl
    client = LlmOpenai(LlmSettingsGpt4(
        api_key="your_api_key",
        model="gpt-4o",
        temperature=0.5,
    ))
    # Set up prompts
    client.set_system_prompt(["You are an image analysis assistant."])
    client.set_user_prompt(["Describe what you see in this image."])
    # Add an image file
    client.add_url_file(LlmFileUrl(
        url="https://example.com/image.jpg",
        type=FileType.IMAGE
    ))
    # Get the analysis
    response = client.request()
    print(response.response)
    ```
##  Analyze a PDF Document 
    ```python
    from canvas_sdk.clients.llms import LlmAnthropic
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsAnthropic
    from canvas_sdk.clients.llms.constants import FileType
    from canvas_sdk.clients.llms.structures import LlmFileUrl
    client = LlmAnthropic(LlmSettingsAnthropic(
        api_key="your_api_key",
        model="claude-sonnet-4-5-20250929",
        temperature=0.5,
        max_tokens=4096,
    ))
    # Set up prompts
    client.set_system_prompt(["You are a document analysis assistant."])
    client.set_user_prompt(["Summarize the key points in this document."])
    # Add a PDF file
    client.add_url_file(LlmFileUrl(
        url="https://example.com/document.pdf",
        type=FileType.PDF
    ))
    # Get the summary
    response = client.request()
    print(response.response)
    ```
##  Upload File Content Directly 
Instead of providing a URL, you can upload file content directly using `FileContent`. This is useful when you have the file data in memory (e.g., from a form upload).
    ```python
    import base64
    from canvas_sdk.clients.llms import LlmOpenai
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGpt4
    from canvas_sdk.clients.llms.structures import FileContent
    client = LlmOpenai(LlmSettingsGpt4(
        api_key="your_api_key",
        model="gpt-4o",
        temperature=0.5,
    ))
    # Read file content from disk or form upload
    with open("document.pdf", "rb") as f:
        file_bytes = f.read()
    # Create FileContent with base64-encoded data
    file_content = FileContent(
        mime_type="application/pdf",
        content=base64.b64encode(file_bytes),
        size=len(file_bytes),
    )
    # Add to the client's file_content list
    client.file_content.append(file_content)
    # Set up prompts
    client.set_system_prompt(["Analyze the provided document."])
    client.set_user_prompt(["What are the main topics covered in this document?"])
    # Get the analysis
    response = client.request()
    print(response.response)
    ```
**Supported MIME types for direct file content:**
MIME Type Pattern | Description  
---|---  
`image/*` | Images (PNG, JPEG, GIF, etc.)  
`application/pdf` | PDF documents  
`text/*` | Text files (Anthropic only)  
##  Structured JSON Output 
    ```python
    from pydantic import Field
    from canvas_sdk.clients.llms import LlmOpenai
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGpt4
    from canvas_sdk.clients.llms.structures import BaseModelLlmJson
    # Define your response schema
    class PersonInfo(BaseModelLlmJson):
        name: str = Field(description="The person's full name")
        age: int = Field(description="The person's age in years")
        occupation: str = Field(description="The person's job or profession")
    # Initialize client
    client = LlmOpenai(LlmSettingsGpt4(
        api_key="your_api_key",
        model="gpt-4o",
        temperature=0.3,
    ))
    # Set the schema for structured output
    client.set_schema(PersonInfo)
    # Set up prompts
    client.set_system_prompt(["Extract person information from the text."])
    client.set_user_prompt(["John Smith is a 35-year-old software engineer."])
    # Get structured response
    response = client.request()
    # Response will be valid JSON matching the PersonInfo schema
    print(response.response)  # {"name": "John Smith", "age": 35, "occupation": "software engineer"}
    ```
##  Nested Structured Output 
    ```python
    from pydantic import Field
    from canvas_sdk.clients.llms.structures import BaseModelLlmJson
    # Define nested schemas (all must extend BaseModelLlmJson)
    class Address(BaseModelLlmJson):
        street: str = Field(description="Street address")
        city: str = Field(description="City name")
        country: str = Field(description="Country name")
    class Person(BaseModelLlmJson):
        name: str = Field(description="Full name")
        address: Address = Field(description="Home address")
    # Use with client
    client.set_schema(Person)
    client.set_system_prompt(["Extract person and address information."])
    client.set_user_prompt(["Jane Doe lives at 123 Main St, New York, USA."])
    response = client.request()
    ```
##  LLM Clients 
All LLM clients inherit from `LlmApi` and share the same interface.
###  Available Clients 
Client | Provider | Settings Class | API Endpoint  
---|---|---|---  
`LlmOpenai` | OpenAI | `LlmSettingsGpt4` | `https://us.api.openai.com`  
`LlmAnthropic` | Anthropic | `LlmSettingsAnthropic` | `https://api.anthropic.com`  
`LlmGoogle` | Google | `LlmSettingsGemini` | `https://generativelanguage.googleapis.com`  
###  Constructor 
    ```python
    LlmOpenai(settings: LlmSettingsGpt4)
    LlmAnthropic(settings: LlmSettingsAnthropic)
    LlmGoogle(settings: LlmSettingsGemini)
    ```
###  Attributes 
Attribute | Type | Description  
---|---|---  
`settings` | `LlmSettings` | Configuration settings for the LLM API  
`prompts` | `list[LlmTurn]` | List of conversation turns  
`file_urls` | `list[LlmFileUrl]` | Files to attach via URL (use `add_url_file()`)  
`file_content` | `list[FileContent]` | Files to attach via direct content  
`schema` | `type[BaseModelLlmJson]` | Schema for structured JSON output  
###  Methods 
####  `set_system_prompt(text: list[str]) -> None`
Set or replace the system prompt. The system prompt is always placed at the beginning of the conversation.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`text` | `list[str]` | List of text strings for the prompt  
####  `set_user_prompt(text: list[str]) -> None`
Add a user message to the conversation.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`text` | `list[str]` | List of text strings for the prompt  
####  `set_model_prompt(text: list[str]) -> None`
Add a model/assistant response to the conversation history.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`text` | `list[str]` | List of text strings for the response  
####  `add_prompt(prompt: LlmTurn) -> None`
Add a conversation turn using an `LlmTurn` object.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`prompt` | `LlmTurn` | The conversation turn to add  
####  `add_url_file(url_file: LlmFileUrl) -> None`
Add a file attachment to the next user message.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`url_file` | `LlmFileUrl` | File URL and type information  
####  `set_schema(schema: type[BaseModelLlmJson] | None) -> None`
Set a schema for structured JSON output. Pass `None` to disable structured output.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`schema` | `type[BaseModelLlmJson] | None` | Pydantic model for JSON schema  
####  `reset_prompts() -> None`
Clear all stored prompts from the conversation.
####  `request() -> LlmResponse`
Make a single request to the LLM API.
**Returns:** `LlmResponse` containing status code, response text, and token usage.
####  `attempt_requests(attempts: int) -> list[LlmResponse]`
Attempt multiple requests until success or max attempts reached.
**Parameters:**
Parameter | Type | Description  
---|---|---  
`attempts` | `int` | Maximum number of request attempts  
**Returns:** List of all `LlmResponse` objects from each attempt.
##  Settings Classes 
###  LlmSettings (Base) 
Base configuration class for LLM APIs.
Field | Type | Description  
---|---|---  
`api_key` | `str` | API authentication key  
`model` | `str` | Model name or identifier  
###  LlmSettingsGpt4 
Settings for OpenAI API.
Field | Type | Description  
---|---|---  
`api_key` | `str` | OpenAI API key  
`model` | `str` | Model name (e.g., `gpt-4o`, `gpt-4-turbo`)  
`temperature` | `float` | Randomness control (0.0-2.0)  
**Example:**
    ```python
    LlmSettingsGpt4(
        api_key="sk-...",
        model="gpt-4o",
        temperature=0.7,
    )
    ```
###  LlmSettingsAnthropic 
Settings for Anthropic Claude API.
Field | Type | Description  
---|---|---  
`api_key` | `str` | Anthropic API key  
`model` | `str` | Model name (e.g., `claude-sonnet-4-5-20250929`)  
`temperature` | `float` | Randomness control (0.0-1.0)  
`max_tokens` | `float` | Maximum tokens to generate  
**Example:**
    ```python
    LlmSettingsAnthropic(
        api_key="sk-ant-...",
        model="claude-sonnet-4-5-20250929",
        temperature=0.7,
        max_tokens=8192,
    )
    ```
###  LlmSettingsGemini 
Settings for Google Gemini API.
Field | Type | Description  
---|---|---  
`api_key` | `str` | Google API key  
`model` | `str` | Model name (e.g., `models/gemini-2.0-flash`)  
`temperature` | `float` | Randomness control (0.0-2.0)  
**Example:**
    ```python
    LlmSettingsGemini(
        api_key="AIza...",
        model="models/gemini-2.0-flash",
        temperature=0.7,
    )
    ```
##  Data Structures 
###  LlmResponse 
Response from an LLM API call.
Field | Type | Description  
---|---|---  
`code` | `HTTPStatus` | HTTP status code of the response  
`response` | `str` | Text content returned by the LLM  
`tokens` | `LlmTokens` | Token usage information  
**Methods:**
Method | Returns | Description  
---|---|---  
`to_dict()` | `dict` | Convert response to dictionary  
###  LlmTokens 
Token usage information for LLM API calls.
Field | Type | Description  
---|---|---  
`prompt` | `int` | Number of tokens in the prompt  
`generated` | `int` | Number of tokens in the generated response  
**Methods:**
Method | Returns | Description  
---|---|---  
`add(counts)` | `None` | Add token counts from another instance  
`to_dict()` | `dict` | Convert to dictionary  
###  LlmTurn 
A single conversation turn in an LLM interaction.
Field | Type | Description  
---|---|---  
`role` | `str` | Role of the speaker (`system`, `user`, `model`)  
`text` | `list[str]` | List of text strings for this turn  
**Methods:**
Method | Returns | Description  
---|---|---  
`to_dict()` | `dict` | Convert turn to dictionary  
`load_from_dict(dict_list)` | `list[LlmTurn]` | Create turns from list of dicts  
###  LlmFileUrl 
Container for file URL and type information.
Field | Type | Description  
---|---|---  
`url` | `str` | URL where the file can be accessed  
`type` | `FileType` | Type of file (IMAGE, PDF, TEXT)  
###  FileContent 
Container for file content, used for direct file uploads to LLM providers. Add instances to `client.file_content` list.
Field | Type | Description  
---|---|---  
`mime_type` | `str` | MIME type of the content (e.g., `image/png`)  
`content` | `bytes` | Base64-encoded file content  
`size` | `int` | Size of the original file in bytes  
**Example:**
    ```python
    import base64
    from canvas_sdk.clients.llms.structures import FileContent
    # From file bytes
    with open("image.png", "rb") as f:
        file_bytes = f.read()
    file_content = FileContent(
        mime_type="image/png",
        content=base64.b64encode(file_bytes),
        size=len(file_bytes),
    )
    # Add to client
    client.file_contents.append(file_content)
    ```
###  BaseModelLlmJson 
Base class for structured JSON output schemas. Extends Pydantic's `BaseModel` with:
  - `additionalProperties: false` in JSON schema
  - Automatic camelCase field name conversion
**Usage:**
    ```python
    from pydantic import Field
    from canvas_sdk.clients.llms.structures import BaseModelLlmJson
    class MySchema(BaseModelLlmJson):
        field_name: str = Field(description="Description for the LLM")
        another_field: int = Field(description="Another description")
    ```
##  Constants (Enums) 
###  FileType 
Supported file types for LLM file attachments.
Value | Description  
---|---  
`IMAGE` | Image files (PNG, JPEG, GIF)  
`PDF` | PDF documents  
`TEXT` | Plain text files  
###  Role Constants 
Available on all LLM client classes:
Constant | Value | Description  
---|---|---  
`ROLE_SYSTEM` | `"system"` | System/instruction role  
`ROLE_USER` | `"user"` | User message role  
`ROLE_MODEL` | `"model"` | Model/assistant response role  
##  Complete Plugin Example 
Here's a complete example of using the LLMs client in a Canvas plugin:
    ```python
    import base64
    from http import HTTPStatus
    from pydantic import Field
    from canvas_sdk.clients.llms import LlmOpenai
    from canvas_sdk.clients.llms.constants import FileType
    from canvas_sdk.clients.llms.structures import BaseModelLlmJson, FileContent, LlmFileUrl
    from canvas_sdk.clients.llms.structures.settings import LlmSettingsGpt4
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, PlainTextResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPI, api
    from canvas_sdk.handlers.simple_api.api import FileFormPart, StringFormPart
    class AnimalCount(BaseModelLlmJson):
        """Structured response for animal counting."""
        dogs: int = Field(description="Number of dogs in the image")
        cats: int = Field(description="Number of cats in the image")
        total: int = Field(description="Total number of animals")
    class LlmHandler(SimpleAPI):
        """Simple API handler for LLM operations."""
        def authenticate(self, credentials: Credentials) -> bool:
            return True
        def _llm_client(self) -> LlmOpenai:
            """Create LLM client from plugin secrets."""
            return LlmOpenai(LlmSettingsGpt4(
                api_key=self.secrets["LlmKey"],
                model="gpt-4o",
                temperature=0.5,
            ))
        @api.post("/chat")
        def chat(self) -> list[Response | Effect]:
            """Handle a chat conversation."""
            client = self._llm_client()
            # Process conversation turns from request
            for turn in self.request.json():
                if turn.get("role") == "system":
                    client.set_system_prompt([turn.get("prompt", "")])
                elif turn.get("role") == "user":
                    client.set_user_prompt([turn.get("prompt", "")])
                else:
                    client.set_model_prompt([turn.get("prompt", "")])
            response = client.attempt_requests(attempts=2)[0]
            return [PlainTextResponse(response.response, status_code=response.code)]
        @api.post("/analyze_image")
        def analyze_image(self) -> list[Response | Effect]:
            """Analyze an image for animal content via URL."""
            client = self._llm_client()
            url = self.request.json().get("url")
            if not url:
                return [JSONResponse({"error": "URL required"}, status_code=HTTPStatus.BAD_REQUEST)]
            # Set up structured output
            client.set_schema(AnimalCount)
            client.set_system_prompt(["Count the animals in the provided image."])
            client.set_user_prompt(["Identify and count all animals in this image."])
            client.add_url_file(LlmFileUrl(url=url, type=FileType.IMAGE))
            responses = client.attempt_requests(attempts=2)
            content = [r.to_dict() for r in responses]
            return [JSONResponse(content, status_code=HTTPStatus.OK)]
        @api.post("/file")
        def file(self) -> list[Response | Effect]:
            """Analyze uploaded file content using LLM.
            Accepts multipart form data with 'file' and 'input' fields.
            """
            content = b""
            mime_type = ""
            user_input = ""
            # Parse form data
            form_data = self.request.form_data()
            if "file" in form_data and isinstance(form_data["file"], FileFormPart):
                content = form_data["file"].content
                mime_type = form_data["file"].content_type
            if "input" in form_data and isinstance(form_data["input"], StringFormPart):
                user_input = form_data["input"].value
            if not (content and mime_type and user_input):
                return [PlainTextResponse("Missing file or input", status_code=HTTPStatus.BAD_REQUEST)]
            client = self._llm_client()
            # Create FileContent with base64-encoded data
            file = FileContent(
                mime_type=mime_type,
                content=base64.b64encode(content),
                size=len(content),
            )
            client.file_content.append(file)
            client.set_system_prompt(["Answer the question about the file clearly and concisely."])
            client.set_user_prompt([user_input])
            response = client.attempt_requests(attempts=1)[0]
            return [PlainTextResponse(response.response, status_code=response.code)]
    ```
##  Error Handling 
The LLM clients return `LlmResponse` objects with HTTP status codes indicating success or failure.
    ```python
    from http import HTTPStatus
    response = client.request()
    if response.code == HTTPStatus.OK:
        print(f"Success: {response.response}")
    elif response.code == HTTPStatus.TOO_MANY_REQUESTS:
        print("Rate limited - try again later")
    elif response.code == HTTPStatus.UNAUTHORIZED:
        print("Invalid API key")
    elif response.code == HTTPStatus.BAD_REQUEST:
        print(f"Bad request: {response.response}")
    else:
        print(f"Error {response.code}: {response.response}")
    ```
When using `attempt_requests`, the method will automatically retry on failure:
    ```python
    responses = client.attempt_requests(attempts=3)
    # Check if any attempt succeeded
    successful = [r for r in responses if r.code == HTTPStatus.OK]
    if successful:
        print(f"Success after {len(responses)} attempt(s)")
    else:
        print(f"All {len(responses)} attempts failed")
    ```
##  Provider-Specific Notes 
###  OpenAI 
  - Uses the Responses API (`/v1/responses`)
  - Supports images and PDFs via URL (`add_url_file`) or direct content (`file_content`)
  - System prompts are sent as `instructions`
  - Direct file content uses `input_image` for images and `input_file` for PDFs
###  Anthropic 
  - Uses the Messages API (`/v1/messages`)
  - Supports images, PDFs, and text files via URL or direct content
  - Text files are base64-decoded and sent as plain text
  - Structured output uses tool calling
###  Google Gemini 
  - Uses the Generative Language API
  - Files via URL are downloaded and converted to base64 automatically
  - Supports both URL-based and direct file content
  - Maximum file size limit of 10MB per request (combined)
  - Structured output uses `responseJsonSchema`
##  Additional Resources 
  - [OpenAI API Documentation](https://platform.openai.com/docs/api-reference)
  - [Anthropic API Documentation](https://docs.anthropic.com/en/api)
  - [Google Gemini API Documentation](https://ai.google.dev/gemini-api/docs)
  - [Example Plugin](/sdk/example-llm/) \- Documentation for the example plugin
  - [Source Code](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/llm) \- View the source on GitHub
----- END PAGE https://docs.canvasmedical.com/sdk/clients-llms/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/clients-sendgrid/
The Canvas SDK SendGrid client provides a simple interface for sending emails, managing webhooks, and querying email logs using the SendGrid API.
##  Requirements 
  - **SendGrid API Key** : Create one at https://app.sendgrid.com/settings/api_keys
  - **Authenticated Domain** : Configure at https://app.sendgrid.com/settings/sender_auth
##  Imports 
The SendGrid client is included in the Canvas SDK. Import the necessary components:
    ```python
    from canvas_sdk.clients.sendgrid.libraries import EmailClient
    from canvas_sdk.clients.sendgrid.constants import RecipientType
    from canvas_sdk.clients.sendgrid.structures import (
        Address,
        BodyContent,
        Email,
        Recipient,
        RequestFailed,
        Settings,
    )
    ```
##  Initialize the Client 
    ```python
    client = EmailClient(Settings(key="your_sendgrid_api_key"))
    ```
##  Send a Simple Text Email 
    ```python
    from canvas_sdk.clients.sendgrid.libraries import EmailClient
    from canvas_sdk.clients.sendgrid.constants import RecipientType
    from canvas_sdk.clients.sendgrid.structures import (
        Address, BodyContent, Email, Recipient, RequestFailed, Settings
    )
    client = EmailClient(Settings(key="your_api_key"))
    email = Email(
        sender=Address(email="sender@example.com", name="Sender Name"),
        reply_tos=[Address(email="reply@example.com", name="Reply To")],
        recipients=[
            Recipient(address=Address(email="recipient@example.com", name="Recipient"), type=RecipientType.TO)
        ],
        subject="Hello from Canvas SDK",
        bodies=[BodyContent(type="text/plain", value="This is a test email.")],
        attachments=[],
        send_at=Email.now(),
    )
    try:
        client.simple_send(email)
        print("Email sent successfully!")
    except RequestFailed as e:
        print(f"Failed to send email: {e.message} (HTTP {e.status_code})")
    ```
##  Send an HTML Email with CC 
    ```python
    email = Email(
        sender=Address(email="sender@example.com", name="Sender"),
        reply_tos=[Address(email="reply@example.com", name="Reply To")],
        recipients=[
            Recipient(address=Address(email="to@example.com", name="To"), type=RecipientType.TO),
            Recipient(address=Address(email="cc@example.com", name="CC"), type=RecipientType.CC),
        ],
        subject="HTML Email Example",
        bodies=[
            BodyContent(type="text/plain", value="Plain text fallback"),
            BodyContent(type="text/html", value="<html><body><h1>Hello!</h1><p>This is HTML content.</p></body></html>"),
        ],
        attachments=[],
        send_at=Email.now(),
    )
    client.simple_send(email)
    ```
##  Send an Email with Attachment 
    ```python
    from canvas_sdk.clients.sendgrid.structures import Attachment
    # Create attachment from URL
    attachment = Attachment.from_url(
        url="https://example.com/document.pdf",
        headers={},
        filename="document.pdf"
    )
    email = Email(
        sender=Address(email="sender@example.com", name="Sender"),
        reply_tos=[Address(email="reply@example.com", name="Reply To")],
        recipients=[
            Recipient(address=Address(email="to@example.com", name="To"), type=RecipientType.TO)
        ],
        subject="Email with Attachment",
        bodies=[BodyContent(type="text/plain", value="Please find attached document.")],
        attachments=[attachment],
        send_at=Email.now(),
    )
    client.simple_send(email)
    ```
##  Send an Email with Inline Image 
    ```python
    # Create inline image attachment
    inline_image = Attachment.from_url_inline(
        url="https://example.com/logo.png",
        headers={},
        filename="logo.png",
        content_id="logo123"
    )
    email = Email(
        sender=Address(email="sender@example.com", name="Sender"),
        reply_tos=[Address(email="reply@example.com", name="Reply To")],
        recipients=[
            Recipient(address=Address(email="to@example.com", name="To"), type=RecipientType.TO)
        ],
        subject="Email with Inline Image",
        bodies=[
            BodyContent(type="text/plain", value="See image in HTML version"),
            BodyContent(type="text/html", value='<html><body><img src="cid:logo123" width="200"/></body></html>'),
        ],
        attachments=[inline_image],
        send_at=Email.now(),
    )
    client.simple_send(email)
    ```
##  Query Sent Emails 
    ```python
    from datetime import datetime
    from canvas_sdk.clients.sendgrid.constants import CriterionOperation
    from canvas_sdk.clients.sendgrid.structures import CriterionDatetime, LoggedEmailCriteria
    criteria = LoggedEmailCriteria(
        message_id="",
        subject="",
        to_email="recipient@example.com",
        reason="",
        status=[],
        message_created_at=[
            CriterionDatetime(
                date_time=datetime(2024, 1, 1),
                operation=CriterionOperation.GREATER_THAN_OR_EQUAL
            )
        ],
    )
    for email in client.logged_emails(criteria, up_to=10):
        print(f"Subject: {email.subject}, Status: {email.status.value}")
    ```
##  EmailClient 
The main class for interacting with the SendGrid API.
###  Constructor 
    ```python
    EmailClient(settings: Settings)
    ```
Parameter | Type | Description  
---|---|---  
`settings` | `Settings` | Configuration object containing the API key  
###  Sending Emails 
####  `simple_send(email: Email) -> bool`
Send an email using a structured `Email` object. This is the recommended method for most use cases.
**Returns:** `True` on success
**Raises:** `RequestFailed` on error
####  `prepared_send(data: dict) -> bool`
Send an email using a raw dictionary following SendGrid's API schema. Use this for advanced cases not covered by `simple_send`.
**Parameters:**
  - `data`: Dictionary following [SendGrid's mail send schema](https://www.twilio.com/docs/sendgrid/api-reference/mail-send/mail-send#request-body)
**Returns:** `True` on success
**Raises:** `RequestFailed` on error
###  Email Logs 
####  `logged_emails(criteria: LoggedEmailCriteria, up_to: int) -> Iterator[SentEmail]`
Query sent emails matching the specified criteria.
**Parameters:**
  - `criteria`: Filter criteria for the query
  - `up_to`: Maximum number of results to return
**Returns:** Iterator of `SentEmail` objects
####  `logged_email(message_id: str) -> SentEmailDetail`
Get detailed information about a specific email including its event history.
**Parameters:**
  - `message_id`: The SendGrid message ID
**Returns:** `SentEmailDetail` object with full event history
###  Inbound Parse Webhooks 
Configure webhooks to receive incoming emails.
Method | Description  
---|---  
`parser_setting_add(setting: ParseSetting) -> ParseSetting` | Create a new inbound parse webhook  
`parser_setting_delete(hostname: str) -> bool` | Delete a webhook by hostname  
`parser_setting_get(hostname: str) -> ParseSetting` | Get webhook configuration by hostname  
`parser_setting_list() -> Iterator[ParseSetting]` | List all inbound parse webhooks  
Requires MX record setup pointing to `mx.sendgrid.net`, for example:
host | type | priority | TTL | value  
---|---|---|---|---  
`canvas` | `MX` | 10 | 1 hr | `mx.sendgrid.net`  
###  Event Webhooks 
Configure webhooks to receive email delivery status notifications.
Method | Description  
---|---  
`event_webhook_add(event: EventWebhook) -> EventWebhookRecord` | Create a new event webhook  
`event_webhook_delete(event_webhook_id: str) -> bool` | Delete a webhook by ID  
`event_webhook_get(event_webhook_id: str) -> EventWebhookRecord` | Get webhook by ID  
`event_webhook_list() -> Iterator[EventWebhookRecord]` | List all event webhooks  
`event_webhook_sign(event_webhook_id: str, enabled: bool) -> str` | Enable/disable signature verification, returns public key  
##  Data Structures 
###  Settings 
Configuration for the EmailClient.
Field | Type | Description  
---|---|---  
`key` | `str` | SendGrid API key  
###  Address 
Represents an email address with display name.
Field | Type | Description  
---|---|---  
`email` | `str` | Email address  
`name` | `str` | Display name  
###  Recipient 
Represents an email recipient with type.
Field | Type | Description  
---|---|---  
`address` | `Address` | Email address object  
`type` | `RecipientType` | TO, CC, or BCC  
###  BodyContent 
Represents email body content with MIME type.
Field | Type | Description  
---|---|---  
`type` | `str` | MIME type (e.g., `text/plain`, `text/html`)  
`value` | `str` | Content  
###  Email 
Complete email message structure.
Field | Type | Description  
---|---|---  
`sender` | `Address` | Sender email address  
`reply_tos` | `list[Address]` | Reply-to addresses  
`recipients` | `list[Recipient]` | List of recipients (TO/CC/BCC)  
`subject` | `str` | Email subject line  
`bodies` | `list[BodyContent]` | Email body content(s)  
`attachments` | `list[Attachment]` | File attachments  
`send_at` | `int` | Unix timestamp for sending  
**Class Methods:**
Method | Description  
---|---  
`Email.now() -> int` | Get current timestamp for immediate send  
`Email.timestamp(dt: datetime) -> int` | Convert datetime to Unix timestamp  
###  Attachment 
Represents an email attachment.
Field | Type | Description  
---|---|---  
`content_id` | `str` | ID for inline references  
`content` | `str` | Base64 encoded content  
`type` | `str` | MIME type  
`filename` | `str` | Filename  
`disposition` | `AttachmentDisposition` | ATTACHMENT or INLINE  
**Class Methods:**
Method | Description  
---|---  
`Attachment.from_url(url, headers, filename) -> Attachment` | Create attachment from URL  
`Attachment.from_url_inline(url, headers, filename, content_id) -> Attachment` | Create inline attachment from URL  
###  LoggedEmailCriteria 
Search criteria for querying sent emails.
Field | Type | Description  
---|---|---  
`message_id` | `str` | Filter by message ID  
`subject` | `str` | Filter by subject  
`to_email` | `str` | Filter by recipient email  
`reason` | `str` | Filter by reason  
`status` | `list[StatusEmail]` | Filter by status(es)  
`message_created_at` | `list[CriterionDatetime]` | Filter by creation date/time  
###  CriterionDatetime 
DateTime comparison for email queries.
Field | Type | Description  
---|---|---  
`date_time` | `datetime` | Date/time to compare  
`operation` | `CriterionOperation` | Comparison operator  
###  SentEmail 
Basic information about a sent email (returned by `logged_emails`).
Field | Type | Description  
---|---|---  
`from_email` | `str` | Sender email address  
`message_id` | `str` | SendGrid message ID  
`subject` | `str` | Email subject  
`to_email` | `str` | Recipient email address  
`reason` | `str` | Delivery failure reason  
`status` | `StatusEmail` | Delivery status  
`created_at` | `datetime` | Creation timestamp  
###  SentEmailDetail 
Detailed sent email information with event history (returned by `logged_email`).
Field | Type | Description  
---|---|---  
`from_email` | `str` | Sender email address  
`message_id` | `str` | SendGrid message ID  
`subject` | `str` | Email subject  
`to_email` | `str` | Recipient email address  
`status` | `StatusEmail` | Current delivery status  
`events` | `list[EmailEvent]` | List of lifecycle events  
###  EmailEvent 
Represents an event in an email's lifecycle.
Field | Type | Description  
---|---|---  
`event` | `EventEmail` | Event type  
`email` | `str` | Recipient email address  
`message_id` | `str` | SendGrid message ID  
`event_id` | `str` | Unique event ID  
`on_datetime` | `datetime` | Event timestamp  
`reason` | `str` | Reason (for bounce, dropped events)  
`response` | `str` | Server response (for delivered events)  
`url` | `str` | Clicked/opened URL (for click, open)  
`attempt` | `int` | Delivery attempt number (for deferred)  
###  ParseSetting 
Configuration for inbound email parsing.
Field | Type | Description  
---|---|---  
`url` | `str` | Webhook URL to receive parsed emails  
`hostname` | `str` | Domain to receive emails (requires MX record)  
`spam_check` | `bool` | Enable spam filtering  
`send_raw` | `bool` | Send raw MIME message instead of parsed  
###  EventWebhook 
Configuration for outbound email event notifications.
Field | Type | Description  
---|---|---  
`enabled` | `bool` | Whether webhook is active  
`url` | `str` | Webhook URL  
`friendly_name` | `str` | Display name  
`delivered` | `bool` | Track delivered events  
`bounce` | `bool` | Track bounce events  
`dropped` | `bool` | Track dropped events  
`spam_report` | `bool` | Track spam report events  
`processed` | `bool` | Track processed events  
`open` | `bool` | Track open events  
`click` | `bool` | Track click events  
`unsubscribe` | `bool` | Track unsubscribe events  
`group_resubscribe` | `bool` | Track group resubscribe events  
`group_unsubscribe` | `bool` | Track group unsubscribe events  
###  EventWebhookRecord 
Stored event webhook with metadata (extends EventWebhook).
Field | Type | Description  
---|---|---  
_(all fields from EventWebhook)_ |  |   
`id` | `str` | Webhook ID  
`public_key` | `str` | Public key for signature verification  
`created_date` | `datetime` | Creation timestamp  
`updated_date` | `datetime` | Last update timestamp  
###  ParsedEmail 
Represents an inbound email received via the Inbound Parse webhook.
Field | Type | Description  
---|---|---  
`headers` | `list[ParsedHeader]` | Email headers  
`charsets` | `dict[str, str]` | Character set mappings  
`envelope` | `ParsedEnvelope` | SMTP envelope information  
`email_from` | `str` | Sender address  
`email_to` | `str` | Recipient address  
`subject` | `str` | Email subject  
`text` | `str` | Plain text body  
`html` | `str` | HTML body  
`attachments` | `int` | Number of attachments  
`attachment_info` | `dict[str, ParsedAttachment]` | Attachment metadata  
`content_ids` | `dict[str, str]` | Content ID mappings  
`spf` | `str` | SPF verification result  
`dkim` | `str` | DKIM verification result  
`spam_report` | `list[str]` | Spam analysis report  
`spam_score` | `float` | Spam score  
##  Constants (Enums) 
###  RecipientType 
Value | Description  
---|---  
`TO` | Primary recipient  
`CC` | Carbon copy  
`BCC` | Blind carbon copy  
###  AttachmentDisposition 
Value | Description  
---|---  
`ATTACHMENT` | Standard file attachment  
`INLINE` | Embedded in email body  
###  StatusEmail 
Email delivery status values.
Value | Description  
---|---  
`PROCESSED` | Email processed by SendGrid  
`DELIVERED` | Successfully delivered  
`NOT_DELIVERED` | Delivery failed  
`DEFERRED` | Temporarily delayed  
`DROPPED` | Dropped by SendGrid  
`BOUNCED` | Bounced back  
`BLOCKED` | Blocked by recipient  
###  EventEmail 
Email event types for webhooks.
Value | Description  
---|---  
`BOUNCE` | Email bounced  
`CLICK` | Link clicked  
`DEFERRED` | Delivery deferred  
`DELIVERED` | Email delivered  
`DROPPED` | Email dropped  
`CANCEL_DROP` | Drop cancelled  
`OPEN` | Email opened  
`PROCESSED` | Email processed  
`RECEIVED` | Inbound email received  
`SPAM_REPORT` | Reported as spam  
`GROUP_UNSUBSCRIBE` | Unsubscribed from group  
`GROUP_RESUBSCRIBE` | Resubscribed to group  
`UNSUBSCRIBE` | Unsubscribed  
###  CriterionOperation 
Comparison operators for email log queries.
Value | Symbol | Description  
---|---|---  
`GREATER_THAN` | `>` | Greater than  
`GREATER_THAN_OR_EQUAL` | `>=` | Greater than or equal  
`LOWER_THAN` | `<` | Less than  
`LOWER_THAN_OR_EQUAL` | `<=` | Less than or equal  
`EQUAL` | `=` | Equal to  
##  Error Handling 
###  RequestFailed 
Exception raised when a SendGrid API request fails (extends `RuntimeError`).
Attribute | Type | Description  
---|---|---  
`status_code` | `int` | HTTP status code  
`message` | `str` | Error message from SendGrid  
**Example:**
    ```python
    try:
        client.simple_send(email)
    except RequestFailed as e:
        print(f"Error {e.status_code}: {e.message}")
    ```
##  Webhook Setup Examples 
###  Inbound Parse Webhook (Receive Incoming Emails) 
    ```python
    from canvas_sdk.clients.sendgrid.structures import ParseSetting
    # Note: Requires MX record for the hostname pointing to mx.sendgrid.net
    setting = ParseSetting(
        url="https://your-app.com/api/incoming-email",
        hostname="mail.yourdomain.com",
        spam_check=True,
        send_raw=False,
    )
    try:
        created = client.parser_setting_add(setting)
        print(f"Inbound webhook created for {created.hostname}")
    except RequestFailed as e:
        print(f"Failed: {e.message}")
    ```
###  Event Webhook (Track Outbound Email Status) 
    ```python
    from canvas_sdk.clients.sendgrid.structures import EventWebhook
    webhook = EventWebhook(
        url="https://your-app.com/api/email-events",
        enabled=True,
        friendly_name="My Email Tracker",
        delivered=True,
        bounce=True,
        dropped=True,
        spam_report=True,
        processed=True,
        open=True,
        click=True,
        unsubscribe=False,
        group_resubscribe=False,
        group_unsubscribe=False,
    )
    try:
        created = client.event_webhook_add(webhook)
        print(f"Event webhook created with ID: {created.id}")
    except RequestFailed as e:
        print(f"Failed: {e.message}")
    ```
##  Additional Resources 
  - [SendGrid API Documentation](https://www.twilio.com/docs/sendgrid/api-reference)
  - [Inbound Parse Webhook Setup](https://www.twilio.com/docs/sendgrid/for-developers/parsing-email/inbound-email)
  - [Event Webhook Documentation](https://www.twilio.com/docs/sendgrid/for-developers/tracking-events/event)
  - [Example Plugin](/sdk/example-sendgrid_email/) \- Documentation for the example plugin
  - [Source Code](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/sendgrid_email) \- View the source on GitHub
----- END PAGE https://docs.canvasmedical.com/sdk/clients-sendgrid/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/clients-twilio/
The Canvas SDK Twilio client provides a simple interface for sending SMS and MMS messages, managing phone numbers, and handling webhooks using the Twilio API.
##  Requirements 
  - **Twilio Account SID** : Found in your [Twilio Console](https://console.twilio.com/)
  - **Twilio API Key and Secret** : Create at [API Keys](https://console.twilio.com/us1/account/keys-credentials/api-keys)
  - **Twilio Phone Number** : Purchase at [Phone Numbers](https://console.twilio.com/us1/develop/phone-numbers/manage/incoming)
##  Imports 
The Twilio client is included in the Canvas SDK. Import the necessary components:
    ```python
    from canvas_sdk.clients.twilio.libraries import SmsClient
    from canvas_sdk.clients.twilio.structures import Settings, SmsMms, RequestFailed
    ```
##  Initialize the Client 
    ```python
    settings = Settings(
        account_sid="your_account_sid",
        key="your_api_key",
        secret="your_api_secret",
    )
    client = SmsClient(settings)
    ```
##  Send a Simple SMS 
    ```python
    from canvas_sdk.clients.twilio.libraries import SmsClient
    from canvas_sdk.clients.twilio.structures import Settings, SmsMms, RequestFailed
    # Initialize the client
    settings = Settings(
        account_sid="ACxxxxxxxxxxxxxxxxx",
        key="SKxxxxxxxxxxxxxxxxx",
        secret="your_api_secret",
    )
    client = SmsClient(settings)
    # First, get your phone number SID
    phones = list(client.account_phone_numbers())
    phone = phones[0]  # Use the first phone number
    print(f"Using phone: {phone.phone_number} (SID: {phone.sid})")
    # Create and send the SMS
    sms = SmsMms(
        number_from=phone.phone_number,
        number_from_sid=phone.sid,
        number_to="+1234567890",
        message="Hello from Canvas SDK!",
        media_url="",
        status_callback_url="",
    )
    try:
        message = client.send_sms_mms(sms)
        print(f"Message sent! SID: {message.sid}, Status: {message.status.value}")
    except RequestFailed as e:
        print(f"Failed to send: {e.message} (HTTP {e.status_code})")
    ```
##  Send an MMS with Image 
    ```python
    # Create an MMS with an image attachment
    mms = SmsMms(
        number_from=phone.phone_number,
        number_from_sid=phone.sid,
        number_to="+1234567890",
        message="Check out this image!",
        media_url="https://example.com/image.jpg",
        status_callback_url="",
    )
    try:
        message = client.send_sms_mms(mms)
        print(f"MMS sent! SID: {message.sid}")
    except RequestFailed as e:
        print(f"Failed to send: {e.message}")
    ```
##  Send SMS with Status Callback 
    ```python
    # Send SMS with a callback URL to track delivery status
    sms = SmsMms(
        number_from=phone.phone_number,
        number_from_sid=phone.sid,
        number_to="+1234567890",
        message="Message with tracking",
        media_url="",
        status_callback_url="https://your-app.com/api/sms-status",
    )
    message = client.send_sms_mms(sms)
    print(f"Message queued with callback. SID: {message.sid}")
    ```
##  Retrieve Message History 
    ```python
    from canvas_sdk.clients.twilio.constants import DateOperation
    # Get all messages (no filters)
    for message in client.retrieve_all_sms("", "", "", DateOperation.ON_EXACTLY):
        print(f"{message.date_sent}: {message.number_from} -> {message.number_to}: {message.body}")
    # Get messages sent to a specific number
    for message in client.retrieve_all_sms("+1234567890", "", "", DateOperation.ON_EXACTLY):
        print(f"To {message.number_to}: {message.body}")
    # Get messages from a specific date onwards
    for message in client.retrieve_all_sms("", "", "2024-01-01", DateOperation.ON_AND_AFTER):
        print(f"{message.date_sent}: {message.body}")
    ```
##  Handle Inbound Messages (Webhook) 
When Twilio receives an SMS to your number, it can call your webhook. Parse the callback data:
    ```python
    from canvas_sdk.clients.twilio.structures import StatusInbound, TwiMlMessage
    def handle_inbound_sms(raw_body: str) -> str:
        """Process incoming SMS and return TwiML response."""
        # Parse the incoming message
        inbound = StatusInbound.callback_inbound(raw_body)
        print(f"Received from {inbound.number_from}: {inbound.body}")
        # Create a reply using TwiML
        if "hello" in inbound.body.lower():
            reply = TwiMlMessage.instance("Hello! Nice to hear from you!")
        else:
            reply = TwiMlMessage.instance("Thanks for your message!")
        return reply.to_xml()
    ```
##  Reply with MMS (TwiML) 
    ```python
    from canvas_sdk.clients.twilio.structures import TwiMlMessage
    # Create a TwiML response with text and image
    reply = TwiMlMessage.instance_with_media(
        message_text="Here's a picture for you!",
        media_url="https://example.com/image.jpg"
    )
    xml_response = reply.to_xml()
    # Returns TwiML like:
    # <?xml version="1.0" encoding="UTF-8"?>
    # <Response><Message><Body>Here's a picture for you!</Body><Media>https://example.com/image.jpg</Media></Message></Response>
    ```
##  SmsClient 
The main class for interacting with the Twilio SMS/MMS API.
###  Constructor 
    ```python
    SmsClient(settings: Settings)
    ```
Parameter | Type | Description  
---|---|---  
`settings` | `Settings` | Configuration object with Twilio credentials  
###  Phone Number Management 
####  `account_phone_numbers() -> Iterator[Phone]`
Retrieve all phone numbers associated with the Twilio account.
    ```python
    for phone in client.account_phone_numbers():
        print(f"{phone.friendly_name}: {phone.phone_number}")
        print(f"  SMS: {phone.capabilities.sms}, MMS: {phone.capabilities.mms}")
    ```
**Returns:** Iterator of `Phone` objects
**Raises:** `RequestFailed` on error
####  `account_phone_number(phone_sid: str) -> Phone`
Retrieve details for a specific phone number by its SID.
    ```python
    phone = client.account_phone_number("PNxxxxxxxxxxxxxxxxx")
    print(f"Phone: {phone.phone_number}, Status: {phone.status}")
    ```
Parameter | Type | Description  
---|---|---  
`phone_sid` | `str` | The Twilio SID of the phone  
**Returns:** `Phone` object
**Raises:** `RequestFailed` on error
####  `set_inbound_webhook(phone_sid: str, webhook_url: str, method: HttpMethod) -> bool`
Configure the webhook URL for receiving inbound messages on a phone number.
    ```python
    from canvas_sdk.clients.twilio.constants import HttpMethod
    success = client.set_inbound_webhook(
        phone_sid="PNxxxxxxxxxxxxxxxxx",
        webhook_url="https://your-app.com/api/inbound-sms",
        method=HttpMethod.POST
    )
    ```
Parameter | Type | Description  
---|---|---  
`phone_sid` | `str` | The Twilio SID of the phone  
`webhook_url` | `str` | URL to receive inbound messages  
`method` | `HttpMethod` | HTTP method (GET or POST)  
**Returns:** `True` on success
**Raises:** `RequestFailed` on error
###  Sending Messages 
####  `send_sms_mms(sms_mms: SmsMms) -> Message`
Send an SMS or MMS message. The method automatically validates phone capabilities.
    ```python
    sms = SmsMms(
        number_from="+15551234567",
        number_from_sid="PNxxxxxxxxxxxxxxxxx",
        number_to="+15559876543",
        message="Hello!",
        media_url="",  # Empty for SMS, URL for MMS
        status_callback_url="https://your-app.com/status",
    )
    message = client.send_sms_mms(sms)
    print(f"Sent! SID: {message.sid}, Status: {message.status.value}")
    ```
Parameter | Type | Description  
---|---|---  
`sms_mms` | `SmsMms` | Message details to send  
**Returns:** `Message` object with sent message details
**Raises:** `RequestFailed` if the phone lacks required capabilities or API fails
###  Retrieving Messages 
####  `retrieve_sms(message_id: str) -> Message`
Get details for a specific message by its SID.
    ```python
    message = client.retrieve_sms("SMxxxxxxxxxxxxxxxxx")
    print(f"Status: {message.status.value}")
    print(f"Body: {message.body}")
    print(f"Sent: {message.date_sent}")
    ```
Parameter | Type | Description  
---|---|---  
`message_id` | `str` | The Twilio message SID  
**Returns:** `Message` object
**Raises:** `RequestFailed` on error
####  `retrieve_all_sms(number_to, number_from, date_sent, date_operation) -> Iterator[Message]`
Retrieve messages with optional filtering.
    ```python
    from canvas_sdk.clients.twilio.constants import DateOperation
    # All messages
    for msg in client.retrieve_all_sms("", "", "", DateOperation.ON_EXACTLY):
        print(msg.body)
    # Messages to a specific number
    for msg in client.retrieve_all_sms("+15551234567", "", "", DateOperation.ON_EXACTLY):
        print(msg.body)
    # Messages from a specific date
    for msg in client.retrieve_all_sms("", "", "2024-06-01", DateOperation.ON_AND_AFTER):
        print(f"{msg.date_sent}: {msg.body}")
    ```
Parameter | Type | Description  
---|---|---  
`number_to` | `str` | Filter by recipient (empty = no filter)  
`number_from` | `str` | Filter by sender (empty = no filter)  
`date_sent` | `str` | Date to filter by (YYYY-MM-DD format)  
`date_operation` | `DateOperation` | How to compare the date  
**Returns:** Iterator of `Message` objects
**Raises:** `RequestFailed` on error
####  `delete_sms(message_id: str) -> bool`
Delete a message from Twilio.
    ```python
    deleted = client.delete_sms("SMxxxxxxxxxxxxxxxxx")
    print(f"Deleted: {deleted}")
    ```
Parameter | Type | Description  
---|---|---  
`message_id` | `str` | The Twilio message SID  
**Returns:** `True` on success
**Raises:** `RequestFailed` on error
###  Media Handling 
####  `retrieve_media_list(message_id: str) -> Iterator[Media]`
Get all media attachments for a message.
    ```python
    for media in client.retrieve_media_list("SMxxxxxxxxxxxxxxxxx"):
        print(f"Media SID: {media.sid}")
        print(f"Content Type: {media.content_type}")
    ```
Parameter | Type | Description  
---|---|---  
`message_id` | `str` | The Twilio message SID  
**Returns:** Iterator of `Media` objects
**Raises:** `RequestFailed` on error
####  `retrieve_raw_media(message_id: str, media_sid: str) -> bytes`
Download the raw binary content of a media attachment.
    ```python
    for media in client.retrieve_media_list(message_sid):
        content = client.retrieve_raw_media(message_sid, media.sid)
        # Save to file
        with open(f"media_{media.sid}.jpg", "wb") as f:
            f.write(content)
    ```
Parameter | Type | Description  
---|---|---  
`message_id` | `str` | The Twilio message SID  
`media_sid` | `str` | The Twilio media SID  
**Returns:** Raw binary content (`bytes`)
**Raises:** `RequestFailed` on error
##  Data Structures 
###  Settings 
Configuration for the SmsClient.
Field | Type | Description  
---|---|---  
`account_sid` | `str` | Twilio Account SID  
`key` | `str` | Twilio API Key SID  
`secret` | `str` | Twilio API Key Secret  
###  SmsMms 
Represents an SMS or MMS message to send.
Field | Type | Description  
---|---|---  
`number_from` | `str` | Sender phone number (E.164 format)  
`number_from_sid` | `str` | Twilio SID of the sender phone number  
`number_to` | `str` | Recipient phone number (E.164 format)  
`message` | `str` | Text content of the message  
`media_url` | `str` | URL of media to attach (empty for SMS)  
`status_callback_url` | `str` | URL to receive delivery status updates  
###  Message 
Represents a Twilio message with full metadata.
Field | Type | Description  
---|---|---  
`sid` | `str` | Unique message identifier  
`body` | `str` | Message text content  
`date_created` | `datetime` | When the message was created  
`date_sent` | `datetime \| None` | When the message was sent  
`date_updated` | `datetime` | When the message was last updated  
`direction` | `MessageDirection` | Message direction  
`number_from` | `str` | Sender phone number  
`number_to` | `str` | Recipient phone number  
`price` | `str \| None` | Cost of the message  
`price_unit` | `str` | Currency of the price  
`error_code` | `int \| None` | Error code if failed  
`error_message` | `str \| None` | Error description if failed  
`uri` | `str` | API URI for this resource  
`count_media` | `int \| None` | Number of media attachments  
`count_segments` | `int` | Number of SMS segments  
`status` | `MessageStatus` | Current message status  
`sub_resource_uris` | `dict[str, str] \| None` | URIs to related resources  
###  Phone 
Represents a Twilio phone number with configuration.
Field | Type | Description  
---|---|---  
`account_sid` | `str` | Twilio Account SID  
`capabilities` | `Capabilities` | Phone capabilities (SMS, MMS, etc.)  
`date_created` | `datetime` | When added to account  
`date_updated` | `datetime` | Last configuration update  
`friendly_name` | `str` | User-defined name  
`phone_number` | `str` | Phone number in E.164 format  
`sid` | `str` | Unique phone number identifier  
`sms_fallback_method` | `HttpMethod` | HTTP method for fallback URL  
`sms_fallback_url` | `str` | Fallback URL if primary fails  
`sms_method` | `HttpMethod` | HTTP method for SMS webhook  
`sms_url` | `str` | Webhook URL for inbound SMS  
`status_callback_method` | `HttpMethod` | HTTP method for status callbacks  
`status_callback` | `str` | URL for status updates  
`status` | `str` | Current phone number status  
###  Capabilities 
Phone number communication capabilities.
Field | Type | Description  
---|---|---  
`fax` | `bool` | Supports fax  
`mms` | `bool` | Supports MMS (multimedia)  
`sms` | `bool` | Supports SMS (text)  
`voice` | `bool` | Supports voice calls  
###  Media 
Represents media attached to a message.
Field | Type | Description  
---|---|---  
`sid` | `str` | Unique media identifier  
`content_type` | `str` | MIME type (e.g., `image/jpeg`)  
`date_created` | `datetime` | When the media was created  
`date_updated` | `datetime` | When the media was last updated  
`parent_sid` | `str` | Message SID this media belongs to  
`uri` | `str` | API URI for this resource  
###  StatusInbound 
Parsed data from an inbound message webhook callback.
Field | Type | Description  
---|---|---  
`account_sid` | `str` | Twilio Account SID  
`message_sid` | `str` | Message SID  
`messaging_service_sid` | `str` | Messaging Service SID  
`sms_message_sid` | `str` | SMS Message SID  
`sms_sid` | `str` | SMS SID  
`sms_status` | `MessageStatus` | Message status  
`to_country` | `str` | Recipient country  
`to_zip` | `str` | Recipient ZIP code  
`to_state` | `str` | Recipient state  
`to_city` | `str` | Recipient city  
`from_country` | `str` | Sender country  
`from_zip` | `str` | Sender ZIP code  
`from_state` | `str` | Sender state  
`from_city` | `str` | Sender city  
`number_to` | `str` | Recipient phone number  
`number_from` | `str` | Sender phone number  
`body` | `str` | Message text  
`count_media` | `int` | Number of media attachments  
`count_segments` | `int` | Number of SMS segments  
`media_content_type` | `list[str]` | MIME types of attached media  
`media_url` | `list[str]` | URLs of attached media  
**Class Methods:**
Method | Description  
---|---  
`StatusInbound.callback_inbound(raw_body)` | Parse URL-encoded webhook body  
###  StatusOutboundApi 
Parsed data from an outbound message status callback.
Field | Type | Description  
---|---|---  
`account_sid` | `str` | Twilio Account SID  
`message_sid` | `str` | Message SID  
`sms_sid` | `str` | SMS SID  
`sms_status` | `MessageStatus` | SMS status  
`message_status` | `MessageStatus` | Message status  
`number_to` | `str` | Recipient phone number  
`number_from` | `str` | Sender phone number  
**Class Methods:**
Method | Description  
---|---  
`StatusOutboundApi.callback_outbound_api(raw_body)` | Parse URL-encoded webhook body  
###  TwiMlMessage 
Generates TwiML XML for responding to inbound messages.
Field | Type | Description  
---|---|---  
`number_to` | `str` | Recipient (optional in response)  
`number_from` | `str` | Sender (optional in response)  
`status_callback_url` | `str` | Status callback URL  
`message_text` | `str` | Message text content  
`media_url` | `str` | Media URL to attach  
`method` | `HttpMethod\|None` | HTTP method for callbacks  
**Class Methods:**
Method | Description  
---|---  
`TwiMlMessage.instance(message_text) -> TwiMlMessage` | Create text-only TwiML message  
`TwiMlMessage.instance_with_media(message_text, media_url) -> TwiMlMessage` | Create TwiML with media  
**Instance Methods:**
Method | Description  
---|---  
`to_xml() -> str` | Generate TwiML XML string  
**Example:**
    ```python
    # Simple text reply
    reply = TwiMlMessage.instance("Thanks for your message!")
    xml = reply.to_xml()
    # Reply with media
    reply = TwiMlMessage.instance_with_media("Check this out!", "https://example.com/image.jpg")
    xml = reply.to_xml()
    ```
##  Constants (Enums) 
###  MessageStatus 
Message lifecycle status values.
Value | Description  
---|---  
`ACCEPTED` | Message accepted by Twilio  
`SCHEDULED` | Message scheduled for future delivery  
`CANCELED` | Scheduled message was canceled  
`QUEUED` | Message queued for sending  
`SENDING` | Message is being sent  
`SENT` | Message sent to carrier  
`FAILED` | Message failed to send  
`DELIVERED` | Message delivered to recipient  
`UNDELIVERED` | Message could not be delivered  
`PARTIALLY_DELIVERED` | Some recipients received the message  
`RECEIVING` | Inbound message being received  
`RECEIVED` | Inbound message received  
`READ` | Message was read (WhatsApp only)  
###  MessageDirection 
Message direction types.
Value | Description  
---|---  
`INBOUND` | Message received from external number  
`OUTBOUND_API` | Message sent via API  
`OUTBOUND_CALL` | Message sent during a call  
`OUTBOUND_REPLY` | Message sent as webhook reply  
###  DateOperation 
Date filtering operations for message queries.
Value | Description  
---|---  
`ON_EXACTLY` | Messages on exactly this date  
`ON_AND_BEFORE` | Messages on or before this date  
`ON_AND_AFTER` | Messages on or after this date  
###  HttpMethod 
HTTP methods for webhook configuration.
Value | Description  
---|---  
`GET` | HTTP GET method  
`POST` | HTTP POST method  
##  Error Handling 
###  RequestFailed 
Exception raised when a Twilio API request fails (extends `RuntimeError`).
Attribute | Type | Description  
---|---|---  
`status_code` | `int` | HTTP status code  
`message` | `str` | Error message from Twilio  
**Example:**
    ```python
    try:
        message = client.send_sms_mms(sms)
    except RequestFailed as e:
        if e.status_code == 0:
            # Client-side validation error (e.g., phone lacks MMS capability)
            print(f"Validation error: {e.message}")
        else:
            # Twilio API error
            print(f"API error {e.status_code}: {e.message}")
    ```
##  Complete Webhook Example 
Here's a complete example of handling inbound SMS and sending replies:
    ```python
    from canvas_sdk.clients.twilio.structures import StatusInbound, TwiMlMessage
    def handle_webhook(raw_body: str) -> str:
        """
        Handle incoming SMS webhook from Twilio.
        Args:
            raw_body: URL-encoded form data from Twilio POST request
        Returns:
            TwiML XML response string
        """
        # Parse the inbound message
        inbound = StatusInbound.callback_inbound(raw_body)
        # Log the message
        print(f"From: {inbound.number_from}")
        print(f"To: {inbound.number_to}")
        print(f"Body: {inbound.body}")
        print(f"Media count: {inbound.count_media}")
        # Check for media attachments
        if inbound.count_media > 0:
            for i, url in enumerate(inbound.media_url):
                print(f"Media {i}: {inbound.media_content_type[i]} - {url}")
        # Generate appropriate response
        body_lower = inbound.body.lower()
        if "help" in body_lower:
            reply = TwiMlMessage.instance("Commands: HELP, STATUS, HELLO")
        elif "hello" in body_lower:
            reply = TwiMlMessage.instance_with_media(
                "Hello! Here's a welcome image!",
                "https://example.com/welcome.jpg"
            )
        elif "status" in body_lower:
            reply = TwiMlMessage.instance("System is operational.")
        else:
            reply = TwiMlMessage.instance("Unknown command. Text HELP for options.")
        return reply.to_xml()
    ```
##  Additional Resources 
  - [Twilio SMS API Documentation](https://www.twilio.com/docs/sms)
  - [Twilio Webhooks Guide](https://www.twilio.com/docs/messaging/guides/webhook-request)
  - [TwiML Reference](https://www.twilio.com/docs/messaging/twiml)
  - [Example Plugin](/sdk/example-twilio_sms_mms/) \- Documentation for the example plugin
  - [Source Code](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/twilio_sms_mms) \- View the source on GitHub
----- END PAGE https://docs.canvasmedical.com/sdk/clients-twilio/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/clients/
The clients module provides pre-built integrations with popular third-party services, letting your plugins send emails, SMS messages, interact with AI models, process documents, and manage cloud storage. Each client handles authentication, request formatting, and response parsing so you can focus on your plugin's logic.
All clients follow a consistent pattern: configure credentials via [plugin secrets](/sdk/secrets/), instantiate a client, and call methods. Error handling is standardized with a `RequestFailed` exception across most clients.
> **Warning:** When using third-party clients with your own API keys, you are responsible for all privacy, security, and regulatory compliance associated with those services. For certain providers such as OpenAI and Anthropic, you may contact Canvas to inquire about access through our compliant accounts. 
[ AWS S3 Upload, download, and manage files in Amazon S3. ](/sdk/clients-aws-s3/) [ Extend AI Intelligent document processing with extraction, classification, and splitting. ](/sdk/clients-extend-ai/) [ LLMs Unified interface for OpenAI, Anthropic, and Google AI models. ](/sdk/clients-llms/) [ SendGrid Send emails, manage webhooks, and track delivery with SendGrid. ](/sdk/clients-sendgrid/) [ Twilio Send SMS/MMS messages and manage phone numbers with Twilio. ](/sdk/clients-twilio/)
----- END PAGE https://docs.canvasmedical.com/sdk/clients/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/commands-custom-command/
##  Introduction 
The `CustomCommand` class allows plugins to create custom commands with HTML-rendered content that can be inserted into patient charts. Custom commands are designed for displaying read-only content and do not support user input or interactive forms.
**Important** : Custom commands must be configured in the plugin's `CANVAS_MANIFEST.json` file under the `commands` array before they can be used.
##  Parameters 
Name | Type | Required | Description  
---|---|---|---  
`note_uuid` | _string_ | `true` | The externally exposable id of the note in which to insert the command.  
`command_uuid` | _string_ | `true` | The externally exposable id of the command which is being referenced.  
`schema_key` | _string_ | `true` | Unique identifier for data binding. Must match the `schema_key` in your manifest configuration.  
`content` | _string_ | `true` | HTML content for display in the chart.  
`print_content` | _string_ | `false` | HTML content for print version (recommended for optimal print output).  
##  Manifest Configuration 
Custom commands must be declared in your `CANVAS_MANIFEST.json`:
    ```json
    {
      "components": {
        "commands": [
          {
            "name": "RiskAssessment",
            "label": "Risk Assessment",
            "schema_key": "riskAssessment",
            "section": "assessment"
          }
        ]
      }
    }
    ```
###  Manifest Fields 
  - **name** : Unique name for the command
  - **label** : User-friendly label displayed in Canvas UI
  - **schema_key** : Unique identifier for the command. CustomCommand instances must use this value.
  - **section** : Chart section where command appears: `subjective`, `objective`, `assessment`, `plan`, `procedures`, `history`, or `internal`
##  Basic Usage 
###  Step 1: Create HTML Templates 
Create a template file for your command content (e.g., `templates/risk_assessment.html`):
    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            .risk-assessment {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                padding: 16px;
            }
            .risk-header {
                font-size: 18px;
                font-weight: 600;
                margin-bottom: 16px;
            }
            .risk-item {
                padding: 8px;
                margin-bottom: 8px;
                background: #f7fafc;
                border-radius: 4px;
            }
            .risk-level {
                font-weight: 600;
                color: #c53030;
            }
        </style>
    </head>
    <body>
        <div class="risk-assessment">
            <div class="risk-header">Risk Assessment</div>
            <div class="risk-item">
                <span class="risk-level">Cardiovascular Risk: High</span>
                <p>Hypertension, family history of heart disease</p>
            </div>
            <div class="risk-item">
                <span class="risk-level">Falls Risk: Moderate</span>
                <p>Age over 65, history of dizziness</p>
            </div>
        </div>
    </body>
    </html>
    ```
Create a simpler print version (e.g., `templates/risk_assessment_print.html`):
    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            .risk-assessment-print {
                font-family: Arial, sans-serif;
                font-size: 11px;
                .section {
                    margin-bottom: 8px;
                }
                .label {
                    font-weight: bold;
                }
            }
        </style>
    </head>
    <body class="risk-assessment-print">
        <h3>Risk Assessment</h3>
        <div class="section">
            <span class="label">Cardiovascular Risk:</span> High - Hypertension, family history
        </div>
        <div class="section">
            <span class="label">Falls Risk:</span> Moderate - Age over 65, history of dizziness
        </div>
    </body>
    </html>
    ```
###  Step 2: Use Templates in Your Command 
    ```python
    from canvas_sdk.commands.commands.custom_command import CustomCommand
    from canvas_sdk.templates import render_to_string
    import uuid
    command = CustomCommand(
        schema_key="riskAssessment",
        content=render_to_string("templates/risk_assessment.html"),
        print_content=render_to_string("templates/risk_assessment_print.html")
    )
    command.command_uuid = str(uuid.uuid4())
    command.note_uuid = "rk786p"
    effect = command.originate()
    ```
###  Extended CustomCommand Class (For Reusability) 
Create a subclass with a predefined `schema_key`:
    ```python
    from canvas_sdk.commands.commands.custom_command import CustomCommand
    from canvas_sdk.templates import render_to_string
    import uuid
    class RiskAssessmentCommand(CustomCommand):
        """Custom command for risk assessment."""
        class Meta:
            schema_key = "riskAssessment"
    # Usage
    command = RiskAssessmentCommand(
        content=render_to_string("templates/risk_assessment.html"),
        print_content=render_to_string("templates/risk_assessment_print.html")
    )
    command.command_uuid = str(uuid.uuid4())
    command.note_uuid = "rk786p"
    effect = command.originate()
    ```
##  Methods 
###  originate() 
Returns an Effect that originates a new command in the note body.
**Example:**
    ```python
    from canvas_sdk.commands.commands.custom_command import CustomCommand
    from canvas_sdk.templates import render_to_string
    import uuid
    command = CustomCommand(
        schema_key="riskAssessment",
        content=render_to_string("templates/risk_assessment.html"),
        print_content=render_to_string("templates/risk_assessment_print.html")
    )
    command.command_uuid = str(uuid.uuid4())
    command.note_uuid = "rk786p"
    effect = command.originate()
    ```
##  Content vs Print Content 
Custom commands support two versions of content:
###  Display Content (content) 
  - Rendered in the Canvas UI when viewing the chart
  - Can include rich styling and complex layouts
###  Print Content (print_content) 
  - Rendered when printing the chart or generating PDFs
  - Should be simpler and more compact
**Best Practice** : Always provide both versions for the best user experience.
##  Limitations 
  - Custom commands are read-only and cannot capture user input
  - Interactive elements (forms, buttons, input fields) are not supported
  - Commands must be configured in the manifest before use
  - The `schema_key` must be unique across your plugin's commands
----- END PAGE https://docs.canvasmedical.com/sdk/commands-custom-command/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/commands/
The commands module lets you create and update commands within a specific note in Canvas. Commands are the building blocks of many end-user workflows in Canvas, including nearly all clinical workflows for documentation, like HPIs and questionnaires, as well as orders like prescriptions, labs, and referrals. Each Command class can be instantiated in your plugin and used to build a new command instance within a specific note or update an existing instance. The commands are then displayed in real time within the end user's workflow.
Common objectives that can be met by using Command classes include dynamic note templates, clinical decision support, order set composition, care gap closure, and care coordination automation.
##  Common Attributes 
###  Parameters 
All commands share the following init kwarg parameters:
Name | Type | Required | Description  
---|---|---|---  
`note_uuid` | _string_ | `true` if creating a new command | The externally exposable id of the note in which to insert the command.  
`command_uuid` | _string_ | `true` if updating an existing command | The externally exposable id of the command which is being referenced.  
All parameters can be set upon initialization, and also updated on the class instance.
###  Methods 
All commands have the following methods:
####  originate 
Returns an Effect that originates a new command in the note body.
**See also:** For efficiently inserting multiple commands at once, see [Batch Originate Commands](/sdk/effect-batch-originate/).
**Example** :
    ```python
    from canvas_sdk.commands import PlanCommand
    def compute():
        new_plan = PlanCommand(note_uuid='rk786p', narrative='new')
        new_plan.narrative = 'newer'
        return [new_plan.originate()]
    ```
####  edit 
Returns an Effect that edits an existing command with the values set on the command class instance.
**Behavior and Considerations:**
  - **Partial Edits:** If you update only some fields of the command, any fields not explicitly modified will retain their existing values.
  - **No Changes:** Calling `edit()` without making any changes will result in a no-op; the command remains unchanged.
  - **Invalid Values:** If you attempt to set an invalid value, you should receive a validation error.
**Example** :
    ```python
    from canvas_sdk.commands import PlanCommand
    def compute():
        existing_plan = PlanCommand(command_uuid='63hdik', narrative='something new')
        return [existing_plan.edit()]
    ```
####  delete 
Returns an Effect that deletes an existing, non-committed command from the note body.
**Example** :
    ```python
    from canvas_sdk.commands import PlanCommand
    def compute():
        existing_plan = PlanCommand(command_uuid='63hdik')
        return [existing_plan.delete()]
    ```
####  commit 
Returns an Effect that commits an existing, non-committed command to the note body.
**Example** :
    ```python
    from canvas_sdk.commands import PlanCommand
    def compute():
        existing_plan = PlanCommand(command_uuid='63hdik')
        return [existing_plan.commit()]
    ```
####  review 
Returns an Effect that sets a command in review.
**Limited availability** The `review()` method can only be called on Prescribe commands objects. Other command types do not support this operation.
**Example** :
    ```python
    from canvas_sdk.commands import PrescribeCommand
    def compute():
        existing_prescribe = PrescribeCommand(command_uuid='e32b85d9-ccb7-4e4f-a0e5-8783ed2d9528')
        return [existing_prescribe.review()]
    ```
####  send 
Returns an Effect that sends a signed command.
**Limited availability** The `send()` method can only be called on LabOrder and Prescribe command objects. Other command types do not support this operation.
**Example** :
    ```python
    from canvas_sdk.commands import PrescribeCommand
    def compute():
        existing_prescribe = PrescribeCommand(command_uuid='e32b85d9-ccb7-4e4f-a0e5-8783ed2d9528')
        return [existing_prescribe.send()]
    ```
####  enter_in_error 
Returns an effect that enter-in-errors an existing, committed command in the note body.
**Example** :
    ```python
    from canvas_sdk.commands import PlanCommand
    def compute():
        existing_plan = PlanCommand(command_uuid='63hdik')
        return [existing_plan.enter_in_error()]
    ```
##  Command Constants 
The `canvas_sdk.commands.constants` module provides essential classes and enumerations used across various Canvas SDK command implementations. These constants ensure consistency and provide structured data types for common medical and administrative elements.
###  ClinicalQuantity 
`ClinicalQuantity` represents detailed information about the form or unit of medication, particularly for prescription-related commands.
Field Name | Type | Description  
---|---|---  
`representative_ndc` | _string_ | National Drug Code (NDC) representing the medication.  
`ncpdp_quantity_qualifier_code` | _string_ | NCPDP code indicating the quantity qualifier.  
**Usage Example** :
    ```python
    from canvas_sdk.commands import PrescribeCommand
    from canvas_sdk.commands.constants import ClinicalQuantity
    # Using ClinicalQuantity in a prescription
    clinical_quantity = ClinicalQuantity(
        representative_ndc="12843016128",
        ncpdp_quantity_qualifier_code="C48542"
    )
    prescribe = PrescribeCommand(
        note_uuid="rk786p",
        fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=clinical_quantity,
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED
    )
    ```
###  ServiceProvider 
`ServiceProvider` represents detailed information about healthcare service providers, used in referral and imaging order commands.
Field Name | Type | Description  
---|---|---  
`first_name` | _string_ | Service provider's first name (max length 512)  
`last_name` | _string_ | Service provider's last name (max length 512)  
`specialty` | _string_ | Provider's specialty (max length 512)  
`practice_name` | _string_ | Name of the practice (max length 512)  
`business_fax` | _Optional[string]_ | Business fax number (optional, max length 512)  
`business_phone` | _Optional[string]_ | Business phone number (optional, max length 512)  
`business_address` | _Optional[string]_ | Business address (optional, max length 512)  
`notes` | _Optional[string]_ | Additional notes (optional, max length 512)  
**Usage Example** :
    ```python
    from canvas_sdk.commands import ReferCommand
    from canvas_sdk.commands.constants import ServiceProvider
    # Creating a referral with service provider information
    service_provider = ServiceProvider(
        first_name="John",
        last_name="Smith",
        specialty="Cardiology",
        practice_name="Heart Health Center",
        business_phone="555-0123",
        business_address="123 Medical Plaza, Suite 100"
    )
    refer = ReferCommand(
        note_uuid="rk786p",
        diagnosis_codes=["E119"],
        priority=ReferCommand.Priority.ROUTINE,
        clinical_question=ReferCommand.ClinicalQuestion.DIAGNOSTIC_UNCERTAINTY,
        notes_to_specialist="Patient needs cardiac evaluation",
        service_provider=service_provider
    )
    ```
###  CodeSystems 
`CodeSystems` provides standardized medical coding system identifiers used throughout Canvas for consistent medical code classification.
**Available Code Systems** :
Code System | Description  
---|---  
`ICD10` | International Classification of Diseases, 10th Revision  
`SNOMED` | Systematized Nomenclature of Medicine Clinical Terms  
`RXNORM` | RxNorm - standardized nomenclature for medications  
`UNSTRUCTURED` | Canvas-specific system for unstructured or custom codes  
**Usage Example** :
    ```python
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using different code systems
    icd10_coding = Coding(
        system=CodeSystems.ICD10, 
        code="E11.9", 
        display="Type 2 diabetes mellitus without complications"
    )
    snomed_coding = Coding(
        system=CodeSystems.SNOMED, 
        code="65921008", 
        display="Drink plenty of fluids"
    )
    unstructured_coding = Coding(
        system=CodeSystems.UNSTRUCTURED, 
        code="Custom instruction text"
    )
    ```
###  Coding 
`Coding` represents a coded value from a medical terminology system, providing structured representation of medical concepts.
Field Name | Type | Description  
---|---|---  
`system` | _string_ | The coding system identifier (e.g., ICD-10, SNOMED)  
`code` | _string_ | The specific code within the system  
`display` | _Optional[string]_ | Human-readable description of the code  
**Usage Example** :
    ```python
    from canvas_sdk.commands import InstructCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using structured coding with SNOMED
    instruct_snomed = InstructCommand(
        note_uuid="rk786p",
        coding=Coding(
            system=CodeSystems.SNOMED,
            code="65921008",
            display="Drink plenty of fluids"
        ),
        comment="To address mild dehydration symptoms"
    )
    # Using unstructured coding for custom instructions
    instruct_custom = InstructCommand(
        note_uuid="rk786p",
        coding=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Physical medicine neuromuscular training"
        )
    )
    ```
##  Command Actions 
All commands support user-triggered actions through the Canvas UI. These actions appear as buttons or menu items that users can click to perform specific operations on commands.
Commands have two types of actions:
  - **Generic actions** (available on all commands): print, audit history
  - **Command-specific actions** (vary by command type): documented in each command's respective section below
###  Customizing Action Availability 
Developers can programmatically control command actions by:
  - **Hiding actions** based on user permissions, roles, or command state
  - **Reordering actions** to prioritize commonly used operations
  - **Conditional display** depending on workflow requirements or business logic
Action customization is handled through plugin code that modifies the available action set accordingly.
###  Generic Actions 
The following actions are available on all command types:
####  print 
Generates a printable version of the command for documentation or external sharing purposes.
####  audit_history 
Displays the complete audit trail for the command, showing all modifications, state changes, and user interactions over time.
####  carry_forward 
Populates the command with the last known data for this command type and patient, allowing users to quickly recreate similar commands based on previous entries.
###  Command-Specific Actions 
Individual command types have additional actions tailored to their functionality. These actions are documented in each command's respective section below.
> **Info:** The send action is the only command action available through the SDK and is limited to LabOrder and Prescribe commands only. 
###  Example 
    ```python
    import json
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.v1.data import Staff
    class Handler(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__AVAILABLE_ACTIONS)
        def compute(self) -> list[Effect]:
            actions = self.context["actions"]
            user_id = self.context["user"]["staff"]
            # Filter actions based on user permissions
            try:
                staff = Staff.objects.get(id=user_id)
                # Example: Hide print action for specific user
                if staff.first_name == "Larry":
                    filtered_actions = [
                        action for action in actions
                        if action["name"] != "print"
                    ]
                else:
                    filtered_actions = actions
            except Staff.DoesNotExist:
                # If staff not found, return original actions
                filtered_actions = actions
            return [Effect(
                type=EffectType.COMMAND_AVAILABLE_ACTIONS_RESULTS,
                payload=json.dumps(filtered_actions)
            )]
    ```
##  Chaining Methods with a User-set UUID 
A common use case is to originate and also commit a command in a single plugin action. However, attempting to commit a command without a `command_uuid` will throw an error. Because the `originate` method executes asynchronously, there is not currently a clean way to get the `command_uuid` back from the originate action and use it for the commit action in the same operation.
The solution is to set the UUID in the plugin – using a valid Version 4 UUID – and pass it through to both the originate and commit actions. This is accomplished by manually setting the `command_uuid` before calling the methods:
    ```python
    from uuid import uuid4
    from canvas_sdk.commands import DiagnoseCommand
    def compute():
        note_uuid = '550e8400-e29b-41d4-a716-446655440000'
        diagnose_command = DiagnoseCommand(
            note_uuid=note_uuid,
            icd10_code='E11.9'
        )
        # To chain command effects, you must know what the command's id
        # is. To accomplish that, we set the id ourselves rather than
        # allow the database to assign one.
        diagnose_command.command_uuid = str(uuid4())
        # Now we can both originate and commit in a single operation
        return [diagnose_command.originate(), diagnose_command.commit()]
    ```
This pattern ensures that both the originate and commit operations use the same `command_uuid`, allowing them to be chained together reliably in a single plugin execution.
Command-specific details for each command class can be found below.
##  Custom Commands 
For creating custom commands with HTML-rendered content that can be inserted into patient charts, see the [CustomCommand](/sdk/commands-custom-command/) documentation.
Custom commands are different from standard commands:
  - They allow you to display read-only HTML content in the patient chart
  - They must be configured in your plugin's manifest before use
  - They support both display and print versions of content
  - They are designed for displaying formatted data, not for capturing user input
Learn more: [CustomCommand Reference](/sdk/commands-custom-command/)
* * *
##  AdjustPrescription 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`new_fdb_code` | _string_ | `true` | The [FDB code](/sdk/utils/#fdb_code) of the new medication.  
Check the Prescribe command for the other parameters used in the Adjust Prescription command.
    ```python
    from canvas_sdk.commands import AdjustPrescriptionCommand, PrescribeCommand
    from canvas_sdk.commands.constants import ClinicalQuantity
    AdjustPrescriptionCommand(
        fdb_code="172480",
        new_fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id="provider_456",
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
    ```
* * *
##  Allergy 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`allergy` | _Allergen_ | `false` | Represents the allergen. See details in the Allergen type below.  
`severity` | _Severity enum_ | `false` | The severity of the allergic reaction. Must be one of `AllergyCommand.Severity`.  
`narrative` | _string_ | `false` | A narrative or free-text description of the allergy.  
`approximate_date` | _datetime_ | `false` | The approximate date the allergy was identified.  
**Enums and Types** :
**`Allergen`**
Attribute | Type | Description  
---|---|---  
`concept_id` | _integer_ | The identifier for the allergen concept.  
`concept_type` | _AllergenType enum_ | The type of allergen. See `AllergenType` values below.  
AllergenType | Description  
---|---  
`ALLERGEN_GROUP` | Represents a group of allergens.  
`MEDICATION` | Represents a medication allergen.  
`INGREDIENT` | Represents an ingredient allergen.  
Severity | Description  
---|---  
`MILD` | Indicates a mild reaction.  
`MODERATE` | Indicates a moderate reaction.  
`SEVERE` | Indicates a severe reaction.  
**Example** :
    ```python
    from canvas_sdk.commands.commands.allergy import AllergyCommand, AllergenType, Allergen
    from datetime import date
    allergy = AllergyCommand(
        note_uuid="rk786p",
        allergy=Allergen(concept_id=12345, concept_type=AllergenType.MEDICATION),
        severity=AllergyCommand.Severity.SEVERE,
        narrative="Severe rash and difficulty breathing after penicillin.",
        approximate_date=date(2023, 6, 15)
    )
    ```
* * *
##  Assess 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`condition_id` | _string_ | `true` | The externally exposable id of the condition being assessed.  
`background` | _string_ | `false` | Background information about the diagnosis.  
`status` | _Status enum_ | `false` | The current status of the diagnosis. Must be one of `AssessCommand.Status`  
`narrative` | _string_ | `false` | The narrative for the current assessment.  
`Status` | Value  
---|---  
IMPROVED | "improved"  
STABLE | "stable"  
DETERIORATED | "deteriorated"  
**Example** :
    ```python
    from canvas_sdk.commands import AssessCommand
    assess = AssessCommand(
        note_uuid='rk786p',
        condition_id='hu38rlo',
        background='started in 2012',
        status=AssessCommand.Status.STABLE,
        narrative='experiencing more pain lately'
    )
    ```
* * *
##  ChangeMedication 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`medication_id` | _string_ | `true` | Externally exposable id of the patient's medication being changed.  
`sig` | _string_ | `false` | Administration details of the medication.  
**Example** :
    ```python
    from canvas_sdk.commands.commands.change_medication import ChangeMedicationCommand
    change_medication = ChangeMedicationCommand(
        note_uuid='rk786p',
        medication_id='2u309j',
        sig='two pills taken orally'
    )
    ```
* * *
##  CloseGoal 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`goal_id` | _int_ | `true` | The externally exposable ID of the goal being closed.  
`achievement_status` | _AchievementStatus enum_ | `false` | The final achievement status of the goal. Must be one of `GoalCommand.AchievementStatus`.  
`progress` | _string_ | `false` | A narrative about the patient's progress toward the goal.  
**Example** :
    ```python
    from canvas_sdk.commands import CloseGoalCommand, GoalCommand
    close_goal = CloseGoalCommand(
        note_uuid="rk786p",
        goal_id=12345,
        achievement_status=GoalCommand.AchievementStatus.ACHIEVED,
        progress="Patient has achieved the target weight goal of 150 lbs."
    )
    ```
##  Diagnose 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`icd10_code` | _string_ | `true` | ICD-10 code of the condition being diagnosed.  
`background` | _string_ | `false` | Background information about the diagnosis.  
`approximate_date_of_onset` | _datetime_ | `false` | The approximate date the condition began.  
`today_assessment` | _string_ | `false` | The narrative for the initial assessment of the condition.  
**Example** :
    ```python
    from canvas_sdk.commands import DiagnoseCommand
    from datetime import datetime
    diagnose = DiagnoseCommand(
        note_uuid='rk786p',
        icd10_code='M54.50',
        background='lifted heavy box',
        approximate_date_of_onset=datetime(2012, 1, 1),
        today_assessment='unable to sleep lately'
    )
    ```
* * *
##  FamilyHistory 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`family_history` | _string_ or _Coding_ | `true` | A description of the family history being documented.  
`relative` | _string_ | `false` | A description of the relative (e.g., mother, uncle).  
`note` | _string_ | `false` | Additional notes or context about the family history.  
**Coding Support** :
The `family_history` parameter accepts either:
  - **String** : Searches for matching family history condition
  - **Coding object** : Allows structured or unstructured coding 
    - Supported systems: `SNOMED`, `UNSTRUCTURED`
    - Required fields: `system`, `code`
    - Optional field: `display`
**Example** :
    ```python
    from canvas_sdk.commands import FamilyHistoryCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using a string (searches for matching conditions)
    family_history = FamilyHistoryCommand(
        note_uuid="rk786p",
        family_history="Diabetes Type 2",
        relative="Mother",
        note="Diagnosed at age 45"
    )
    # Using a SNOMED code
    family_history_snomed = FamilyHistoryCommand(
        note_uuid="rk786p",
        family_history=Coding(
            system=CodeSystems.SNOMED,
            code="44054006",
            display="Diabetes Type 2"
        ),
        relative="Mother",
        note="Diagnosed at age 45"
    )
    # Using unstructured (free text)
    family_history_unstructured = FamilyHistoryCommand(
        note_uuid="rk786p",
        family_history=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Family history of heart disease"
        ),
        relative="Father"
    )
    ```
* * *
##  FollowUp 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`structured` | _boolean_ | `false` | Whether the RFV is structured or not. Defaults to False.  
`requested_date` | _date_ | `false` | The desired follow up date.  
`note_type_id` | _UUID (str)_ | `false` | The desired type of appointment.  
`coding` | _Coding_ or _UUID (str)_ | `true` if structured=True | The coding for the structured RFV. Either a full Coding object (with `code`, `system`, `display`) or a UUID string referencing a verified coding record. If a Coding is provided, it is validated against existing records  
`comment` | _string_ | `false` | Additional commentary on the RFV.  
**Example** :
    ```python
    from canvas_sdk.commands import FollowUpCommand
    from datetime import date
    structured = FollowUpCommand(
      note_uuid='rk786p',
      structured=True,
      requested_date=date(2025, 3, 2),
      note_type_id="kz986a",
      coding={'code': '', 'system': '', 'display': ''},
      comment='also wants to discuss treatment options'
    )
    # Example with a UUID string referencing a Coding record
    structured2 = FollowUpCommand(
      note_uuid='rk786p',
      structured=True,
      requested_date=date(2025, 3, 2),
      note_type_id="kz986a",
      coding="e2b1e1e3-3f52-4a0a-bb3a-123456789abc",  # Must correspond to an existing coding record
      comment="Discuss treatment options"
    )
    unstructured = FollowUpCommand(
      note_uuid='rk786p',
      requested_date=date(2025, 3, 2),
      note_type_id="kz986a",
      comment='also wants to discuss treatment options'
    )
    ```
* * *
##  Goal 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`goal_statement` | _string_ | `true` | Description of the goal.  
`start_date` | _datetime_ | `false` | The date the goal begins.  
`due_date` | _datetime_ | `false` | The date the goal is due.  
`achievement_status` | _AchievementStatus enum_ | `false` | The current achievement status of the goal.  
`priority` | _Priority enum_ | `false` | The priority of the goal.  
`progress` | _string_ | `false` | A narrative about the patient's progress toward the goal.  
`AchievementStatus` | Value  
---|---  
IN_PROGRESS | "in-progress"  
IMPROVING | "improving"  
WORSENING | "worsening"  
NO_CHANGE | "no-change"  
ACHIEVED | "achieved"  
SUSTAINING | "sustaining"  
NOT_ACHIEVED | "not-achieved"  
NO_PROGRESS | "no-progress"  
NOT_ATTAINABLE | "not-attainable"  
`Priority` | Value  
---|---  
HIGH | "high-priority"  
MEDIUM | "medium-priority"  
LOW | "low-priority"  
**Example** :
    ```python
    from canvas_sdk.commands import GoalCommand
    from datetime import datetime
    goal = GoalCommand(
        note_uuid='rk786p',
        goal_statement='Eat more healthy vegetables.',
        start_date=datetime(2024, 1, 1),
        due_date=datetime(2024, 12, 31),
        achievement_status=GoalCommand.AchievementStatus.IN_PROGRESS,
        priority=GoalCommand.Priority.HIGH,
        progress='patient is frequenting local farmers market to find healthy options'
    )
    ```
* * *
##  HistoryOfPresentIllness 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`narrative` | _string_ | `true` | The narrative of the patient's history of present illness.  
**Example** :
    ```python
    from canvas_sdk.commands import HistoryOfPresentIllnessCommand
    hpi = HistoryOfPresentIllnessCommand(
            note_uuid='rk786p',
            narrative='presents with chronic back pain and headaches'
        )
    ```
* * *
##  ImagingOrder 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`image_code` | _string_ | `true` | Code identifier of the imaging order.  
`diagnosis_codes` | _list[string]_ | `true` | ICD-10 Diagnosis codes justifying the imaging order.  
`priority` | _Priority enum_ | `false` | Priority of the imaging order. Must be one of `ImagingOrderCommand.Priority`.  
`additional_details` | _string_ | `false` | Additional details or instructions related to the imaging order.  
`service_provider` | _ServiceProvider_ | `true` | Service provider of the imaging order.  
`comment` | _string_ | `false` | Additional comments.  
`ordering_provider_key` | _string_ | `true` | The key for the provider ordering the imaging.  
`linked_items_urns` | _list[string]_ | `false` | List of URNs for items linked to the imaging order command.  
**Command-specific actions** :
Action Name | Available When | Description  
---|---|---  
`delegate_action` | command is staged | Delegates the order by creating a task.  
`sign_action` | command is staged | Signs the order, transitioning it from staged to committed state.  
`print_specialist` | command is committed | Prints the order using a specialist-focused template.  
`print_patient` | command is committed | Prints the order using a patient-friendly template.  
`fax` | command is committed | Transmits the order electronically via fax.  
**Enums and Types** :
**`Priority`**
Priority | Description  
---|---  
`ROUTINE` | Indicates a routine order.  
`URGENT` | Indicates un urgent order.  
**Example** :
    ```python
    from canvas_sdk.commands import ImagingOrderCommand
    from canvas_sdk.commands.constants import ServiceProvider
    imaging_order = ImagingOrderCommand(
        note_uuid="rk786p",
        image_code="G0204",
        diagnosis_codes=["E119"],
        priority=ImagingOrderCommand.Priority.ROUTINE,
        comment="this is a comment",
        additional_details="more details",
        ordering_provider_key="pk3920p",
        service_provider=ServiceProvider(
          first_name="Clinic",
          last_name="Imaging",
          practice_name="Clinic Imaging",
          specialty="radiology",
          business_address="Street Address",
          business_phone="1234569874",
          business_fax="1234569874"
     ),
    )
    ```
* * *
##  ImagingReview 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`report_ids` | _list[string]_ | `true` | List of imaging report IDs to review.  
`message_to_patient` | _string_ | `false` | Message to communicate findings to the patient.  
`communication_method` | _ReportReviewCommunicationMethod enum_ | `false` | Method for patient communication. Must be one of `ReportReviewCommunicationMethod`.  
`linked_items_urns` | _list[string]_ | `false` | List of URNs for items linked to the review.  
`comment` | _string_ | `false` | Internal comment about the review.  
**Enums and Types** :
**`ReportReviewCommunicationMethod`**
Communication Method | Value | Description  
---|---|---  
`DELEGATED_CALL_CAN_LEAVE_MESSAGE` | `"DM"` | Delegated call - can leave message  
`DELEGATED_CALL_NEED_ANSWER` | `"DA"` | Delegated call - need answer  
`DELEGATED_LETTER` | `"DL"` | Delegated letter to be sent to patient  
`ALREADY_LEFT_MESSAGE` | `"AM"` | Already left message for patient  
`ALREADY_REVIEWED_WITH_PATIENT` | `"AR"` | Already reviewed with patient  
**Example** :
    ```python
    from canvas_sdk.commands import ImagingReviewCommand
    from canvas_sdk.commands.commands.review import ReportReviewCommunicationMethod
    from canvas_sdk.v1.data import ImagingReport, Patient
    patient = Patient.objects.get(id="patient-id")
    # Get imaging reports to review
    imaging_reports = ImagingReport.objects.filter(patient=patient, review__isnull=True)
    report_ids = [str(report.id) for report in imaging_reports]
    imaging_review = ImagingReviewCommand(
        note_uuid="a1b2c3d4-e5f6-4a5b-8c9d-0e1f2a3b4c5d",
        report_ids=report_ids,
        message_to_patient="Your imaging results show no abnormalities.",
        communication_method=ReportReviewCommunicationMethod.DELEGATED_CALL_CAN_LEAVE_MESSAGE,
        comment="All clear, no follow-up needed."
    )
    ```
* * *
##  ImmunizationStatement 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`cpt_code` | _string_ or _Coding_ | `false`* | The CPT code for the immunization procedure. Used with CVX code to search against ontologies server for validation.  
`cvx_code` | _string_ or _Coding_ | `false`* | The CVX code for the vaccine administered. Used with CPT code to search against ontologies server for validation.  
`unstructured` | _Coding_ | `false`* | Free-text immunization description.  
`approximate_date` | _date_ | `false` | The approximate date when the immunization was administered.  
`comments` | _string_ | `false` | Additional comments about the immunization (max 255 characters).  
*Must provide either both `cpt_code` and `cvx_code` together, or `unstructured` alone (cannot mix structured and unstructured).
**Coding Support** :
The `cpt_code` and `cvx_code` parameters accept either:
  - **String** : Looks up the code in the respective system (CPT or CVX)
  - **Coding object** : Allows structured coding 
    - `cpt_code` must use system: `CPT`
    - `cvx_code` must use system: `CVX`
    - Required fields: `system`, `code`
    - Optional field: `display`
The `unstructured` parameter:
  - **Coding object** : For free-text immunizations 
    - Required system: `UNSTRUCTURED`
    - Required fields: `system`, `code`
    - Optional field: `display`
**Examples** :
    ```python
    from canvas_sdk.commands.commands.immunization_statement import ImmunizationStatementCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    from datetime import date
    immunization_statement = ImmunizationStatementCommand(
        cpt_code="90724",
        cvx_code="88",
        approximate_date=date(2024, 1, 15),
        comments="Patient received influenza vaccine"
    )
    # Using Coding objects for structured codes
    immunization_statement_coded = ImmunizationStatementCommand(
        cpt_code=Coding(
            system=CodeSystems.CPT,
            code="90724"
        ),
        cvx_code=Coding(
            system=CodeSystems.CVX,
            code="88"
        ),
        approximate_date=date(2024, 1, 15),
        comments="Patient received influenza vaccine"
    )
    # Using unstructured (free text immunization)
    immunization_statement_unstructured = ImmunizationStatementCommand(
        unstructured=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="COVID-19 booster at pharmacy"
        ),
        approximate_date=date(2024, 1, 15)
    )
    ```
* * *
##  Instruct 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`coding` | **Coding** | `true` | The SNOMED code or UNSTRUCTURED code that represents the instruction.  
`comment` | _string_ | `false` | Additional comments related to the instruction.  
**Example** :
    ```python
    from canvas_sdk.commands import InstructCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # SNOMED code
    InstructCommand(
        note_uuid='rk786p',
        coding=Coding(system=CodeSystems.SNOMED, code="65921008"),
        comment="To address mild dehydration symptoms"
    )
    # UNSTRUCTURED code
    InstructCommand(
        note_uuid='rk786p',
        coding=Coding(system=CodeSystems.UNSTRUCTURED, code="Physical medicine neuromuscular training"),
    )
    ```
* * *
##  LabOrder 
The `LabOrderCommand` is used to initiate a lab order through the Canvas system. This command requires detailed information about the lab partner, the tests being ordered, and the provider placing the order. Built-in validations ensure that:
  - The specified lab partner exists (whether provided by name or ID).
  - The ordered tests are available for the chosen lab partner.
**Electronic ordering:** LabOrder commands support the `send()` method for electronic ordering of signed orders directly to lab partners. However, electronic ordering has additional requirements:
  - Only lab partners with electronic ordering enabled support the `send()` method.
  - The command must be committed/signed before it can be sent electronically.
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`lab_partner` | _string_ | `true` | The lab partner processing the order. Accepts either the lab partner's name or its unique identifier (ID).  
`tests_order_codes` | _list[string]_ | `true` | A list of codes or IDs for the tests being ordered. The system verifies that each provided value corresponds to an available test for the specified lab partner.  
`ordering_provider_key` | _string_ | `false` | The key for the provider ordering the tests.  
`diagnosis_codes` | _list[string]_ | `false` | ICD-10 Diagnosis codes justifying the lab order.  
`fasting_required` | _boolean_ | `false` | Indicates if fasting is required for the tests.  
`comment` | _string_ | `false` | Additional comments related to the lab order.  
**Command-specific actions** :
Action Name | Available When | Description  
---|---|---  
`sign_send_action` | command is staged | Signs and immediately sends the order electronically to the lab partner.  
`send_action` | command is staged | Sends the order electronically to the chosen lab partner.  
`sign_action` | command is staged | Signs the order, transitioning it from staged to committed state.  
`print_requisition_form` | command is committed | Prints the order using a requisition-focused template for lab submission.  
`print_specimen_label` | command is committed | Prints the template using a specimen-focused template.  
`fax_requisition_form` | command is committed | Transmits the order electronically via fax.  
**ABN Workflow Actions**
When the ABN (Advance Beneficiary Notice) workflow is enabled, additional actions become available:
Action Name | Available When | Description  
---|---|---  
`send_abn_signed` | command is staged | Sends the order electronically after ABN requirements are met.  
`make_changes` | command is staged | Allows modifications to complete ABN requirements before sending.  
###  Validations 
  - **Lab Partner Validation:** The system checks that the provided `lab_partner` (by name or ID) exists in the system. If no matching lab partner is found, a validation error is raised.
  - **Tests Order Codes Validation:** Each test code or ID in `tests_order_codes` is verified against the tests available for the specified lab partner. If one or more tests cannot be found, the error will indicate which codes or IDs are missing.
**Example** :
    ```python
    from canvas_sdk.commands import LabOrderCommand
    from canvas_sdk.v1.data.lab import LabPartner, LabPartnerTest
    partner = LabPartner.objects.first()
    tests = [test.order_code for test in LabPartnerTest.objects.filter(lab_partner=partner)]
    LabOrderCommand(
      lab_partner=str(partner.id),
      tests_order_codes=tests,
      ordering_provider_key="provider_key_123",
      diagnosis_codes=["E119"],
      fasting_required=True,
      comment="Patient should fast for 8 hours before the test."
    )
    ```
* * *
##  LabReview 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`report_ids` | _list[string]_ | `true` | List of lab report IDs to review.  
`message_to_patient` | _string_ | `false` | Message to communicate findings to the patient.  
`communication_method` | _ReportReviewCommunicationMethod enum_ | `false` | Method for patient communication. Must be one of `ReportReviewCommunicationMethod`.  
`linked_items_urns` | _list[string]_ | `false` | List of URNs for items linked to the review.  
`comment` | _string_ | `false` | Internal comment about the review.  
**Enums and Types** :
**`ReportReviewCommunicationMethod`**
Communication Method | Value | Description  
---|---|---  
`DELEGATED_CALL_CAN_LEAVE_MESSAGE` | `"DM"` | Delegated call - can leave message  
`DELEGATED_CALL_NEED_ANSWER` | `"DA"` | Delegated call - need answer  
`DELEGATED_LETTER` | `"DL"` | Delegated letter to be sent to patient  
`ALREADY_LEFT_MESSAGE` | `"AM"` | Already left message for patient  
`ALREADY_REVIEWED_WITH_PATIENT` | `"AR"` | Already reviewed with patient  
**Example** :
    ```python
    from canvas_sdk.commands import LabReviewCommand
    from canvas_sdk.commands.commands.review import ReportReviewCommunicationMethod
    from canvas_sdk.v1.data import LabReport, Patient
    patient = Patient.objects.get(id="patient-id")
    # Get lab reports to review
    lab_reports = LabReport.objects.filter(patient=patient, review__isnull=True)
    report_ids = [str(report.id) for report in lab_reports]
    lab_review = LabReviewCommand(
        note_uuid="a1b2c3d4-e5f6-4a5b-8c9d-0e1f2a3b4c5d",
        report_ids=report_ids,
        message_to_patient="Your lab results are within normal range.",
        communication_method=ReportReviewCommunicationMethod.DELEGATED_CALL_CAN_LEAVE_MESSAGE,
        comment="All values normal, no follow-up needed."
    )
    ```
* * *
##  MedicalHistory 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`past_medical_history` | _string_ | `true` | A description of the past medical condition or history.  
`approximate_start_date` | _date_ | `false` | Approximate start date of the condition.  
`approximate_end_date` | _date_ | `false` | Approximate end date of the condition.  
`show_on_condition_list` | _boolean_ | `false` | Whether the condition should appear on the condition list.  
`comments` | _string_ | `false` | Additional comments (max length: 1000 characters).  
**Example** :
    ```python
    from canvas_sdk.commands import MedicalHistoryCommand
    from datetime import date
    MedicalHistoryCommand(
        past_medical_history="Resistant Hypertension",
        approximate_start_date=date(2015, 1, 1),
        show_on_condition_list=True,
        comments="Controlled with medication."
    )
    ```
* * *
##  MedicationStatement 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`fdb_code` | _string_ or _Coding_ | `true` | The [FDB code](/sdk/utils/#fdb_code) of the medication  
`sig` | _string_ | `false` | Administration details of the medication.  
**Coding Support** :
The `fdb_code` parameter accepts either:
  - **String (FDB code)** : Looks up the medication in the FDB system
  - **Coding object** : Allows structured or unstructured coding 
    - Supported systems: `FDB`, `UNSTRUCTURED`
    - Required fields: `system`, `code`
    - Optional field: `display`
**Example** :
    ```python
    from canvas_sdk.commands import MedicationStatementCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using an FDB code string (recommended for FDB medications)
    medication_statement = MedicationStatementCommand(
        note_uuid='rk786p',
        fdb_code='198698',
        sig='two pills taken orally'
    )
    # Using an FDB Coding object
    medication_statement_fdb = MedicationStatementCommand(
        note_uuid='rk786p',
        fdb_code=Coding(
            system=CodeSystems.FDB,
            code='198698',
            display='aspirin 81 mg oral tablet'
        ),
        sig='two pills taken orally'
    )
    # Using unstructured (free text medication)
    medication_statement_unstructured = MedicationStatementCommand(
        note_uuid='rk786p',
        fdb_code=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code='Herbal supplement for joint health'
        )
    )
    ```
* * *
##  SurgicalHistory 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`past_surgical_history` | _string_ or _Coding_ | `true` | A description of the past surgical procedure.  
`approximate_date` | _date_ | `false` | Approximate date of the surgery.  
`comment` | _string_ | `false` | Additional comments (max length: 1000 characters).  
**Coding Support** :
The `past_surgical_history` parameter accepts either:
  - **String** : Searches for matching surgical procedures
  - **Coding object** : Allows structured or unstructured coding 
    - Supported systems: `SNOMED`, `UNSTRUCTURED`
    - Required fields: `system`, `code`
    - Optional field: `display`
**Example** :
    ```python
    from canvas_sdk.commands import PastSurgicalHistoryCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    from datetime import date
    # Using a string (searches for matching procedures)
    PastSurgicalHistoryCommand(
        past_surgical_history="Appendectomy",
        approximate_date=date(2008, 6, 15),
        comment="No complications reported."
    )
    # Using a SNOMED code
    surgical_history_snomed = PastSurgicalHistoryCommand(
        past_surgical_history=Coding(
            system=CodeSystems.SNOMED,
            code="80146002",
            display="Appendectomy"
        ),
        approximate_date=date(2008, 6, 15),
        comment="No complications reported."
    )
    # Using unstructured (free text)
    surgical_history_unstructured = PastSurgicalHistoryCommand(
        past_surgical_history=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Minor outpatient procedure on left knee"
        ),
        approximate_date=date(2020, 3, 10)
    )
    ```
* * *
##  Perform 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`cpt_code` | _string_ or _Coding_ | `true` | The CPT code of the procedure or action performed.  
`notes` | _string_ | `false` | Additional notes related to the performed procedure.  
**Coding Support** :
The `cpt_code` parameter accepts either:
  - **String** : Searches for matching procedures
  - **Coding object** : Allows structured or unstructured coding 
    - Supported systems: `CPT`, `UNSTRUCTURED`
    - Required fields: `system`, `code`
    - Optional field: `display`
**Example** :
    ```python
    from canvas_sdk.commands import PerformCommand
    from canvas_sdk.commands.constants import CodeSystems, Coding
    # Using a string (searches for matching procedures)
    PerformCommand(
        cpt_code="99213",
        notes="Patient presented with a common cold."
    )
    # Using a CPT code
    perform_cpt = PerformCommand(
        cpt_code=Coding(
            system=CodeSystems.CPT,
            code="99213",
            display="Office visit, established patient"
        ),
        notes="Annual wellness visit"
    )
    # Using unstructured (free text)
    perform_unstructured = PerformCommand(
        cpt_code=Coding(
            system=CodeSystems.UNSTRUCTURED,
            code="Custom procedure performed"
        ),
        notes="Non-standard procedure documentation"
    )
    ```
* * *
##  Plan 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`narrative` | _string_ | `true` | The narrative of the patient's plan.  
**Example** :
    ```python
    from canvas_sdk.commands import PlanCommand
    plan = PlanCommand(
        note_uuid='rk786p',
        narrative='will return in 2 weeks to check on pain management'
    )
    ```
* * *
##  Prescribe 
**Electronic prescribing:** Prescribe commands support the `send()` method for electronic transmission of signed prescriptions. However, electronic prescribing has additional validations:
  - A pharmacy must be specified on the command before it can be sent.
  - The command must be committed/signed before it can be sent electronically.
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`fdb_code` | _string_ | `false`* | The [FDB code](/sdk/utils/#fdb_code) of the medication.  
`compound_medication_id` | _string_ | `false`* | The ID of an existing compound medication to prescribe.  
`compound_medication_data` | `CompoundMedicationData` | `false`* | Data for creating a new compound medication inline.  
`icd10_codes` | _list[string]_ | `false` | List of ICD-10 codes (maximum 2) associated with the prescription.  
`sig` | _string_ | `true` | Administration instructions/details of the medication.  
`days_supply` | _integer_ | `false` | Number of days the prescription is intended to cover.  
`quantity_to_dispense` | _Decimal | float | integer_ | `true` | The amount of medication to dispense.  
`type_to_dispense` | _ClinicalQuantity_ | `true`** | Information about the form or unit of the medication to dispense.  
`refills` | _integer_ | `true` | Number of refills allowed for the prescription.  
`substitutions` | _Substitutions Enum_ | `true` | Specifies whether substitutions (e.g., generic drugs) are allowed.  
`pharmacy` | _string_ | `false` | The NCPDP ID of the pharmacy where the prescription should be sent.  
`prescriber_id` | _string_ | `true` | The key of the prescriber.  
`supervising_provider_id` | _string_ | `false` | The key of the supervising provider of the prescriber.  
`note_to_pharmacist` | _string_ | `false` | Additional notes or instructions for the pharmacist.  
*Must provide exactly one of: fdb_code, compound_medication_id, or compound_medication_data
**ClinicalQuantity is only required when `fdb_code` is provided. It is optional for compound medications.
**Command-specific actions** :
Action Name | Available When | Description  
---|---|---  
`sign_send_action` | command is in review | Signs and immediately sends the prescription electronically.  
`sign_action` | command is in review | Signs the prescription, transitioning it from staged to committed state.  
`print_action` | command is in review | Prints and commits the command.  
`make_changes` | command is in review | Allow users to revert the command to staged state and make changes.  
`send_action` | command is committed | Sends the prescription electronically.  
**Enums and Types**
Substitutions | Value | Description  
---|---|---  
`ALLOWED` | `"allowed"` | Generic or substitute medications are permitted.  
`NOT_ALLOWED` | `"not_allowed"` | Only the prescribed brand is allowed.  
**CompoundMedicationData** : Data for creating a compound medication inline within a prescription.
Field Name | Type | Description | Required  
---|---|---|---  
`formulation` | _string_ | The compound medication formulation (max 105 characters) | `true`  
`potency_unit_code` | _string_ | The unit of measurement for the medication | `true`  
`controlled_substance` | _string_ | The controlled substance schedule | `true`  
`controlled_substance_ndc` | _string_ | NDC for controlled substances (dashes removed) | `false`*  
`active` | _bool_ | Whether the compound medication is active (default: true) | `false`  
*Required when controlled_substance is not "N" (None)
**Examples**
**_Option 1: Standard Prescription (FDB Code)_**
    ```python
    from canvas_sdk.commands.constants import ClinicalQuantity
    from canvas_sdk.commands import PrescribeCommand
    prescription = PrescribeCommand(
        fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id='provider_456',
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
    ```
**_Option 2: Existing Compound Medication (by ID)_**
    ```python
    from canvas_sdk.commands.constants import ClinicalQuantity
    from canvas_sdk.commands import PrescribeCommand
    from canvas_sdk.v1.data.compound_medication import CompoundMedication as CompoundMedicationModel
    # Get an existing compound medication (let's assume it exists in the database)
    compound_med = CompoundMedicationModel.objects.filter(
        active=True,
        formulation="Testosterone 200mg/mL in Grapeseed Oil"
    ).first()
    prescription = PrescribeCommand(
        compound_medication_id=str(compound_med.id),
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id='provider_456',
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
    ```
**_Option 3: Create New Compound Medication Inline_**
    ```python
    from canvas_sdk.commands.constants import ClinicalQuantity
    from canvas_sdk.commands.commands.prescribe import PrescribeCommand, CompoundMedicationData
    from canvas_sdk.v1.data.compound_medication import CompoundMedication
    compound_medication_data = CompoundMedicationData(
        formulation="Testosterone 200mg/mL in Grapeseed Oil",
        potency_unit_code=CompoundMedication.PotencyUnits.GRAM,
        controlled_substance=CompoundMedication.ControlledSubstanceOptions.SCHEDULE_III,
        controlled_substance_ndc="12345678901",
        active=True,
    )
    prescription = PrescribeCommand(
        compound_medication_data=compound_medication_data,
        icd10_codes=["M79.3"],
        sig="Apply thin layer to affected area twice daily",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id='provider_456',
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
    ```
**Validation Notes**
  - Medication Type Validation: Exactly one of fdb_code, compound_medication_id, or compound_medication_data must be provided
  - Compound Medication ID: When using compound_medication_id, the system validates that the compound medication exists
  - Compound Medication Data: When using compound_medication_data: 
    - All required fields in the dataclass must be provided
    - If controlled substance is not "N" (None), then controlled_substance_ndc is required
    - The formulation is limited to 105 characters
    - Any dashes in the NDC are automatically removed
    - Before creating a new compound medication, the system checks if a compound with the same formulation and potency unit code already exists. If it does, it reuses the existing compound medication instead of creating a new one.
  - Potency Unit and Controlled Substance Values: Must use valid enum values from PotencyUnit and ControlledSubstanceSchedule
* * *
##  PhysicalExam 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`questionnaire_id` | _string_ | `true` | The externally exposable id of the questionnaire being answered by the patient.  
`result` | _string_ | `false` | A summary of the result of the patient's answers.  
###  Toggle Questions Feature 
The PhysicalExamCommand includes special functionality for toggling questions on/off. When working with a PhysicalExam Command, the following methods are available:
**Methods** :
Method | Parameters | Returns | Description  
---|---|---|---  
`is_question_enabled` | `question_id: str` or `int` | `bool` | Check if a specific question is enabled (not skipped).  
`set_question_enabled` | `question_id: str` or `int, enabled: bool` | `None` | Enable or disable a specific question.  
`question_toggles` | _property_ | `dict` | Get all current toggle states (question_id → enabled).  
**Example - Working with Existing Commands** :
A common use case is retrieving existing PhysicalExam commands from a note and modifying their toggle states. Here's how to work with the Canvas SDK data objects:
    ```python
    from canvas_sdk.commands import PhysicalExamCommand
    from canvas_sdk.v1.data import Command, Note
    from logger import log
    # Get existing physical exam commands from a note
    note = Note.objects.get(id="ff287601-fff4-46c4-b21f-04760e88adf1")
    physical_exam_commands = Command.objects.filter(
        note=note,
        schema_key="exam"  # Physical exam commands have schema_key "exam"
    ).all()
    effects = []
    for command in physical_exam_commands:
        # The command.data contains the question responses and skip states
        # Example structure of command.data:
        # {
        #     "questionnaire": {"value": "83d93454-25a9-404d-83a5-e0ed2ec3af00"},
        #     "question-12": "70",  # Body length response
        #     "question-13": None,   # Head circumference (no response)
        #     "skip-12": True,   # Body length is enabled (counterintuitive: skip=True means enabled)
        #     "skip-13": False,  # Head circumference is disabled
        # }
        # Create a PhysicalExamCommand instance from the existing command
        exam = PhysicalExamCommand(command_uuid=str(command.id))
        # The exam.questions property gives you access to all questions with their IDs
        log.info(f"Processing Physical Exam Command: {exam.command_uuid}")
        for question in exam.questions:
            # Each question object has an 'id' property with the question ID
            question_id = question.id
            if exam.is_question_enabled(question_id):
                log.info(f"Question {question_id} is enabled")
                # Check if there's a response in the command data
                question_key = f"question-{question_id}"
                if question_key in command.data:
                    response = command.data[question_key]
                    if response:
                        log.info(f"Response: {response}")
        # Example: Enable all questions that have responses, disable those without
        for question in exam.questions:
            question_id = question.id
            question_key = f"question-{question_id}"
            # Check if question has a response in command.data
            has_response = question_key in command.data and command.data[question_key]
            if has_response:
                exam.set_question_enabled(question_id, True)
            else:
                # Optionally disable questions without responses
                exam.set_question_enabled(question_id, False)
        effects.append(exam.edit())
    ```
**Example - Creating a New Physical Exam** :
    ```python
    from canvas_sdk.commands import PhysicalExamCommand
    # Create a new physical exam
    exam = PhysicalExamCommand(
      note_uuid='a229456f-c10d-4f85-a04e-e8675d4e56dd',
      questionnaire_id='83d93454-25a9-404d-83a5-e0ed2ec3af00',
    )
    questions = exam.questions  # Retrieve the list of questions
    # Returns: [
    #               Question(
    #                       self.name='question-12',
    #                       self.label='Body length (in)',
    #                       self.type='TXT',
    #                       self.options=[ResponseOption(self.dbid=38, self.name='Body length (in)', self.code='8306-3', self.value='')],
    #                       self.response=None
    #               ),
    #               Question(
    #                       self.name='question-13',
    #                       self.label='Head circumference (cm)',
    #                       self.type='TXT', self.options=[ResponseOption(self.dbid=39, self.name='Head circumference (cm)', self.code='8287-5', self.value='')],
    #                       self.response=None
    #               )
    # Check if a question is enabled
    if exam.is_question_enabled("12"):
      print("Body length question is enabled.")
    # Disable irrelevant questions
    exam.set_question_enabled("13", False)
    # Get all toggle states
    states = exam.question_toggles
    # Returns: {"12": True, "13": False, "14": True, ...}, where keys are question IDs and values are enabled states.
    # Working with existing exam - toggle states are preserved
    existing_exam = PhysicalExamCommand(command_uuid='existing-exam-uuid')
    # All previously set toggle states are automatically loaded
    ```
**Note:** The PhysicalExamCommand is a subclass of the QuestionnaireCommand, so it supports all the questionnaire features (including response recording, question mapping, etc.). For detailed information on these features, please refer to the Questionnaire Command Documentation.
* * *
##  Questionnaire 
###  Overview 
The `QuestionnaireCommand` is used to present a questionnaire to a patient and commit their responses to an interview. It requires the ID of the questionnaire
**Automatic Questionnaire ID Loading** : When instantiating a QuestionnaireCommand with an existing `command_uuid`, the questionnaire_id will be automatically loaded from the database if not explicitly provided. This means you don't need to specify the questionnaire_id when working with existing commands.
In addition to the basic parameters, this command supports a dynamic response interface. Once instantiated, you can retrieve the list of questions via the `questions` property, and then record responses for each question using the question object's `add_response()` method. Each question type enforces its expected response format:
  - **Text questions (TYPE_TEXT):** Accept a keyword argument `text` (a string).
  - **Integer questions (TYPE_INTEGER):** Accept a keyword argument `integer` (an integer or a value convertible to an integer).
  - **Radio questions (TYPE_RADIO):** Accept a keyword argument `option` (a `ResponseOption` instance); only one option may be selected.
  - **Checkbox questions (TYPE_CHECKBOX):** Accept a keyword argument `option` (a `ResponseOption` instance) along with an optional boolean `selected` (defaulting to True) and an optional string `comment`. Multiple responses can be recorded.
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`questionnaire_id` | _string_ | `true` | The externally exposable id of the questionnaire being answered by the patient.  
`result` | _string_ | `false` | A summary of the result of the patient's answers.  
**Example** :
    ```python
    from canvas_sdk.commands import QuestionnaireCommand
    questionnaire = QuestionnaireCommand(
        note_uuid='rk786p',
        questionnaire_id='g73hd9',
        result='The patient is feeling average today.'
    )
    ```
###  Usage Example 
Below is an example that demonstrates how to instantiate a `QuestionnaireCommand`, retrieve the questions, and add responses to them based on their type:
    ```python
    import uuid
    from canvas_sdk.commands.commands.questionnaire import QuestionnaireCommand
    from canvas_sdk.commands.commands.questionnaire.question import ResponseOption
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import Note, Questionnaire
    class Protocol(BaseHandler):
        def compute(self) -> list[Effect]:
          q = Questionnaire.objects.filter(name="Exercise").first()
          note = Note.objects.last()
          # Create a QuestionnaireCommand instance.
          command = QuestionnaireCommand(questionnaire_id=str(q.id))
          command.note_uuid = str(note.id)
          command.command_uuid = str(uuid.uuid4())
          # Alternatively you can just retrieve an existing questionnaire command, and only return an `edit` effect.
          # Retrieve the list of questions.
          questions = command.questions
          # Record responses for each question.
          for question in questions:
              if question.type == ResponseOption.TYPE_TEXT:
                  # For text questions, pass a 'text' keyword argument.
                  question.add_response(text=f"Thanks for all the fish")
              elif question.type == ResponseOption.TYPE_INTEGER:
                  # For integer questions, pass an 'integer' keyword argument.
                  question.add_response(integer=42)
              elif question.type == ResponseOption.TYPE_RADIO:
                  # For radio questions, pass an 'option' keyword argument (a ResponseOption instance).
                  first_option = question.options[0]
                  question.add_response(option=first_option)
              elif question.type == ResponseOption.TYPE_CHECKBOX:
                  # For checkbox questions, add responses with option, selected flag, and optionally a comment.
                  first_option = question.options[0]
                  last_option = question.options[-1]
                  question.add_response(option=first_option, selected=True, comment="Don't panic")
                  question.add_response(option=last_option, selected=True)
          # Because we're directly setting a command_uuid, we can return both originate and edit.
          return [command.originate(), command.edit()]
    ```
###  Explanation 
  - **Retrieving Questions:** The `questions` property returns a list of question objects created from the questionnaire's data.
  - **Recording Responses:** Each question object provides an `add_response()` method that enforces the correct response format: 
    - For **TextQuestion** , you must pass a `text` parameter.
    - For **IntegerQuestion** , you must pass an `integer` parameter.
    - For **RadioQuestion** , you must pass an `option` parameter (a `ResponseOption` instance) that corresponds to one of the allowed options.
    - For **CheckboxQuestion** , you must pass an `option` parameter along with an optional `selected` flag (defaulting to True) and an optional `comment`. Multiple responses can be recorded for checkbox questions.
    - **Note for Checkboxes:** Only the responses explicitly provided in the command payload will be updated in the UI. If a checkbox response is already selected and is not sent as unselected in the payload, its state remains unchanged.
  - **Creating and Editing:** When creating a new questionnaire command, you must explicitly set a unique `command_uuid`. Providing this UUID enables you to originate the command within the note and then subsequently edit it with detailed responses in the same protocol execution.
  - This approach is necessary because given the dynamic nature of the questionnaire command, the initial creation (origination) only includes the questionnaire ID. Once the command has been originated, you can immediately follow up with an edit to populate it with the patient's responses.
  - If you are looking to insert a committed questionnaire command, you'll need to return three effects: 
    - An `.originate()` to insert the command and select the questionnaire
    - An `.edit()` to populate the responses
    - A `.commit()` to commit the command
* * *
##  ReasonForVisit 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`structured` | _boolean_ | `false` | Whether the RFV is structured or not. Defaults to False.  
`coding` | _Coding_ or _UUID (str)_ | `true` if structured=True | The coding for the structured RFV. Either a full Coding object (with `code`, `system`, `display`) or a UUID string referencing a verified coding record. If a Coding is provided, it is validated against existing records  
`comment` | _string_ | `false` | Additional commentary on the RFV.  
**Example** :
    ```python
    from canvas_sdk.commands import ReasonForVisitCommand
    structured_rfv = ReasonForVisitCommand(
      note_uuid='rk786p',
      structured=True,
      coding={'code': '', 'system': '', 'display': ''},
      comment='also wants to discuss treatment options'
    )
    # Example with a UUID string referencing a Coding record
    structured_rfv2 = ReasonForVisitCommand(
      note_uuid='rk786p',
      structured=True,
      coding="e2b1e1e3-3f52-4a0a-bb3a-123456789abc",  # Must correspond to an existing coding record
      comment="Discuss treatment options"
    )
    unstructured_rfv = ReasonForVisitCommand(
      note_uuid='rk786p',
      comment='also wants to discuss treatment options'
    )
    ```
##  Refer 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`service_provider` | _ServiceProvider_ | `true` | The service provider associated with the referral command.  
`diagnosis_codes` | _list[string]_ | `true` | A list of relevant ICD-10 Diagnosis.  
`clinical_question` | _ClinicalQuestion enum_ | `true` | The clinical question prompting the referral. Must be one of `ReferCommand.ClinicalQuestion`  
`priority` | _Priority enum_ | `false` | Priority of the imaging order. Must be one of `ReferCommand.Priority`.  
`notes_to_specialist` | _string_ | `true` | Notes or additional information directed to the specialist.  
`include_visit_note` | _boolean_ | `false` | Flag indicating whether the visit note should be included in the referral.  
`comment` | _string_ | `false` | An optional comment providing further details about the referral.  
`linked_items_urns` | _list[string]_ | `false` | List of URNs for items linked to the referral command.  
**Command-specific actions** :
Action Name | Available When | Description  
---|---|---  
`delegate_action` | command is staged | Delegates the order by creating a task.  
`sign_action` | command is staged | Signs the order, transitioning it from staged to committed state.  
`print_specialist` | command is committed | Prints the order using a specialist-focused template.  
`print_patient` | command is committed | Prints the order using a patient-friendly template.  
`fax` | command is committed | Transmits the order electronically via fax.  
**Enums and Types** :
**`Priority`**
Priority | Description  
---|---  
`ROUTINE` | Indicates a routine order.  
`URGENT` | Indicates un urgent order.  
**`ClinicalQuestion`**
Clinical Question | Description  
---|---  
COGNITIVE_ASSISTANCE | Cognitive Assistance (Advice/Guidance)  
ASSISTANCE_WITH_ONGOING_MANAGEMENT | Assistance with Ongoing Management  
SPECIALIZED_INTERVENTION | Specialized intervention  
DIAGNOSTIC_UNCERTAINTY | Diagnostic Uncertainty  
**Example** :
    ```python
    from canvas_sdk.commands import ReferCommand
    from canvas_sdk.commands.constants import ServiceProvider
    refer_command = ReferCommand(
        note_uuid="rk786p",
        diagnosis_codes=["E119"],
        priority=ReferCommand.Priority.ROUTINE,
        clinical_question=ReferCommand.ClinicalQuestion.DIAGNOSTIC_UNCERTAINTY,
        comment="this is a comment",
        notes_to_specialist="This is a note to specialist",
        include_visit_note=True,
        service_provider=ServiceProvider(
          first_name="Clinic",
          last_name="Acupuncture",
          practice_name="Clinic Acupuncture",
          specialty="Acupuncture",
          business_address="Street Address",
          business_phone="1234569874",
          business_fax="1234569874"
     ),
    )
    ```
* * *
##  ReferralReview 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`report_ids` | _list[string]_ | `true` | List of referral report IDs to review.  
`message_to_patient` | _string_ | `false` | Message to communicate findings to the patient.  
`communication_method` | _ReportReviewCommunicationMethod enum_ | `false` | Method for patient communication. Must be one of `ReferralReviewCommand.ReportReviewCommunicationMethod`.  
`linked_items_urns` | _list[string]_ | `false` | List of URNs for items linked to the review.  
`comment` | _string_ | `false` | Internal comment about the review.  
**Enums and Types** :
**`ReportReviewCommunicationMethod`**
Communication Method | Value | Description  
---|---|---  
`DELEGATED_CALL_CAN_LEAVE_MESSAGE` | `"DM"` | Delegated call - can leave message  
`DELEGATED_CALL_NEED_ANSWER` | `"DA"` | Delegated call - need answer  
`DELEGATED_LETTER` | `"DL"` | Delegated letter to be sent to patient  
`ALREADY_LEFT_MESSAGE` | `"AM"` | Already left message for patient  
`ALREADY_REVIEWED_WITH_PATIENT` | `"AR"` | Already reviewed with patient  
**Example** :
    ```python
    from canvas_sdk.commands import ReferralReviewCommand
    from canvas_sdk.commands.commands.review import ReportReviewCommunicationMethod
    from canvas_sdk.v1.data import Patient, ReferralReport
    patient = Patient.objects.get(id="patient-id")
    # Get referral reports to review
    referral_reports = ReferralReport.objects.filter(patient=patient, review__isnull=True)
    report_ids = [str(report.id) for report in referral_reports]
    referral_review = ReferralReviewCommand(
        note_uuid="a1b2c3d4-e5f6-4a5b-8c9d-0e1f2a3b4c5d",
        report_ids=report_ids,
        message_to_patient="Your referral has been reviewed and approved.",
        communication_method=ReportReviewCommunicationMethod.DELEGATED_CALL_CAN_LEAVE_MESSAGE,
        comment="Referral approved, patient notified."
    )
    ```
* * *
##  Refill 
**Command-specific parameters** :
Check the Prescribe command for the parameters used in the Refill command.
**Example** :
    ```python
    from canvas_sdk.commands import RefillCommand, PrescribeCommand
    from canvas_sdk.commands.constants import ClinicalQuantity
    RefillCommand(
        fdb_code="216092",
        icd10_codes=["R51"],
        sig="Take one tablet daily after meals",
        days_supply=30,
        quantity_to_dispense=30,
        type_to_dispense=ClinicalQuantity(
            representative_ndc="12843016128",
            ncpdp_quantity_qualifier_code="C48542"
        ),
        refills=3,
        substitutions=PrescribeCommand.Substitutions.ALLOWED,
        pharmacy="Main Street Pharmacy",
        prescriber_id="provider_123",
        supervising_provider_id="provider_456",
        note_to_pharmacist="Please verify patient's insurance before processing."
    )
    ```
* * *
##  RemoveAllergy 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`allergy_id` | _string_ | `true` | The external ID of the allergy to remove.  
`narrative` | _string_ | `false` | Additional context or narrative for the removal.  
**Example** :
    ```python
    from canvas_sdk.commands import RemoveAllergyCommand
    RemoveAllergyCommand(
        allergy_id="123",
        narrative="Allergy no longer applies after reassessment."
    )
    ```
* * *
##  Resolve Condition 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`condition_id` | _string_ | `true` | The externally exposable id of the condition being resolved.  
`show_in_condition_list` | _boolean_ | `false` | Determines whether the condition remains visible in patient chart summary.  
`rationale` | _string_ | `false` | Additional context.  
    ```python
    from canvas_sdk.commands.commands.resolve_condition import ResolveConditionCommand
    from canvas_sdk.v1.data import Condition
    patient_id = '<a patient ID from your instance>'
    patient_condition = Condition.objects.for_patient(patient_id).committed().active().first()
    ResolveConditionCommand(
       condition_id=patient_condition.id,
       show_in_condition_list=True,
       rationale="Additional notes.",
       note_uuid="rk786p",
    )
    ```
* * *
##  Review of Systems 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`questionnaire_id` | _string_ | `true` | The externally exposable id of the questionnaire being answered by the patient.  
`result` | _string_ | `false` | A summary of the result of the patient's answers.  
###  Toggle Questions Feature 
The ReviewOfSystemsCommand includes the same toggle functionality as PhysicalExamCommand, allowing practitioners to enable or disable specific system review questions based on patient relevance. You can find an extra example of this functionality on the Physical Exam Command Documentation.
**Methods** :
Method | Parameters | Returns | Description  
---|---|---|---  
`is_question_enabled` | `question_id: str` or `int` | `bool` | Check if a specific question is enabled (not skipped).  
`set_question_enabled` | `question_id: str` or `int, enabled: bool` | `None` | Enable or disable a specific question.  
`question_toggles` | _property_ | `dict` | Get all current toggle states (question_id → enabled).  
**Example** :
    ```python
    from canvas_sdk.commands import ReviewOfSystemsCommand
    # Create a new review of systems
    ros = ReviewOfSystemsCommand(
      note_uuid='8a18931a-acd9-474b-9070-ccd6fd472313',
      questionnaire_id='ed92577b-a023-4370-bc85-2b57e8afc4d8',
    )
    questions = ros.questions  # Retrieve the list of questions
    # Returns: [
    #               Question(
    #                       self.name='question-14',
    #                       self.label='Recurrent fever or chills',
    #                       self.type='TXT',
    #                       self.options=[]],
    #                       self.response=None
    #               ),
    #               Question(
    #                       self.name='question-25',
    #                       self.label='Other',
    #                       self.type='TXT', self.options=[],
    #                       self.response=None
    #               )
    # Check if a question is enabled
    if ros.is_question_enabled("14"):
      print("Recurrent fever or chills question is enabled.")
    # Disable irrelevant questions
    ros.set_question_enabled("25", False)
    # Get all toggle states
    states = ros.question_toggles
    # Returns: {"14": True, "25": False, "26": True, ...}, where keys are question IDs and values are enabled states.
    # Working with existing ros - toggle states are preserved
    existing_ros = ReviewOfSystemsCommand(command_uuid='existing-exam-uuid')
    # All previously set toggle states are automatically loaded
    ```
**Note:** The ReviewOfSystemsCommand is a subclass of the QuestionnaireCommand, so it supports all the questionnaire features (including response recording, question mapping, etc.). For detailed information on these features, please refer to the Questionnaire Command Documentation.
* * *
##  StopMedication 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`medication_id` | _string_ | `true` | Externally exposable id of the patient's medication being stopped.  
`rationale` | _string_ | `false` | The reason for stopping the medication.  
**Example** :
    ```python
    from canvas_sdk.commands import StopMedicationCommand
    stop_medication = StopMedicationCommand(
        note_uuid='rk786p',
        medication_id='2u309j',
        rationale='In remission'
    )
    ```
* * *
##  StructuredAssessment 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`questionnaire_id` | _string_ | `true` | The externally exposable id of the questionnaire being answered by the patient.  
`result` | _string_ | `false` | A summary of the result of the patient's answers.  
**Example** :
    ```python
    from canvas_sdk.commands import StructuredAssessmentCommand
    questionnaire = StructuredAssessmentCommand(
        note_uuid='rk786p',
        questionnaire_id='g73hd9',
        result='The patient is feeling average today.'
    )
    ```
**Note:** The StructuredAssessmentCommand is a subclass of the QuestionnaireCommand, so it supports all the questionnaire features (including response recording, question mapping, etc.). For detailed information on these features, please refer to the Questionnaire Command Documentation.
* * *
##  Task 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`title` | _string_ | `true` | The title or summary of the task.  
`assign_to` | _TaskAssigner_ | `true` | Specifies the assignee (role, team, or individual).  
`due_date` | _date_ | `false` | Due date for completing the task.  
`comment` | _string_ | `false` | Additional comments or notes about the task.  
`labels` | _list[string]_ | `false` | Labels associated with the task.  
`linked_items_urns` | _list[string]_ | `false` | URNs for items linked to the task.  
**Enums and Types** :
**TaskAssigner Type** :
Key | Type | Required | Description  
---|---|---|---  
`to` | _AssigneeType_ | `true` | Type of assignee (e.g., role, team, etc.).  
`id` | _integer_ | `false` | Identifier of the specific assignee.  
AssigneeType | Value | Description  
---|---|---  
`ROLE` | `"role"` | Task assigned to a specific role.  
`TEAM` | `"team"` | Task assigned to a specific team.  
`UNASSIGNED` | `"unassigned"` | Task is unassigned.  
`STAFF` | `"staff"` | Task assigned to a specific staff member.  
**Example** :
    ```python
    from canvas_sdk.commands import TaskCommand
    from canvas_sdk.commands.commands.task import TaskAssigner, AssigneeType
    from datetime import date
    TaskCommand(
        title="Follow-up appointment scheduling",
        assign_to=TaskAssigner(to=AssigneeType.STAFF, id=123),
        due_date=date(2024, 12, 15),
        comment="Ensure the patient schedules a follow-up within 30 days.",
        labels=["Urgent"],
        linked_items_urns=["urn:task:123", "urn:note:456"]
    )
    ```
* * *
##  UncategorizedDocumentReview 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`report_ids` | _list[string]_ | `true` | List of uncategorized document IDs to review.  
`message_to_patient` | _string_ | `false` | Message to communicate findings to the patient.  
`communication_method` | _ReportReviewCommunicationMethod enum_ | `false` | Method for patient communication. Must be one of `ReportReviewCommunicationMethod`.  
`linked_items_urns` | _list[string]_ | `false` | List of URNs for items linked to the review.  
`comment` | _string_ | `false` | Internal comment about the review.  
**Enums and Types** :
**`ReportReviewCommunicationMethod`**
Communication Method | Value | Description  
---|---|---  
`DELEGATED_CALL_CAN_LEAVE_MESSAGE` | `"DM"` | Delegated call - can leave message  
`DELEGATED_CALL_NEED_ANSWER` | `"DA"` | Delegated call - need answer  
`DELEGATED_LETTER` | `"DL"` | Delegated letter to be sent to patient  
`ALREADY_LEFT_MESSAGE` | `"AM"` | Already left message for patient  
`ALREADY_REVIEWED_WITH_PATIENT` | `"AR"` | Already reviewed with patient  
**Example** :
    ```python
    from canvas_sdk.commands import UncategorizedDocumentReviewCommand
    from canvas_sdk.v1.data import UncategorizedClinicalDocument, Patient
    from canvas_sdk.commands.commands.review import ReportReviewCommunicationMethod
    patient = Patient.objects.last()
    # Get uncategorized documents to review
    uncategorized_documents = UncategorizedClinicalDocument.objects.filter(patient=patient, review__isnull=True)
    report_ids = [str(doc.id) for doc in uncategorized_documents]
    uncategorized_review = UncategorizedDocumentReviewCommand(
        note_uuid="a1b2c3d4-e5f6-4a5b-8c9d-0e1f2a3b4c5d",
        report_ids=report_ids,
        message_to_patient="Your document has been reviewed.",
        communication_method=ReportReviewCommunicationMethod.DELEGATED_CALL_CAN_LEAVE_MESSAGE,
        comment="Document reviewed, no further action needed."
    )
    ```
* * *
##  UpdateDiagnosis 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`condition_code` | _string_ | `true` | The ICD-10 code of the existing diagnosis to update.  
`new_condition_code` | _string_ | `true` | The new condition ICD-10 code to replace the existing diagnosis.  
`background` | _string_ | `false` | Background information or notes related to the updated diagnosis.  
`narrative` | _string_ | `false` | A narrative or explanation about the update.  
* * *
**Example**
    ```python
    from canvas_sdk.commands import UpdateDiagnosisCommand
    UpdateDiagnosisCommand(
        condition_code="E119",
        new_condition_code="E109",
        background="Patient previously diagnosed with diabetes type 2; now updated to diabetes type 1.",
        narrative="Updating condition based on recent clinical findings."
    )
    ```
* * *
##  UpdateGoal 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`goal_id` | _string_ | `true` | Externally exposable id of the goal being updated.  
`due_date` | _datetime_ | `false` | The date the goal is due.  
`achievement_status` | _AchievementStatus enum_ | `false` | The current achievement status of the goal.  
`priority` | _Priority enum_ | `false` | The priority of the goal.  
`progress` | _string_ | `false` | A narrative about the patient's progress toward the goal.  
`AchievementStatus` |   
---|---  
IN_PROGRESS | "in-progress"  
IMPROVING | "improving"  
WORSENING | "worsening"  
NO_CHANGE | "no-change"  
ACHIEVED | "achieved"  
SUSTAINING | "sustaining"  
NOT_ACHIEVED | "not-achieved"  
NO_PROGRESS | "no-progress"  
NOT_ATTAINABLE | "not-attainable"  
`Priority` |   
---|---  
HIGH | "high-priority"  
MEDIUM | "medium-priority"  
LOW | "low-priority"  
**Example** :
    ```python
    from canvas_sdk.commands import UpdateGoalCommand, GoalCommand
    from datetime import datetime
    update_goal = UpdateGoalCommand(
        note_uuid='rk786p',
        goal_id='0j9whjjk',
        due_date=datetime(2025, 3, 31),
        achievement_status=GoalCommand.AchievementStatus.WORSENING,
        priority=GoalCommand.Priority.MEDIUM,
        progress='patient has slowed down progress and requesting to move due date out'
    )
    ```
* * *
##  Vitals 
**Command-specific parameters** :
Name | Type | Required | Description  
---|---|---|---  
`height` | _integer_ | `false` | Height in inches.  
`weight_lbs` | _integer_ | `false` | Weight in pounds.  
`weight_oz` | _integer_ | `false` | Weight in ounces.  
`waist_circumference` | _integer_ | `false` | Waist circumference in inches.  
`body_temperature` | _integer_ | `false` | Body temperature in Fahrenheit.  
`body_temperature_site` | _enum_ | `false` | Site of body temperature measurement.  
`blood_pressure_systole` | _integer_ | `false` | Systolic blood pressure.  
`blood_pressure_diastole` | _integer_ | `false` | Diastolic blood pressure.  
`blood_pressure_position_and_site` | _enum_ | `false` | Position and site of blood pressure measurement.  
`pulse` | _integer_ | `false` | Pulse rate in beats per minute.  
`pulse_rhythm` | _enum_ | `false` | Rhythm of the pulse.  
`respiration_rate` | _integer_ | `false` | Respiration rate in breaths per minute.  
`oxygen_saturation` | _integer_ | `false` | Oxygen saturation in percentage.  
`note` | _string_ | `false` | Additional notes (max length: 150 characters).  
**Enums and Types** :
BodyTemperatureSite | Value | Description  
---|---|---  
`AXILLARY` | `0` | Measurement taken from the armpit.  
`ORAL` | `1` | Measurement taken from the mouth.  
`RECTAL` | `2` | Measurement taken from the rectum.  
`TEMPORAL` | `3` | Measurement taken from the forehead.  
`TYMPANIC` | `4` | Measurement taken from the ear.  
BloodPressureSite | Value | Description  
---|---|---  
`SITTING_RIGHT_UPPER` | `0` | Sitting position, right upper arm.  
`SITTING_LEFT_UPPER` | `1` | Sitting position, left upper arm.  
`STANDING_RIGHT_UPPER` | `4` | Standing position, right upper arm.  
`SUPINE_LEFT_LOWER` | `11` | Supine position, left lower arm.  
PulseRhythm | Value | Description  
---|---|---  
`REGULAR` | `0` | Regular rhythm.  
`IRREGULARLY_IRREGULAR` | `1` | Completely irregular rhythm.  
`REGULARLY_IRREGULAR` | `2` | Regularly irregular rhythm.  
**Example** :
    ```python
    from canvas_sdk.commands import VitalsCommand
    VitalsCommand(
        height=70,
        weight_lbs=150,
        body_temperature=98,
        body_temperature_site=VitalsCommand.BodyTemperatureSite.ORAL,
        blood_pressure_systole=120,
        blood_pressure_diastole=80,
        blood_pressure_position_and_site=VitalsCommand.BloodPressureSite.SITTING_RIGHT_UPPER,
        pulse=72,
        pulse_rhythm=VitalsCommand.PulseRhythm.REGULAR,
        oxygen_saturation=98,
        note="Vitals are within normal range."
    )
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/commands/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-allergy-intolerance/
##  Introduction 
The `AllergyIntolerance` model represents a known risk, specific to a patient, of a harmful or undesirable physiological response associated with exposure to a substance.
##  Basic usage 
To get an allergy intolerance by identifier, use the `get` method on the `AllergyIntolerance` model manager:
    ```python
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    allergy = AllergyIntolerance.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the allergy intolerances for a patient can be accessed with the `allergy_intolerances` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    allergies = patient.allergy_intolerances.all()
    ```
If you have a patient ID, you can get the allergies for the patient with the `for_patient` method on the `AllergyIntolerance` model manager:
    ```python
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    allergies = AllergyIntolerance.objects.for_patient(patient_id)
    ```
##  Codings 
The codings for an allergy intolerance can be accessed with the `codings` attribute on an `AllergyIntolerance` object:
    ```python
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    from logger import log
    allergy = AllergyIntolerance.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in allergy.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Filtering 
Allergy intolerances can be filtered by any attribute that exists on the model.
Filtering for allergy intolerances is done with the `filter` method on the `AllergyIntolerance` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    allergies = AllergyIntolerance.objects.filter(status="active")
    ```
###  By ValueSet 
Filtering by ValueSet works a little differently. The `find` method on the model manager is used to perform `ValueSet` filtering:
    ```python
    from canvas_sdk.v1.data.allergy_intolerance import AllergyIntolerance
    from canvas_sdk.value_set.v2022.allergy import EggSubstance
    allergies = AllergyIntolerance.objects.find(EggSubstance)
    ```
##  Attributes 
###  AllergyIntolerance 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
note_id | Integer  
allergy_intolerance_type | String  
category | Integer  
status | String  
severity | String  
onset_date | Date  
onset_date_original_input | String  
last_occurrence | Date  
last_occurrence_original_input | String  
recorded_date | DateTime  
narrative | String  
codings | AllergyIntoleranceCoding[]  
###  AllergyIntoleranceCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
allergy_intolerance | AllergyIntolerance  
----- END PAGE https://docs.canvasmedical.com/sdk/data-allergy-intolerance/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-application/
##  Introduction 
The `Application` model represents a plugin Application in Canvas. Applications are used to integrate third-party tools and services into the Canvas platform, allowing users to access external resources and functionalities directly from within Canvas. Each application has a unique identifier, name and description.
##  Basic usage 
To get an application by identifier, use the `get` method on the `Application` model manager:
    ```python
    from canvas_sdk.v1.data import Application
    application = Application.objects.get(identifier="123")
    ```
##  Filtering 
Applications can be filtered by any attribute that exists on the model.
Filtering for applications is done with the `filter` method on the `Application` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data import Application
    applications = Application.objects.filter(name="application name")
    ```
##  Attributes 
###  Application 
Field Name | Type  
---|---  
identifier | str  
name | str  
description | str
----- END PAGE https://docs.canvasmedical.com/sdk/data-application/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-appointment/
##  Introduction 
The `Appointment` model represents a single scheduled meeting from a patient, that may be in the future or past.
##  Basic usage 
To get an appointment by identifier, use the `get` method on the `Appointment` model manager:
    ```python
    from canvas_sdk.v1.data.appointment import Appointment
    appointment = Appointment.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
    ```
If you have a patient object, the appointments for a patient can be accessed with the `appointments` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    appointments = patient.appointments.all()
    ```
To get appointments part of a recurrence.
    ```python
    from canvas_sdk.v1.data.appointment import Appointment
    appointment = Appointment.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
    # parent appointment
    parent_appointment = appointment.parent_appointment
    # children appointments
    children = parent_appointment.children.all()
    ```
##  Filtering 
Appointments can be filtered by any attribute that exists on the model.
Filtering for appointments is done with the `filter` method on the `Appointment` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.appointment import Appointment, AppointmentProgressStatus
    appointments = Appointment.objects.filter(status=AppointmentProgressStatus.CONFIRMED)
    ```
###  Filtering by External Identifiers 
To query Appointments by external identifiers, the `external_identifiers` relation can be used with double-underscores to identify values stored on the AppointmentExternalIdentifier model. For example:
    ```python
    from canvas_sdk.v1.data.appointment import Appointment
    appointment = Appointment.objects.filter(
        external_identifiers__system="COMPANY_IDENTIFIER",
        external_identifiers__value="ejNoTa5vKzoT9oSjg87MVB").first()
    ```
##  Attributes 
###  Appointment 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
appointment_rescheduled_from | Appointment  
parent_appointment | Appointment  
provider | Staff  
start_time | DateTime  
duration_minutes | Integer  
comment | String  
note_id | Integer  
note_type_id | Integer  
status | String  
meeting_link | URL  
telehealth_instructions_sent | Boolean  
location | PracticeLocation  
description | String  
external_identifiers | AppointmentExternalIdentifier[]  
metadata | AppointmentMetadata[]  
###  AppointmentExternalIdentifier 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
use | String  
identifier_type | String  
system | String  
value | String  
issued_date | Date  
expiration_date | Date  
appointment | Appointment  
###  AppointmentMetadata 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
appointment | Appointment  
key | String  
value | String  
    ```python
    from canvas_sdk.v1.data.appointment import Appointment
    from logger import log
    appointment_id = "f53626e4-0683-43ac-a1b7-c52815639ce2"
    appointment = Appointment.objects.get(id=appointment_id)
    appointment_metadata = appointment.metadata.all()
    for metadata in appointment_metadata:
       log.info(f"Appointment metadata: {metadata.key}, {metadata.value}")
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/data-appointment/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-assessment/
##  Introduction 
The `Assessment` model represents a clinical assessment or evaluation of a patient's medical `Condition`.
##  Basic usage 
To get an assessment by identifier, use the `get` method on the `Assessment` model manager:
    ```python
    from canvas_sdk.v1.data.assessment import Assessment
    assessment = Assessment.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the assessments for a patient can be accessed with the `assessments` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    assessments = patient.assessments.all()
    ```
##  Filtering 
Assessments can be filtered by any attribute that exists on the model.
Filtering for assessments is done with the `filter` method on the `Assessment` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.assessment import Assessment, AssessmentStatus
    assessments = Assessment.objects.filter(patient__id="1eed3ea2a8d546a1b681a2a45de1d790", status=AssessmentStatus.STATUS_IMPROVING)
    ```
##  Attributes 
###  Assessment 
Field Name | Type |   
---|---|---  
id | UUID |   
dbid | Integer |   
created | DateTime |   
modified | DateTime |   
originator | [CanvasUser](/sdk/data-canvasuser) |   
deleted | Boolean |   
entered_in_error | [CanvasUser](/sdk/data-canvasuser) |   
committer | [CanvasUser](/sdk/data-canvasuser) |   
patient | [Patient](/sdk/data-patient/#patient) |   
note | [Note](/sdk/data-note/#note) |   
condition | [Condition](/sdk/data-condition/#condition) |   
interview | [Interview](/sdk/data-questionnaire/#interview) |   
status | AssessmentStatus |   
narrative | String |   
background | String |   
care_team | String |   
treatments_stated | [MedicationStatement](/sdk/data-medication-statement)[] |   
billinglineitem_set | [BillingLineItem](/sdk/data-billing-line-item)[] |   
##  Enumeration types 
###  Assessment Status 
Value | Label  
---|---  
STATUS_IMPROVING | Improved  
STATUS_STABLE | Unchanged  
STATUS_DETERIORATING | Deteriorated  
----- END PAGE https://docs.canvasmedical.com/sdk/data-assessment/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-banner-alert/
##  Introduction 
The `BannerAlert` model represents alerts associated with [Patient](/sdk/data-patient/#patient) records. This page deals with data retrieval. To create or remove `BannerAlert` records, see [Banner Alert Effects](/sdk/effect-banner-alerts/).
##  Usage 
The `BannerAlert` model can be used to find all of the banner alert records linked to a patient. For example, to find all of the banner alerts for a patient, the `Patient.banner_alerts` method can be used:
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_banner_alerts = patient_1.banner_alerts.all()
    >>> print([item.narrative for item in patient_banner_alerts])
    ['Patient spits when angry', 'Confirm contact info']
    ```
##  Filtering 
The `filter` method can be used to filter by desired attributes. The following examples show commonly used operations to filter banner alert data:
**Show a Patient's active BannerAlert records from the 'foo' plugin in order of descending creation date**
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> banner_alerts = patient_1.banner_alerts.filter(status='active', plugin_name='foo').order_by("created")
    >>> print([item.narrative for item in banner_alerts])
    ['foo', 'bar']
    ```
##  Attributes 
###  BannerAlert 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
plugin_name | String  
key | String  
narrative | String  
placement | BannerAlertPlacement[]  
intent | BannerAlertIntent  
href | String  
status | BannerAlertStatus  
##  Enumeration types 
###  BannerAlertStatus 
Value | Label  
---|---  
active | Active  
inactive | Inactive  
###  BannerAlertIntent 
Value | Label  
---|---  
info | Info  
warning | Warning  
alert | Alert  
###  BannerAlertPlacement 
Value | Label  
---|---  
chart | Chart  
timeline | Timeline  
appointment_card | Appointment Card  
scheduling_card | Scheduling Card  
profile | Profile
----- END PAGE https://docs.canvasmedical.com/sdk/data-banner-alert/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-billing-line-item/
##  Introduction 
The `BillingLineItem` model represents billing line items linked to [Notes](/sdk/data-note) that can be found in the note footer. BillingLineItems are also linked to [Patient](/sdk/data-patient/#patient) instances.
##  Usage 
The `BillingLineItem` model can be used to find all of the billable codes linked to a patient note. For example, to find all of the current billing line items for a note, the `Note.billing_line_items` method can be used:
    ```python
    >>> from canvas_sdk.v1.data.note import Note
    >>> from canvas_sdk.v1.data.billing import BillingLineItemStatus
    >>> note_1 = Note.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> note_1_billing_line_items = note_1.billing_line_items.filter(status=BillingLineItemStatus.ACTIVE)
    >>> print([item.cpt for item in note_1_billing_line_items])
    ['99213', '90703']
    ```
Alternatively, you could find all the `BillingLineItem` instances for a single `Patient`:
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_billing_line_items = patient_1.billing_line_items.all()
    >>> print([item.cpt for item in patient_billing_line_items])
    ['99213', '90703', '76942', '67505']
    ```
You can also access all `BillingLineItemModifier`s associated with a `BillingLineItem`:
    ```python
    >>> from canvas_sdk.v1.data.billing import BillingLineItem, BillingLineItemModifier
    >>> line_item = BillingLineItem.objects.get(id="b80b1cdc2e6a4aca90ccebc02e683f35")
    >>> line_item_modifiers = line_item.modifiers.all()
    >>> print([mod.code for mod in line_item_modifiers])
    ['25', '59']
    ```
##  Filtering 
The `filter` method can be used to filter by desired attributes. The following examples show commonly used operations to filter billing line item data:
**Show a Patient's active BillingLineItems that start with '99-' in order of descending charge amount**
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> from canvas_sdk.v1.data.billing import BillingLineItemStatus
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> office_visit_charges = patient_1.billing_line_items.filter(status=BillingLineItemStatus.ACTIVE, cpt__startswith='99').order_by("charge")
    >>> print([(item.cpt, item.charge,) for item in office_visit_charges])
    [('99215', 200.00), ('99215', 190.00), ('99214', 100.00), ('99213', 80.00)]
    ```
**Find All Removed BillingLineItems from a Note**
    ```python
    >>> import arrow
    >>> from canvas_sdk.v1.data.note import Note
    >>> from canvas_sdk.v1.data.billing import BillingLineItemStatus
    >>> note_1 = Note.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> note_1_removed_items = note_1.billing_line_items.filter(status=BillingLineItemStatus.REMOVED)
    >>> print([item.cpt for item in note_1_removed_items])
    ['11901', '00950']
    ```
For examples of how to use the BillingLineItem data class with the BillingLineItem effects, check out [this page](/sdk/effect-billing-line-items)
##  Attributes 
###  BillingLineItem 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
note | [Note](/sdk/data-note)  
patient | [Patient](/sdk/data-patient/#patient)  
cpt | String  
charge | Decimal  
description | String  
units | Integer  
command_type | String  
command_id | Integer  
status | BillingLineItemStatus  
assessments | [Assessment](/sdk/data-assessment)[]  
###  BillingLineItemModifier 
Field Name | Type  
---|---  
dbid | Integer  
line_item | BillingLineItem  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
##  Enumeration types 
###  BillingLineItemStatus 
Value | Label  
---|---  
ACTIVE | Active  
REMOVED | Removed
----- END PAGE https://docs.canvasmedical.com/sdk/data-billing-line-item/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-business-line/
##  Introduction 
The `BusinessLine` model represents a group of [Patients](/sdk/data-patient/#patient) that share a common brand under an [Organization](/sdk/data-organization).
##  Usage 
The `BusinessLine` model can be used to find all of the patients for a given Business Line:
    ```python
    >>> from canvas_sdk.v1.data import BusinessLine
    >>> business_line = BusinessLine.objects.get(id="ff844d60Od18466698dc645PtYZ3019Tt")
    >>> business_line_patients = business_line.patients.all()
    >>> print([patient.first_name for patient in business_line_patients])
    ['George', 'Louise', 'Julia']
    ```
You can also access a patient's Business Line from the `Patient` model:
    ```python
    >>> from canvas_sdk.v1.data import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_business_line = patient_1.business_line
    >>> print(patient_business_line.name)
    'New Patients that love cheese'
    ```
And you can also access all of the Business Lines under a given Organization:
    ```python
    >>> from canvas_sdk.v1.data import Organization
    >>> organization = Organization.objects.first()
    >>> organization_business_lines = organization.business_lines.all()
    >>> print([business_line.name for business_line in organization_business_lines])
    ['New Patients that love cheese', 'Spanish Speaking Patients', 'One Medical']
    ```
##  Filtering 
The `filter` method can be used to filter by desired attributes. The following examples show commonly used operations to filter Business Line data:
**Show an Organization's Business Lines that are active and in the 732 area code**
    ```python
    >>> from canvas_sdk.v1.data import BusinessLine, Organization
    >>> org = Organization.objects.first()
    >>> active_732_business_lines = BusinessLine.objects.filter(organization=org, active=True, area_code="732")
    >>> print([business_line.name for business_line in active_732_business_lines])
    ['Foo', 'Bar']
    ```
##  Attributes 
###  BusinessLine 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
name | String  
description | String  
area_code | String  
subdomain | String  
active | Boolean  
state | BusinessLineState  
organization | [Organization](/sdk/data-organization)  
##  Enumeration types 
###  BusinessLineState 
Value | Label  
---|---  
success | Success  
pending | Pending  
error | Deleted
----- END PAGE https://docs.canvasmedical.com/sdk/data-business-line/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-calendar/
##  Introduction 
The `Calendar` model represents a Calendar in Canvas. Calendars are used to organize events for providers and can be either Clinic or Administrative type.
##  Basic usage 
To get a calendar by identifier, use the `get` method on the `Calendar` model manager:
    ```python
    from canvas_sdk.v1.data.calendar import Calendar
    calendar = Calendar.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
    ```
##  Events 
The events associated with a calendar can be accessed with the `events` attribute on a `Calendar` object:
    ```python
    from canvas_sdk.v1.data.calendar import Calendar
    calendar = Calendar.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
    events = calendar.events.all()
    ```
To get a specific event by identifier:
    ```python
    from canvas_sdk.v1.data.calendar import Event
    event = Event.objects.get(id="a1b2c3d4-5678-90ab-cdef-1234567890ab")
    ```
##  Filtering 
Calendars and events can be filtered by any attribute that exists on the model.
Filtering is done with the `filter` method on the model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.calendar import Calendar
    # Filter calendars by title
    calendars = Calendar.objects.filter(title__icontains="Clinic")
    ```
###  By calendar name 
To filter calendars by a specific provider name, calendar type, and location, use the `for_calendar_name` method:
    ```python
    from canvas_sdk.v1.data.calendar import Calendar
    calendars = Calendar.objects.for_calendar_name(
        provider_name="Dr. Smith",
        calendar_type="Clinic",
        location="Main Office"
    )
    ```
##  Attributes 
###  Calendar 
Field Name | Type | Description  
---|---|---  
id | UUID | Unique identifier for the calendar  
dbid | Integer | Database identifier  
title | String | The title of the calendar  
timezone | TimeZone | The timezone for the calendar (default: UTC)  
description | String | Optional description of the calendar's purpose  
events | Event[] | Events associated with this calendar  
###  Event 
Field Name | Type | Description  
---|---|---  
id | UUID | Unique identifier for the event  
dbid | Integer | Database identifier  
title | String | The title of the event  
description | String | Description of the event  
calendar | Calendar | The calendar this event belongs to  
starts_at | DateTime | The start date and time of the event  
ends_at | DateTime | The end date and time of the event  
recurrence | String | Recurrence rule for recurring events  
recurrence_ends_at | DateTime | The date and time when the recurrence pattern ends  
recurring_parent_event | Event | The parent event  
original_starts_at | DateTime | The original start time for recurring event exceptions  
is_all_day | Boolean | Whether this is an all-day event (default: false)  
is_cancelled | Boolean | Whether this event has been cancelled (default: false)  
allowed_note_types | NoteType[] | Note types that are allowed for this event  
##  Examples 
###  Working with calendar events 
    ```python
    from canvas_sdk.v1.data.calendar import Calendar
    from datetime import datetime
    from logger import log
    calendar = Calendar.objects.get(id="f53626e4-0683-43ac-a1b7-c52815639ce2")
    # Get all upcoming events
    upcoming_events = calendar.events.filter(
        starts_at__gte=datetime.now(),
        is_cancelled=False
    ).order_by('starts_at')
    for event in upcoming_events:
        log.info(f"Event: {event.title}")
        log.info(f"Starts at: {event.starts_at}")
        log.info(f"Ends at: {event.ends_at}")
        if event.recurrence:
            log.info(f"Recurrence: {event.recurrence}")
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/data-calendar/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-canvasuser/
##  Introduction 
The `CanvasUser` model represents a Canvas User. This could be linked to a staff member or a patient. This model isn't meant to be referenced directly, but is sometimes used to attribute a record to user.
##  Basic usage 
To get a user by identifier, use the `get` method on the `CanvasUser` model manager:
    ```python
    from canvas_sdk.v1.data import CanvasUser
    user = CanvasUser.objects.get(dbid=123)
    ```
##  Filtering 
Users can be filtered by any attribute that exists on the model.
Filtering for users is done with the `filter` method on the `CanvasUser` model manager.
###  By attribute 
Specify attributes with `filter` to filter by those attributes:
    ```python
    from canvas_sdk.v1.data import CanvasUser
    users = CanvasUser.objects.filter(phone_number="1111111111", email="test@canvasmedical.com")
    ```
##  Attributes 
###  User 
Field Name | Type  
---|---  
dbid | Integer  
email | String  
phone_number | String  
is_staff | Boolean  
is_portal_registered | Boolean  
last_invite_date_time | DateTime  
----- END PAGE https://docs.canvasmedical.com/sdk/data-canvasuser/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-care-team/
##  Introduction 
The `CareTeam` model represents a collection of [Staff](/sdk/data-staff/#staff) that are responsible for the care of a [Patient](/sdk/data-patient/#patient).
##  Usage 
There are 2 data models associated with Care Teams - `CareTeamMembership` and `CareTeamRole`. The `CareTeamRole` model stores all of the available roles that are available to be filled by staff members (i.e. _Physician_ , _Nurse Practitioner_ , etc.). For example, the following code will show the names of active roles that are available in a Canvas instance:
    ```python
    >>> from canvas_sdk.v1.data.care_team import CareTeamRole
    >>> active_care_team_roles = CareTeamRole.objects.filter(active=True)
    >>> role_names = [role.display for role in active_care_team_roles]
    >>> print(role_names)
    ['Primary care physician', 'Physician', 'Physician assistant', 'Nurse practitioner', 'Health coach', 'Care coordinator']
    ```
The `CareTeamMembership` model connects patients, staff members and their associated roles to make up the assembly of a patient's Care Team. To retrieve staff members and their respective roles on a patient's care team, the `care_team_memberships` attribute available on a [Patient](/sdk/data-patient/#patient) instance can be used:
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> patient_1_care_team = patient_1.care_team_memberships.all()
    >>> print([(ctm.role.display, ctm.staff,) for ctm in patient_1_care_team])
    [('Primary care physician', <Staff: Steven Magee>), ('Nurse practitioner', <Staff: Annalies Hines>), ('Physician assistant', <Staff: Erik McDonald>)]
    ```
##  Filtering 
The `filter` method can be used to filter by desired attributes. The following examples show commonly used operations to filter care team data:
**Find a patient's care team lead**
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> from canvas_sdk.v1.data.care_team import CareTeamMembershipStatus
    >>> patient_1 = Patient.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> patient_1_care_team_lead = patient_1.care_team_memberships.filter(lead=True, status=CareTeamMembershipStatus.ACTIVE).first()
    >>> assert patient_1_care_team_lead is not None
    >>> print((patient_1_care_team_lead.staff, patient_1_care_team_lead.role,))
    (<Staff: Steven Magee>, <CareTeamRole: Primary care physician>)
    ```
**Find all Patients that have a Certain Staff Member on their Care Team**
    ```python
    >>> from canvas_sdk.v1.data.staff import Staff
    >>> from canvas_sdk.v1.data.care_team import CareTeamMembershipStatus
    >>> staff_member = Staff.objects.get(id="3640cd20de8a470aa570a852859ac87e")
    >>> staff_care_teams = staff_member.care_team_memberships.filter(status=CareTeamMembershipStatus.ACTIVE)
    >>> print([(ctm.patient, ctm.lead,) for ctm in staff_care_teams])
    [(<Patient: Danny Boy>, True), (<Patient: Sally Mae>, False)]
    ```
##  Attributes 
###  CareTeamRole 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | BooleanField  
active | Boolean  
care_teams | [CareTeamMembership](/sdk/data-care-team/#careteammembership)[]  
###  CareTeamMembership 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
staff | [Staff](/sdk/data-staff#staff)  
role | CareTeamRole  
status | CareTeamMembershipStatus  
lead | Boolean  
role_code | String  
role_system | String  
role_display | String  
##  Enumeration types 
###  CareTeamMembershipStatus 
Value | Label  
---|---  
proposed | Proposed  
active | Active  
suspended | Suspended  
inactive | Inactive  
entered-in-error | Entered in Error
----- END PAGE https://docs.canvasmedical.com/sdk/data-care-team/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-charge-description-master/
##  Introduction 
The `ChargeDescriptionMaster` model represents a billing charge in Canvas that can be added to the note footer.
##  Usage 
The `ChargeDescriptionMaster` model can be filtered by any of its attributes, including `cpt_code`, `name`, and `short_name`:
    ```python
    >>> from canvas_sdk.v1.data import ChargeDescriptionMaster
    >>> office_visit_charges = ChargeDescriptionMaster.objects.filter(cpt_code__startswith="99")
    >>> print([charge.short_name for charge in office_visit_charges])
    ["Office outpatient visit 40 minutes", "Office outpatient visit 25 minutes", "Office outpatient visit 10 minutes"]
    ```
You can also access `PayorSpecificCharge`s from the `ChargeDescriptionMaster` model:
    ```python
    >>> from canvas_sdk.v1.data import ChargeDescriptionMaster
    >>> office_visit_40min = ChargeDescriptionMaster.objects.filter(cpt_code="99215").first()
    >>> payor_specific_charges = office_visit_40min.transactor_charges.all()
    >>> print([charge.transactor.name for charge in payor_specific_charges])
    ["Aetna", "Medicare", "Blue Shield of CA"]
    ```
`
##  Attributes 
###  ChargeDescriptionMaster 
Field Name | Type  
---|---  
dbid | Integer  
cpt_code | String  
name | String  
short_name | String  
charge_amount | Decimal  
effective_date | Date  
end_date | Date  
code_system | CDMCodeSystem  
ndc_code | String  
##  Enumeration types 
###  CDMCodeSystem 
Value | Label  
---|---  
INTERNAL | Internal  
CPT | CPT
----- END PAGE https://docs.canvasmedical.com/sdk/data-charge-description-master/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-claim/
##  Introduction 
This module defines the data models used to manage healthcare claim workflows.
##  Basic usage 
To retrieve a claim by its identifier:
    ```python
    from canvas_sdk.v1.data.claim import Claim
    claim = Claim.objects.get(id="9d2e0f58-338b-11ec-8d3d-0242ac130003")
    ```
To access diagnosis codes for a claim:
    ```python
    from canvas_sdk.v1.data.claim import Claim
    claim = Claim.objects.get(id="9d2e0f58-338b-11ec-8d3d-0242ac130003")
    diagnosis_codes = claim.diagnosis_codes.all().order_by("rank")
    for diagnosis in diagnosis_codes:
        print(f"Rank {diagnosis.rank}: {diagnosis.code} - {diagnosis.display}")
    ```
##  Filtering 
    ```python
    from canvas_sdk.v1.data.claim import Claim
    # Active claims only
    active_claims = Claim.objects.active()
    ```
##  Attributes 
###  Claim 
Represents a complete healthcare claim. Claim belongs to a Note and has a one-to-one relationship with a ClaimPatient.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
note | [Note](/sdk/data-note/)  
installment_plan | InstallmentPlan  
current_queue | ClaimQueue  
current_coverage | ClaimCoverage  
accept_assign | Boolean  
auto_accident | Boolean  
auto_accident_state | String  
employment_related | Boolean  
other_accident | Boolean  
accident_code | String  
illness_date | Date  
remote_batch_id | String  
remote_file_id | String  
prior_auth | String  
narrative | String  
account_number | String  
snoozed_until | Date  
patient_balance | Decimal  
aggregate_coverage_balance | Decimal  
created | DateTime  
modified | DateTime  
diagnosis_codes | ClaimDiagnosisCode[]  
comments | ClaimComment[]  
line_items | ClaimLineItem[]  
labels | [TaskLabel](/sdk/data-task/#tasklabel)[]  
provider | ClaimProvider  
**Computed Properties** :
  - `total_charges`: Total charges for active line items
  - `total_paid`: Sum of paid amounts from postings
  - `total_adjusted`: Sum of adjustments and transfers
  - `balance`: Remaining balance (coverage + patient)
  - `total_patient_paid`: Paid amount by the patient
  - `total_payer_paid`: Paid amount by coverages
**Helpful Methods** :
  - `get_coverage_by_payer_id(payer_id: str, subscriber_number: str | None = None)`: Finds the active coverage associated with a payer_id. Optionally checks if the subscriber_number matches, which will choose the correct coverage in the case where a patient has two coverages with the same payer_id.
###  ClaimLineItem 
Represents individual billed procedures or services tied to a claim.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
billing_line_item | [BillingLineItem](/sdk/data-billing-line-item/)  
diagnosis_codes | ClaimLineItemDiagnosisCode[]  
claim | Claim  
status | ClaimLineItemStatus  
charge | Decimal  
from_date | String  
thru_date | String  
narrative | String  
ndc_code | String  
ndc_dosage | String  
ndc_measure | String  
place_of_service | [PracticeLocationPOS](/sdk/data-note/#practicelocationpos)  
proc_code | String  
display | String  
remote_chg_id | String  
units | Integer  
epsdt | String  
family_planning | FamilyPlanningOptions  
created | DateTime  
modified | DateTime  
###  ClaimLineItemDiagnosisCode 
Represents a diagnosis code for a given ClaimLineItem. There exists one ClaimLineItemDiagnosisCode for each ClaimDiagnosisCode, and the "linked" attribute indicates whether or not the diagnosis code is linked to the line item.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
line_item | ClaimLineItem  
claim_diagnosis_code | ClaimDiagnosisCode  
code | String  
poa | String  
linked | Boolean  
created | DateTime  
modified | DateTime  
###  ClaimCoverage 
Links a claim to a specific insurance coverage.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
claim | Claim  
coverage | [Coverage](/sdk/data-coverage/)  
active | Boolean  
payer_name | String  
payer_id | String  
payer_typecode | String  
payer_order | ClaimPayerOrder  
payer_addr1 | String  
payer_addr2 | String  
payer_city | String  
payer_state | String  
payer_zip | String  
payer_plan_type | ClaimTypeCode  
coverage_type | [CoverageType](/data-coverage/#coveragetype)  
subscriber_employer | String  
subscriber_group | String  
subscriber_number | String  
subscriber_plan | String  
subscriber_dob | String  
subscriber_first_name | String  
subscriber_last_name | String  
subscriber_middle_name | String  
subscriber_phone | String  
subscriber_sex | [PersonSex](/sdk/data-patient/#sexatbirth)  
subscriber_addr1 | String  
subscriber_addr2 | String  
subscriber_city | String  
subscriber_state | String  
subscriber_zip | String  
subscriber_country | String  
patient_relationship_to_subscriber | [CoverageRelationshipCode](/sdk/data-coverage/#coveragerelationshipcode)  
pay_to_addr1 | String  
pay_to_addr2 | String  
pay_to_city | String  
pay_to_state | String  
pay_to_zip | String  
resubmission_code | String  
payer_icn | String  
created | DateTime  
modified | DateTime  
###  ClaimComment 
Represents a free-text comment made on a Claim.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
claim | Claim  
created | DateTime  
modified | DateTime  
deleted | Boolean  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
comment | String  
###  ClaimDiagnosisCode 
Represents diagnosis codes associated with a claim, ordered by rank.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
claim | Claim  
line_item_diagnosis_codes | ClaimLineItemDiagnosisCode[]  
rank | Integer  
code | String  
display | String  
created | DateTime  
modified | DateTime  
###  ClaimQueue 
Defines the metadata for claim queues used in revenue workflows.
Field Name | Type  
---|---  
dbid | Integer  
queue_sort_ordering | Integer  
name | String  
display_name | String  
description | String  
show_in_revenue | Boolean  
visible_columns | Array[ClaimQueueColumns]  
created | DateTime  
modified | DateTime  
###  ClaimPatient 
Captures patient-level data related to a specific claim.
Field Name | Type  
---|---  
dbid | Integer  
claim | Claim  
photo | String  
dob | String  
first_name | String  
last_name | String  
middle_name | String  
phone | String  
sex | [PersonSex](/sdk/data-patient/#sexatbirth)  
ssn | String  
addr1 | String  
addr2 | String  
city | String  
state | String  
zip | String  
country | String  
created | DateTime  
modified | DateTime  
###  ClaimLabel 
Represents labels assigned to the claim.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
claim | Claim  
label | [TaskLabel](/sdk/data-task/#tasklabel)  
###  ClaimProvider 
Captures provider-level data related to a specific claim.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
claim | Claim  
clia_number | String  
billing_provider_name | String  
billing_provider_phone | String  
billing_provider_addr1 | String  
billing_provider_addr2 | String  
billing_provider_city | String  
billing_provider_state | String  
billing_provider_zip | String  
billing_provider_id | String  
billing_provider_npi | String  
billing_provider_tax_id | String  
billing_provider_tax_id_type | String  
billing_provider_taxonomy | String  
provider_id | String  
provider_first_name | String  
provider_last_name | String  
provider_middle_name | String  
provider_npi | String  
provider_tax_id | String  
provider_tax_id_type | String  
provider_taxonomy | String  
provider_ptan_identifier | String  
referring_provider_id | String  
referring_provider_first_name | String  
referring_provider_last_name | String  
referring_provider_middle_name | String  
referring_provider_npi | String  
referring_provider_ptan_identifier | String  
ordering_provider_first_name | String  
ordering_provider_last_name | String  
ordering_provider_middle_name | String  
ordering_provider_npi | String  
facility_id | String  
facility_name | String  
facility_npi | String  
facility_addr1 | String  
facility_addr2 | String  
facility_city | String  
facility_state | String  
facility_zip | String  
hosp_from_date | String  
hosp_to_date | String  
created | DateTime  
modified | DateTime  
###  ClaimSubmission 
Captures clearinghouse submission details about a claim.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
claim | Claim  
coverage | ClaimCoverage  
clearinghouse_claim_id | String  
claim_index | Integer  
###  InstallmentPlan 
Represents a payment plan between a patient and provider.
Field Name | Type  
---|---  
creator | [CanvasUser](/sdk/data-canvasuser/)  
patient | [Patient](/sdk/data-patient/)  
total_amount | Decimal  
status | InstallmentPlanStatus  
expected_payoff_date | Date  
created_at | DateTime  
updated_at | DateTime  
##  Enumeration types 
###  ClaimLineItemStatus 
Value | Label  
---|---  
active | Active  
removed | Removed  
###  LineItemCodes 
Value  
---  
COPAY  
UNLINKED  
###  FamilyPlanningOptions 
Value | Label  
---|---  
Y | Yes  
N | No  
###  ClaimLineItemStatus 
Value | Label  
---|---  
active | Active  
removed | Removed  
###  LineItemCodes 
Value  
---  
COPAY  
UNLINKED  
###  FamilyPlanningOptions 
Value | Label  
---|---  
Y | Yes  
N | No  
###  ClaimPayerOrder 
Value | Label  
---|---  
Primary | Primary  
Secondary | Secondary  
Tertiary | Tertiary  
Quaternary | Quaternary  
Quinary | Quinary  
###  ClaimTypeCode 
Code | Description  
---|---  
12 | Working Aged (Age 65 or older)  
13 | End-Stage Renal Disease  
14 | No-fault  
15 | Workers Compensation  
41 | Black Lung  
42 | Veterans Administration  
43 | Disabled (Under Age 65)  
47 | Other Liability Insurance is primary  
"" | No Typecode necessary  
###  ClaimQueueColumns 
Value | Label  
---|---  
NoteType | Note type  
ClaimID | Claim ID  
DateOfService | Date of service  
Patient | Patient  
ActiveInsurance | Active insurance  
InsuranceBalance | Insurance balance  
PatientBalance | Patient balance  
DaysInQueue | Days in queue  
Provider | Provider  
Guarantor | Guarantor  
LatestRemit | Latest remit  
LastInvoiced | Last invoiced  
SnoozedUntil | Snoozed until  
Labels | Labels  
###  ClaimQueues 
Value | Label  
---|---  
1 | Appointment  
2 | NeedsClinicianReview  
3 | NeedsCodingReview  
4 | QueuedForSubmission  
5 | FiledAwaitingResponse  
6 | RejectedNeedsReview  
7 | AdjudicatedOpenBalance  
8 | PatientBalance  
9 | ZeroBalance  
10 | Trash  
###  InstallmentPlanStatus 
Value | Label  
---|---  
active | Active  
completed | Completed  
cancelled | Cancelled
----- END PAGE https://docs.canvasmedical.com/sdk/data-claim/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-command/
##  Introduction 
The `Command` model represents a [command](/sdk/commands/) in a note.
##  Basic usage 
To get a command by identifier, use the `get` method on the `Command` model manager:
    ```python
    from canvas_sdk.v1.data.command import Command
    command = Command.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
##  Filtering 
Commands can be filtered by any attribute that exists on the model.
Filtering for commands is done with the `filter` method on the `Command` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.command import Command
    commands = Command.objects.filter(state="committed")
    ```
##  Command types and data 
When events are fired as part of [Command Lifecycle Events](/sdk/events/#command-lifecycle-events), the `self.target` value that is available within a plugin will contain the `id` value of the command. For example:
    ```python
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from logger import log
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.REASON_FOR_VISIT_COMMAND__POST_UPDATE),
        ]
        def compute(self) -> list[Effect]:
            log.info(self.target) # logs the Command id
    ```
Using this value, the `Command` model can be queried to fetch additional data about the command. Two main fields to pay attention to here are the `schema_key` and `data` fields. The `schema_key` field contains the type of the command, while the `data` field contains a JSON object with command data as key/value pairs:
    ```python
    import json
    from canvas_sdk.effects import Effect
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.command import Command
    from logger import log
    class Protocol(BaseProtocol):
        def compute(self) -> list[Effect]:
            command_instance = Command.objects.get(id=self.target)
            log.info(command_instance.schema_key)
            log.info(json.dumps(command_instance.data, indent=2))
    ```
For example, for a _Reason For Visit_ command, the preceding code would log the following lines:
    ```sh
    reasonForVisit
    {
      "coding": {
        "text": "Accident-prone",
        "extra": null,
        "value": "165002",
        "disabled": false,
        "annotations": null,
        "description": null
      },
      "comment": "Patient would like to discuss condition."
    }
    ```
The following table shows the different command `schema_key` values with links to their respective [Command Modules](/sdk/commands). The attributes shown in each corresponding entry contain the structure that will appear in the `data` JSON field of each `Command`.
Schema Key | Command Data  
---|---  
adjustPrescription | [AdjustPrescription](/sdk/commands/#adjustprescription)  
allergy | [Allergy](/sdk/commands/#allergy)  
assess | [Assess](/sdk/commands/#assess)  
changeMedication | [ChangeMedication](/sdk/commands/#changemedication)  
closeGoal | [CloseGoal](/sdk/commands/#closegoal)  
diagnose | [Diagnose](/sdk/commands/#diagnose)  
familyHistory | [FamilyHistory](/sdk/commands/#familyhistory)  
followUp | [FollowUp](/sdk/commands/#followUp)  
goal | [Goal](/sdk/commands/#goal)  
hpi | [HistoryOfPresentIllness](/sdk/commands/#historyofpresentillness)  
imagingOrder | [ImagingOrder](/sdk/commands/#imagingorder)  
instruct | [Instruct](/sdk/commands/#instruct)  
labOrder | [LabOrder](/sdk/commands/#laborder)  
medicalHistory | [MedicalHistory](/sdk/commands/#medicalhistory)  
medicationStatement | [MedicationStatement](/sdk/commands/#medicationstatement)  
perform | [Perform](/sdk/commands/#perform)  
plan | [Plan](/sdk/commands/#plan)  
prescribe | [Prescribe](/sdk/commands/#prescribe)  
questionnaire | [Questionnaire](/sdk/commands/#questionnaire)  
reasonForVisit | [ReasonForVisit](/sdk/commands/#reasonforvisit)  
refer | [Refer](/sdk/commands/#refer)  
refill | [Refill](/sdk/commands/#refill)  
removeAllergy | [RemoveAllergy](/sdk/commands/#removeallergy)  
resolveCondition | [ResolveCondition](/sdk/commands/#resolvecondition)  
stopMedication | [StopMedication](/sdk/commands/#stopmedication)  
surgicalHistory | [SurgicalHistory](/sdk/commands/#surgicalhistory)  
task | [Task](/sdk/commands/#task)  
updateDiagnosis | [UpdateDiagnosis](/sdk/commands/#updatediagnosis)  
updateGoal | [UpdateGoal](/sdk/commands/#updategoal)  
vitals | [Vitals](/sdk/commands/#vitals)  
**PLEASE NOTE** the Commands Module is under development and Canvas is working to migrate all commands to be available. This means that some commands are not able to emit events available in plugins, and historical commands created prior to their Commands Module availability may not be able to be queried using the data module. [This product updates table](/product-updates/commands-module/) shows the commands and their release statuses. If a command in a chart is not available by querying the `Command` data model, the data is still available to be queried using corresponding data models (i.e. [Questionnaire](/sdk/data-questionnaire/), [ImagingOrder](/sdk/data-imaging/), etc.).
##  Attributes 
###  Command 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
state | String  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note/#note)  
schema_key | String  
data | JSON  
origination_source | String  
----- END PAGE https://docs.canvasmedical.com/sdk/data-command/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-compound-medication/
##  Introduction 
The `CompoundMedication` model represents a compound medication formulation that can be prescribed to patients. Compound medications are customized medications mixed or prepared by a compounding pharmacy according to a prescription.
##  Basic usage 
To get a compound medication by identifier, use the `get` method on the `CompoundMedication` model manager:
    ```python
    from canvas_sdk.v1.data.compound_medication import CompoundMedication
    compound_medication = CompoundMedication.objects.get(id="123")
    ```
##  Filtering 
Compound medications can be filtered by any attribute that exists on the model.
Filtering for compound medications is done with the `filter` method on the `CompoundMedication` model manager.
###  By attribute 
Specify attributes with `filter` to filter by those attributes:
    ```python
    from canvas_sdk.v1.data.compound_medication import CompoundMedication
    # Get all active compound medications
    active_medications = CompoundMedication.objects.filter(active=True)
    # Get compound medications by formulation
    compound_medications = CompoundMedication.objects.filter(formulation="Testosterone 200mg/mL in Grapeseed Oil")
    # Get all Schedule II controlled substances
    schedule_ii_medications = CompoundMedication.objects.filter(controlled_substance="II")
    # Get compound medications by potency unit
    tablet_medications = CompoundMedication.objects.filter(potency_unit_code="C48542")
    ```
###  Multiple filters 
You can combine multiple filters:
    ```python
    from canvas_sdk.v1.data.compound_medication import CompoundMedication
    # Get active compound medications that are controlled substances
    controlled_active = CompoundMedication.objects.filter(
      active=True,
      controlled_substance__in=["II", "III", "IV", "V"]
    )
    ```
##  Attributes 
###  CompoundMedication 
Field Name | Type  
---|---  
dbid | Integer  
active | Boolean  
formulation | String  
potency_unit_code | PotencyUnit  
controlled_substance | ControlledSubstanceSchedule  
controlled_substance_ndc | String  
##  Enumeration types 
###  PotencyUnit 
Value | Label  
---|---  
C62412 | Applicator  
C54564 | Blister  
C64696 | Caplet  
C48480 | Capsule  
C64933 | Each  
C53499 | Film  
C48155 | Gram  
C69124 | Gum  
C48499 | Implant  
C62276 | Insert  
C48504 | Kit  
C120263 | Lancet  
C48506 | Lozenge  
C28254 | Milliliter  
C48521 | Packet  
C65032 | Pad  
C48524 | Patch  
C120216 | Pen Needle  
C62609 | Ring  
C53502 | Sponge  
C53503 | Stick  
C48538 | Strip  
C48539 | Suppository  
C53504 | Swab  
C48542 | Tablet  
C48548 | Troche  
C38046 | Unspecified  
C48552 | Wafer  
###  ControlledSubstanceSchedule 
Key | Value | Label  
---|---|---  
SCHEDULE_NOT_SCHEDULED | N | None  
SCHEDULE_II | II | Schedule II  
SCHEDULE_III | III | Schedule III  
SCHEDULE_IV | IV | Schedule IV  
SCHEDULE_V | V | Schedule V  
##  Notes 
  - The `formulation` field has a maximum length of 105 characters (as defined by Surescripts).
----- END PAGE https://docs.canvasmedical.com/sdk/data-compound-medication/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-condition/
##  Introduction 
The `Condition` model represents a clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
##  Basic usage 
To get a condition by identifier, use the `get` method on the `Condition` model manager:
    ```python
    from canvas_sdk.v1.data.condition import Condition
    condition = Condition.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the conditions for a patient can be accessed with the `conditions` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    conditions = patient.conditions.all()
    ```
If you have a patient ID, you can get the conditions for the patient with the `for_patient` method on the `Condition` model manager:
    ```python
    from canvas_sdk.v1.data.condition import Condition
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    condition = Condition.objects.for_patient(patient_id)
    ```
##  Codings 
The codings for a condition can be accessed with the `codings` attribute on an `Condition` object:
    ```python
    from canvas_sdk.v1.data.condition import Condition
    from logger import log
    condition = Condition.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in condition.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Filtering 
Conditions can be filtered by any attribute that exists on the model.
Filtering for conditions is done with the `filter` method on the `Condition` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.condition import Condition
    conditions = Condition.objects.filter(onset_date__gte="2024-10-15")
    ```
###  By ValueSet 
Filtering by ValueSet works a little differently. The `find` method on the model manager is used to perform `ValueSet` filtering:
    ```python
    from canvas_sdk.v1.data.condition import Condition
    from canvas_sdk.value_set.v2022.condition import Diabetes
    conditions = Condition.objects.find(Diabetes)
    ```
##  Attributes 
###  Condition 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
deleted | Boolean  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
onset_date | Date  
resolution_date | Date  
clinical_status | ClinicalStatus  
codings | ConditionCoding[]  
lab_order_reason_conditions | [LabOrderReasonConditionCoding](/sdk/data-labs/#laborderreasoncondition)[]  
surgical | Boolean  
###  ConditionCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
condition | Condition  
##  Enumeration types 
###  ClinicalStatus 
Value | Label  
---|---  
active | active  
relapse | relapse  
remission | remission  
resolved | resolved  
investigative | investigative  
----- END PAGE https://docs.canvasmedical.com/sdk/data-condition/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-coverage/
##  Introduction 
The `Coverage` model represents insurance coverage linked to [Patients](/sdk/data-patient/#patient). Coverages are linked to [Patient](/sdk/data-patient/#patient) instances, as well as `Transactor` instances, which represent the issuer for the corresponding coverage. `Coverage`s also have an associated `EligibilitySummary`, which provides the most up-to-date copay and and coinsurance values.
##  Usage 
The `Coverage` model can be used to find all of the coverages defined in a Canvas instance, whether overall or for a particular patient. For example, to find all of the current coverages for a patient, the `Patient.coverages` method can be used:
    ```python
    >>> import arrow
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
    >>> patient_1_current_coverages = patient_1.coverages.filter(coverage_end_date__gt=arrow.now().date().isoformat())
    >>> print([coverage.issuer.name for coverage in patient_1_current_coverages])
    ['AVALON HEALTHCARE SOLUTIONS CAPITAL BLUE CROSS']
    ```
Alternatively, to find all of the `Coverage` instances issed by a particular issuer/transactor, the `Transactor` model can be queried:
    ```python
    >>> from canvas_sdk.v1.data.coverage import Coverage, Transactor
    >>> transactor_1 = Transactor.objects.get(payer_id="AVA03")
    >>> transactor_coverages = Coverage.objects.filter(issuer=transactor_1)
    >>> print(transactor_coverages)
    <QuerySet [<Coverage: id=89793979-dbff-4a53-b928-75db973c2bdc>, <Coverage: id=423c0f77-8083-4cc1-8e29-2c7d348281e4>]>
    >>>
    ```
Find the latest eligibility summary for a patient:
    ```python
        from canvas_sdk.v1.data.coverage import Coverage, EligibilitySummary
        coverage = Coverage.objects.get(id="a74592ae8a6c4d0ebe0799d3fb3713d1")
        elig_summary_from_model = EligibilitySummary.objects.filter(coverage=coverage).first()
        elig_summary_from_cvg = coverage.eligibility_summary
        if elig_summary_from_model:
            print(elig_summary_from_model.copay_cents, elig_summary_from_model.coinsurance) # 1000 5
        if elig_summary_from_cvg:
            print(elig_summary_from_cvg.copay_cents, elig_summary_from_cvg.coinsurance) # 1000 5
    ```
##  Filtering 
The `filter` method can be used to filter by desired attributes. The following examples show commonly used operations to filter coverage data:
**Show a Patient's Coverages in order of Rank (Primary, Secondary, etc.)**
    ```python
    >>> from canvas_sdk.v1.data.patient import Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_coverages = patient_1.coverages.all().order_by("coverage_rank")
    >>> print([(coverage.issuer.name, coverage.coverage_rank,) for coverage in patient_coverages])
    [('AVALON HEALTHCARE SOLUTIONS CAPITAL BLUE CROSS', 1), ('Blue Cross Blue Shield of Arizona Advantage', 2)]
    ```
**Find All Expired Coverages**
    ```python
    >>> import arrow
    >>> from canvas_sdk.v1.data.coverage import Coverage
    >>> expired_coverages = Coverage.objects.filter(coverage_end_date__lt=arrow.now().date().isoformat())
    >>> print([f"{coverage.issuer.name} expired {coverage.coverage_end_date.isoformat()}" for coverage in expired_coverages])
    ['Blue Cross Blue Shield of Arizona Advantage expired 2025-01-10']
    ```
##  Attributes 
###  Coverage 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
guarantor | [Patient](/sdk/data-patient/#patient)  
subscriber | [Patient](/sdk/data-patient/#patient)  
patient_relationship_to_subscriber | CoverageRelationshipCode  
issuer | Transactor  
id_number | String  
plan | String  
sub_plan | String  
group | String  
sub_group | String  
employer | String  
coverage_start_date | Date  
coverage_end_date | Date  
coverage_rank | Integer  
state | CoverageState  
plan_type | CoverageType  
coverage_type | TransactorCoverageType  
issuer_address | TransactorAddress  
issuer_phone | TransactorPhone  
comments | Text  
stack | CoverageStack  
eligibility_summary | EligibilitySummary  
###  Transactor 
Field Name | Type  
---|---  
dbid | Integer  
payer_id | String  
name | String  
type | String  
transactor_type | TransactorType  
clearinghouse_payer | Boolean  
institutional | Boolean  
institutional_enrollment_req | Boolean  
professional | Boolean  
professional_enrollment_req | Boolean  
era | Boolean  
era_enrollment_req | Boolean  
eligibility | Boolean  
eligibility_enrollment_req | Boolean  
workers_comp | Boolean  
secondary_support | Boolean  
claim_fee | Boolean  
remit_fee | Boolean  
state | String  
description | String  
active | Boolean  
use_provider_for_eligibility | Boolean  
use_for_submission | Transactor  
used_for_submission_by | Transactor[]  
coverage_types | TransactorCoverageType[]  
addresses | TransactorAddress[]  
coverages | Coverage[]  
phones | TransactorPhone[]  
###  TransactorAddress 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
line1 | String  
line2 | String  
city | String  
district | String  
state_code | String  
postal_code | String  
use | [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type | [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude | Float  
latitude | Float  
start | Date  
end | Date  
country | String  
state | [AddressState](/sdk/data-enumeration-types/#addressstate)  
transactor | Transactor  
coverages | [Coverage](/sdk/data-coverage/#coverage)[]  
###  TransactorPhone 
Field Name | Type  
---|---  
id | UUIDField  
dbid | Integer  
created | DateTime  
modified | DateTime  
system | String  
value | String  
use | [ContactPointUse](/sdk/data-enumeration-types/#contactpointuse)  
use_notes | String  
rank | Integer  
state | [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
transactor | Transactor  
coverages | [Coverage](/sdk/data-coverage/#coverage)[]  
###  EligibilitySummary 
Field Name | Type  
---|---  
id | UUIDField  
dbid | Integer  
created | DateTime  
modified | DateTime  
coverage | [Coverage](/sdk/data-coverage/#coverage)  
copay_cents | Integer  
coinsurance | Integer  
##  Enumeration types 
###  CoverageStack 
Value | Label  
---|---  
IN_USE | In use  
OTHER | Other  
REMOVED | Removed  
###  CoverageState 
Value | Label  
---|---  
active | Active  
deleted | Deleted  
###  CoverageType 
Value | Label  
---|---  
commercial | Commercial  
workerscomp | Workers Comp  
bcbs | Blue Cross Blue Shield  
champus | Tricare/Champus  
medicaid | Medicaid  
medicare | Medicare  
other | Other  
tpa | Third Party Administrator  
motorvehicle | Motor Vehicle  
lien | Attorney/Lien  
pip | Personal Injury  
###  CoverageRelationshipCode 
Value | Label  
---|---  
18 | Self  
01 | Spouse  
19 | Natural Child, insured has financial responsibility  
43 | Natural Child, insured does not have financial responsibility  
17 | Step Child  
10 | Foster Child  
15 | Ward of the Court  
20 | Employee  
21 | Unknown  
22 | Handicapped Dependent  
39 | Organ donor  
40 | Cadaver donor  
05 | Grandchild  
07 | Niece/Nephew  
41 | Injured Plaintiff  
23 | Sponsored Dependent  
24 | Minor Dependent of a Minor Dependent  
32 | Mother  
33 | Father  
04 | Grandparent  
53 | Life Partner  
29 | Significant Other  
G8 | Other  
###  TransactorCoverageType 
Value | Label  
---|---  
ANNU | annuity policy  
AUTOPOL | automobile  
CHAR | charity program  
COL | collision coverage policy  
CRIME | crime victim program  
DENTAL | dental care policy  
DENTPRG | dental program  
DIS | disability insurance policy  
DISEASE | disease specific policy  
DRUGPOL | drug policy  
EAP | employee assistance program  
EWB | employee welfare benefit plan policy  
ENDRENAL | end renal program  
EHCPOL | extended healthcare  
FLEXP | flexible benefit plan policy  
GOVEMP | government employee health program  
HIP | health insurance plan policy  
HMO | health maintenance organization policy  
HSAPOL | health spending account  
HIRISK | high risk pool program  
HIVAIDS | HIV-AIDS program  
IND | indigenous peoples health program  
LIFE | life insurance policy  
LTC | long term care policy  
MCPOL | managed care policy  
MANDPOL | mandatory health program  
MENTPOL | mental health policy  
MENTPRG | mental health program  
MILITARY | military health program  
pay | Pay  
POS | point of service policy  
PPO | preferred provider organization policy  
PNC | property and casualty insurance policy  
DISEASEPRG | public health program  
PUBLICPOL | public healthcare  
REI | reinsurance policy  
RETIRE | retiree health program  
SAFNET | safety net clinic program  
SOCIAL | social service program  
SUBSIDIZ | subsidized health program  
SUBSIDMC | subsidized managed care program  
SUBSUPP | subsidized supplemental health program  
SUBPOL | substance use policy  
SUBPRG | substance use program  
SURPL | surplus line insurance policy  
TLIFE | term life insurance policy  
UMBRL | umbrella liability insurance policy  
UNINSMOT | uninsured motorist policy  
ULIFE | universal life insurance policy  
VET | veteran health program  
VISPOL | vision care policy  
CANPRG | women's cancer detection program  
WCBPOL | worker's compensation  
###  TransactorType 
Value | Label  
---|---  
commercial | Commercial  
workerscomp | Workers Comp  
champus | Tricare/Champus  
medicaid | Medicaid  
medicare | Medicare  
medicare_advantage | Medicare Advantage  
CHIP | CHIP  
automobile | Automobile  
employer | Employer  
direct_care | Direct Care  
bcbs | Blue Cross Blue Shield
----- END PAGE https://docs.canvasmedical.com/sdk/data-coverage/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-detected-issue/
##  Introduction 
The `DetectedIssue` model represents an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient.
##  Basic usage 
To get a detected issue by identifier, use the `get` method on the `DetectedIssue` model manager:
    ```python
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    detected_issue = DetectedIssue.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the detected issues for a patient can be accessed with the `detected_issues` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    detected_issues = patient.detected_issues.all()
    ```
##  Evidence 
The codings for the evidence of a detected issue can be accessed with the `evidence` attribute on a `DetectedIssue` object:
    ```python
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    from logger import log
    detected_issue = DetectedIssue.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in detected_issue.evidence.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Filtering 
Detected issues can be filtered by any attribute that exists on the model.
Filtering for detected issues is done with the `filter` method on the `DetectedIssue` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.detected_issue import DetectedIssue
    detected_issues = DetectedIssue.objects.filter(status="active")
    ```
##  Attributes 
###  DetectedIssue 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
identified | DateTime  
deleted | Boolean  
originator | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
code | String  
status | String  
severity | String  
reference | String  
issue_identifier | String  
issue_identifier_system | String  
detail | String  
evidence | DetectedIssueEvidence[]  
###  DetectedIssueEvidence 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
detected_issue | [DetectedIssue](/sdk/data-detected-issue/#detectedissue)  
----- END PAGE https://docs.canvasmedical.com/sdk/data-detected-issue/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-device/
##  Introduction 
The `Device` model represents a type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
##  Basic usage 
To get a device by identifier, use the `get` method on the `Device` model manager:
    ```python
    from canvas_sdk.v1.data.device import Device
    device = Device.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the devices for a patient can be accessed with the `devices` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    devices = patient.devices.all()
    ```
##  Filtering 
Devices can be filtered by any attribute that exists on the model.
Filtering for devices is done with the `filter` method on the `Device` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.device import Device
    devices = Device.objects.filter(manufacturer="ACME Biomedical", lot_number="M320")
    ```
##  Attributes 
###  Device 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
note_id | Integer  
deleted | Boolean  
labeled_contains_NRL | Boolean  
assigning_authority | String  
scoping_entity | String  
udi | String  
di | String  
issuing_agency | String  
lot_number | String  
brand_name | String  
mri_safety_status | String  
version_model_number | String  
company_name | String  
gmdnPTName | String  
status | String  
expiration_date | Date  
expiration_date_original | String  
serial_number | String  
manufacturing_date_original | String  
manufacturing_date | Date  
manufacturer | String  
procedure_id | Integer  
----- END PAGE https://docs.canvasmedical.com/sdk/data-device/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-encounter/
##  Introduction 
The `Encounter` model represents a patient encounter connected to a Note in Canvas.
##  Basic usage 
To get an encounter by identifier, use the `get` method on the `Encounter` model manager:
    ```python
    from canvas_sdk.v1.data import Encounter
    encounter = Encounter.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
To get an encounter from a note, use the `encounter` attribute on the `Note` object:
    ```python
    from canvas_sdk.v1.data import Note
    note = Note.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    encounter = note.encounter
    ```
Keep in mind that not all notes have an associated encounter, so sometimes `note.encounter` will be `None`.
Similary, you can get a note from an `Encounter` object by using the `note` attribute:
    ```python
    from canvas_sdk.v1.data import Encounter
    encounter = Encounter.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    note = encounter.note
    ```
All encounters will have an associated note, which means `encounter.note` will never be `None`.
##  Filtering 
Encounters can be filtered by any attribute that exists on the model.
Filtering for encounters is done with the `filter` method on the `Encounter` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.encounter import Encounter, EncounterState
    encounters = Encounter.objects.filter(state=EncounterState.CONCLUDED)
    ```
##  Attributes 
###  Encounter 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
note | [Note](/sdk/data-note/)  
state | EncounterState  
medium | EncounterMedium  
start_time | DateTime  
end_time | DateTime  
##  Enumeration types 
###  EncounterState 
Name | Value  
---|---  
STARTED | STA  
PLANNED | PLA  
CONCLUDED | CON  
CANCELLED | CAN  
###  EncounterMedium 
Name | Value  
---|---  
VOICE | voice  
VIDEO | video  
OFFICE | office  
HOME | home  
OFFSITE | offsite  
LAB | lab  
----- END PAGE https://docs.canvasmedical.com/sdk/data-encounter/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-enumeration-types/
##  Introduction 
This page shows common enumeration types that are used in multiple models.
##  Enumeration types 
###  AddressState 
Value | Label  
---|---  
active | Active  
deleted | Deleted  
###  AddressType 
Value | Label  
---|---  
postal | Postal  
physical | Physical  
both | Both  
###  AddressUse 
Value | Label  
---|---  
home | Home  
work | Work  
temp | Temp  
old | Old  
###  AddressUseWithBilling 
Value | Label  
---|---  
home | Home  
work | Work  
temp | Temp  
old | Old  
billing | Billing  
###  ColorEnum 
Value | Label  
---|---  
red | Red  
orange | Orange  
yellow | Yellow  
olive | Olive  
green | Green  
teal | Teal  
blue | Blue  
violet | Violet  
purple | Purple  
pink | Pink  
brown | Brown  
grey | Grey  
black | Black  
###  ContactPointState 
Value | Label  
---|---  
active | Active  
deleted | Deleted  
###  ContactPointSystem 
Value | Label  
---|---  
phone | phone  
fax | fax  
email | email  
pager | pager  
other | other  
###  ContactPointUse 
Value | Label  
---|---  
home | Home  
work | Work  
temp | Temp  
old | Old  
other | Other  
mobile | Mobile  
automation | Automation  
###  DocumentReviewMode 
Value | Label  
---|---  
RR | Review required  
AR | Already reviewed offline  
RN | Review not required  
###  OrderStatus 
Value | Description  
---|---  
proposed | Proposed  
draft | Draft  
planned | Planned  
requested | Requested  
received | Received  
accepted | Accepted  
in-progress | In-progress  
review | Review  
completed | Completed  
cancelled | Cancelled  
suspended | Suspended  
rejected | Rejected  
failed | Failed  
EIE | Entered in Error  
###  Origin 
Value | Label  
---|---  
REF_CMD | Referral command  
CMP_IMG_ORD | Completing image orders  
IMG_REP_REV | Imaging report review  
LAB_RES_REV | Lab results review  
CON_REP_REV | Consult report review  
UNC_DOC_REP_REV | Uncategorized document report review  
ASN_NOT_PHN_REV | Assigned note/phone call for review  
POP_HLT_OUT | Population health outreach  
CMP_LAB_ORD | Completing lab orders  
CHT_PDF | Chart PDF  
EXP_CLM_SNO | Expired claim snoozed  
FLG_PST_REV | Flagged posting review  
BAT_PTN_STA | Batch patient statements  
INC_COV | Incomplete Coverage  
###  PersonSex 
Value | Label  
---|---  
F | female  
M | male  
O | other  
UNK | unknown  
###  ReviewPatientCommunicationMethod 
Value | Description  
---|---  
DM | delegate call, can leave message  
DA | delegate call, need patient to answer  
DL | delegate letter  
DC | do not communicate  
AM | already left message  
AR | already reviewed with patient  
###  ReviewStatus 
Value | Label  
---|---  
reviewing | reviewing  
reviewed | reviewed  
###  TaxIDType 
Value | Label  
---|---  
E | EIN text  
S | SSN
----- END PAGE https://docs.canvasmedical.com/sdk/data-enumeration-types/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-external-event/
##  Introduction 
The `ExternalEvent` and `ExternalVisit` models represent clinical events from external data sources such as ADT (Admission, Discharge, Transfer) feeds. These models enable tracking of patient encounters that occur outside of Canvas, such as hospital admissions, emergency room visits, or transfers between facilities.
An `ExternalVisit` groups related events for a single patient visit, while `ExternalEvent` represents individual events within that visit (e.g., admission, discharge, transfer).
##  Basic usage 
To get an external event by identifier, use the `get` method on the `ExternalEvent` model manager:
    ```python
    from canvas_sdk.v1.data.external_event import ExternalEvent
    event = ExternalEvent.objects.get(id="b4f8c3a1-2d5e-4f6a-8b9c-1a2b3c4d5e6f")
    ```
To get an external visit:
    ```python
    from canvas_sdk.v1.data.external_event import ExternalVisit
    visit = ExternalVisit.objects.get(id="a1b2c3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d")
    ```
###  Accessing related models 
If you have an external event, you can access the associated visit and patient:
    ```python
    from canvas_sdk.v1.data.external_event import ExternalEvent
    event = ExternalEvent.objects.get(id="b4f8c3a1-2d5e-4f6a-8b9c-1a2b3c4d5e6f")
    # Access the parent visit
    visit = event.external_visit
    # Access the patient
    patient = event.patient
    ```
If you have an external visit, you can access all events within that visit:
    ```python
    from canvas_sdk.v1.data.external_event import ExternalVisit
    visit = ExternalVisit.objects.get(id="a1b2c3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d")
    # Get all events in this visit
    events = visit.visit_events.all()
    ```
If you have a patient object, you can access their external events and visits:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    # Get all external events for this patient
    events = patient.patient_events.all()
    # Get all external visits for this patient
    visits = patient.patient_visits.all()
    ```
##  Filtering 
External events and visits can be filtered by any attribute that exists on the model.
###  By patient 
    ```python
    from canvas_sdk.v1.data.external_event import ExternalEvent, ExternalVisit
    # Get all events for a specific patient
    events = ExternalEvent.objects.filter(patient__id="1eed3ea2a8d546a1b681a2a45de1d790")
    # Get all visits for a specific patient
    visits = ExternalVisit.objects.filter(patient__id="1eed3ea2a8d546a1b681a2a45de1d790")
    ```
###  By event type 
    ```python
    from canvas_sdk.v1.data.external_event import ExternalEvent
    # Get all admission events
    admissions = ExternalEvent.objects.filter(event_type="ADT^A01")
    # Get all discharge events
    discharges = ExternalEvent.objects.filter(event_type="ADT^A03")
    ```
###  By cancelled status 
    ```python
    from canvas_sdk.v1.data.external_event import ExternalEvent
    # Get all non-cancelled events
    active_events = ExternalEvent.objects.filter(event_cancelation_datetime__isnull=True)
    # Get all cancelled events
    cancelled_events = ExternalEvent.objects.filter(event_cancelation_datetime__isnull=False)
    ```
###  By visit identifier 
    ```python
    from canvas_sdk.v1.data.external_event import ExternalVisit
    visit = ExternalVisit.objects.get(visit_identifier="VISIT-12345")
    ```
###  By facility 
    ```python
    from canvas_sdk.v1.data.external_event import ExternalVisit
    visits = ExternalVisit.objects.filter(facility_name="General Hospital")
    ```
##  Attributes 
###  ExternalEvent 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
external_visit | ExternalVisit  
patient | [Patient](/sdk/data-patient/#patient)  
message_control_id | String  
message_datetime | DateTime  
event_type | String  
event_datetime | DateTime  
event_cancelation_datetime | DateTime  
raw_message | String  
cancelled | Boolean (property)  
###  ExternalVisit 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
visit_identifier | String  
information_source | String  
facility_name | String  
##  Common Event Types 
External events typically use HL7 ADT event types:
Event Type | Description  
---|---  
ADT^A01 | Admit/Visit Notification  
ADT^A02 | Transfer a Patient  
ADT^A03 | Discharge/End Visit  
ADT^A04 | Register a Patient  
ADT^A08 | Update Patient Information  
ADT^A11 | Cancel Admit/Visit Notification  
ADT^A12 | Cancel Transfer  
ADT^A13 | Cancel Discharge/End Visit  
    ```python
    from canvas_sdk.v1.data.external_event import ExternalEvent
    from logger import log
    # Get recent events for a patient and log their types
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    events = ExternalEvent.objects.filter(patient__id=patient_id).order_by("-event_datetime")[:10]
    for event in events:
        status = "CANCELLED" if event.cancelled else "ACTIVE"
        log.info(f"Event: {event.event_type} at {event.event_datetime} [{status}]")
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/data-external-event/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-facility/
##  Introduction 
The `Facility` object represents a healthcare facility associated with patients within Canvas. Facilities can include hospitals, clinics, or other healthcare institutions where patients receive care. This object contains essential information about the facility, such as its address, contact details, and operational status.
##  Basic Usage 
To get a facility by identifier, use the `get` method on the `Facility` model manager:
    ```python
    from canvas_sdk.v1.data.facility import Facility
    facility = Facility.objects.get(id="34b50dfa-1b3e-4dc2-a11d-41b3115c29f3")
    ```
##  Filtering 
Facilities can be filtered by any attribute that exists on the model.
Filtering for facilities is done with the `filter` method on the `Facility` model manager.
##  Attributes 
Specify attributes with `filter` to filter by those attributes:
    ```python
    from canvas_sdk.v1.data.facility import Facility
    facilities = Facility.objects.filter(name="General Hospital", city="Metropolis")
    ```
###  Facility 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
line1 | String  
line2 | String  
city | String  
district | String  
state_code | String  
postal_code | String  
name | String  
npi_number | String  
phone_number | String  
fax_number | String  
active | Boolean
----- END PAGE https://docs.canvasmedical.com/sdk/data-facility/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-goal/
##  Introduction 
The `Goal` model represents a patient Goal in Canvas, which is always associated with a Note and a Patient.
##  Basic usage 
To get a goal by identifier, use the `get` method on the `Goal` model manager:
    ```python
    from canvas_sdk.v1.data.goal import Goal
    goal = Goal.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, or note object, the goals for a patient or note can be accessed with the `goals` attribute on a `Patient` or `Note` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.v1.data.note import Note
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    goals = patient.goals.all()
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    goals = note.goals.all()
    ```
##  Filtering 
Goals can be filtered by any attribute that exists on the model.
Filtering for goals is done with the `filter` method on the `Goal` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.goal import Goal, GoalAchievementStatus
    goals = Goal.objects.filter(achievement_status=GoalAchievementStatus.IN_PROGRESS)
    ```
##  Attributes 
###  Goal 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note)  
lifecycle_status | GoalLifecycleStatus  
achievement_status | GoalAchievementStatus  
priority | GoalPriority  
due_date | Date  
start_date | Date  
progress | String  
goal_statement | String  
##  Enumeration types 
###  GoalLifecycleStatus 
Name | Value  
---|---  
PROPOSED | proposed  
PLANNED | planned  
ACCEPTED | accepted  
ACTIVE | active  
ON_HOLD | on-hold  
COMPLETED | completed  
CANCELLED | cancelled  
REJECTED | rejected  
###  GoalAchievementStatus 
Name | Value  
---|---  
IN_PROGRESS | in-progress  
IMPROVING | improving  
WORSENING | worsening  
NO_CHANGE | no-change  
ACHIEVED | achieved  
SUSTAINING | sustaining  
NOT_ACHIEVED | not-achieved  
NO_PROGRESS | no-progress  
NOT_ATTAINABLE | not-attainable  
###  GoalPriority 
Name | Value  
---|---  
HIGH | high-priority  
MEDIUM | medium-priority  
LOW | low-priority  
----- END PAGE https://docs.canvasmedical.com/sdk/data-goal/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-imaging/
##  Introduction 
The `ImagingOrder`, `ImagingReview` and `ImagingReport` models represent imaging results.
##  Basic Usage 
To retrieve an `ImagingOrder`, `ImagingReview`, or `ImagingReport` by identifier, use the `get` method on the model manager:
    ```python
    from canvas_sdk.v1.data.imaging import ImagingOrder, ImagingReview, ImagingReport
    imaging_order = ImagingOrder.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    imaging_review = ImagingReview.objects.get(id="c02c6b02-2581-46bf-819c-b5aacad2134c")
    imaging_report = ImagingReport.objects.get(id="c1a5a35a-4ee2-4a0e-85c0-21739dc8c4a8")
    ```
If you have a patient object, the orders, reviews, and reports can be accessed with the `imaging_orders`, `imaging_reviews`, and `imaging_results` attributes, respectively on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    orders = patient.imaging_orders.all()
    reviews = patient.imaging_reviews.all()
    reports = patient.imaging_results.all()
    ```
##  Filtering 
Imaging orders, reviews, and reports can be filtered by any attribute that exists on the models.
Filtering is done with the `filter` method on the `ImagingOrder`, `ImagingReview`, and `ImagingReport` model managers.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.imaging import ImagingOrder, ImagingReview, ImagingReport
    orders = ImagingOrder.objects.filter(status="completed")
    reviews = ImagingReview.objects.filter(is_released_to_patient=False)
    reports = ImagingReport.objects.filter(requires_signature=True)
    ```
##  Related Tasks 
To retrieve an Imaging Order's related tasks, use the `get_task_objects` method on the ImagingOrder object.
    ```python
    from canvas_sdk.v1.data.imaging import ImagingOrder
    imaging_order = ImagingOrder.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    tasks = imaging_order.get_task_objects().all()
    ```
##  Attributes 
###  ImagingOrder 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note/#note)  
imaging | String  
imaging_center | [ServiceProvider](/sdk/data-serviceprovider/#service-provider)  
note_to_radiologist | String  
internal_comment | String  
status | [OrderStatus](/sdk/data-enumeration-types/#orderstatus)  
date_time_ordered | DateTime  
ordering_provider | [Staff](/sdk/data-staff/#staff)  
priority | String  
delegated | Boolean  
task_ids | String  
###  ImagingReview 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
patient_communication_method | [ReviewPatientCommunicationMethod](/sdk/data-enumeration-types/#reviewpatientcommunicationmethod)  
internal_comment | String  
message_to_patient | String  
is_released_to_patient | Boolean  
status | [ReviewStatus](/sdk/data-enumeration-types/#reviewstatus)  
patient | [Patient](/sdk/data-patient/#patient)  
###  ImagingReport 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
review_mode | [DocumentReviewMode](/sdk/data-enumeration-types/#documentreviewmode)  
junked | Boolean  
requires_signature | Boolean  
assigned_date | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
order | ImagingOrder  
source | ImagingReportSource  
name | String  
result_date | Date  
original_date | Date  
review | ImagingReview  
##  Enumeration types 
###  ImagingReportSource 
Value | Label  
---|---  
RADIOLOGY_PATIENT | Radiology Report From Patient  
VERBAL_PATIENT | Verbal Report From Patient  
DIRECTLY_RADIOLOGY | Directly Radiology Report  
----- END PAGE https://docs.canvasmedical.com/sdk/data-imaging/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-immunization/
##  Introduction 
The `Immunization` model represents a record of immunization events and immunization statements for a patient. Immunizations can be actively administered medications or historical records of immunizations received elsewhere. The `ImmunizationStatement` model represents historical immunization records and vaccination history.
##  Basic usage 
To get an immunization by identifier, use the `get` method on the `Immunization` model manager:
    ```python
    from canvas_sdk.v1.data.immunization import Immunization
    immunization = Immunization.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the immunizations for a patient can be accessed with the `immunizations` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    immunizations = patient.immunizations.all()
    ```
If you have a patient ID, you can get the immunizations for the patient with the `for_patient` method on the `Immunization` model manager:
    ```python
    from canvas_sdk.v1.data.immunization import Immunization
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    immunizations = Immunization.objects.for_patient(patient_id)
    ```
##  Codings 
The codings for an immunization can be accessed with the `codings` attribute on an `Immunization` object:
    ```python
    from canvas_sdk.v1.data.immunization import Immunization
    from logger import log
    immunization = Immunization.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in immunization.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Filtering 
Immunizations can be filtered by any attribute that exists on the model.
Filtering for immunizations is done with the `filter` method on the `Immunization` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.immunization import Immunization
    immunizations = Immunization.objects.filter(status="completed")
    ```
###  By ValueSet 
Filtering by ValueSet works a little differently. The `find` method on the model manager is used to perform `ValueSet` filtering:
    ```python
    from canvas_sdk.v1.data.immunization import Immunization
    from canvas_sdk.value_set.v2022.immunization import InfluenzaVaccine
    immunizations = Immunization.objects.find(InfluenzaVaccine)
    ```
##  Immunization Statements 
To work with immunization statements (historical records), use the `ImmunizationStatement` model:
    ```python
    from canvas_sdk.v1.data.immunization import ImmunizationStatement
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    immunization_statements = ImmunizationStatement.objects.for_patient(patient_id)
    ```
##  Attributes 
###  Immunization 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note/#note)  
status | ImmunizationStatus  
lot_number | String  
manufacturer | String  
exp_date_original | String  
exp_date | Date  
sig_original | String  
date_ordered | Date  
given_by | [Staff](/sdk/data-staff/#staff)  
consent_given | Boolean  
take_quantity | Float  
dose_form | String  
route | String  
frequency_normalized_per_day | Float  
deleted | Boolean  
codings | ImmunizationCoding[]  
###  ImmunizationCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
immunization | Immunization  
###  ImmunizationStatement 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note/#note)  
date_original | String  
date | Date  
evidence | String  
comment | String  
reason_not_given | ImmunizationReasonsNotGiven  
deleted | Boolean  
coding | ImmunizationStatementCoding[]  
###  ImmunizationStatementCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
immunization_statement | ImmunizationStatement  
##  Enumeration types 
###  ImmunizationStatus 
Value | Label  
---|---  
in-progress | In Progress  
on-hold | on-hold  
completed | completed  
stopped | stopped  
###  ImmunizationReasonsNotGiven 
Value | Label  
---|---  
NA | not applicable  
IMMUNE | immunity  
MEDPREC | medical precaution  
OSTOCK | product out of stock  
PATOBJ | patient objection  
----- END PAGE https://docs.canvasmedical.com/sdk/data-immunization/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-lab-partner-and-test/
##  Introduction 
The **LabPartner** and **LabPartnerTest** models represent external lab partners and the tests they offer within Canvas.
* * *
##  LabPartner 
The `LabPartner` model stores information about a lab partner
###  Basic Usage 
To retrieve a lab partner by its unique identifier:
    ```python
    from canvas_sdk.v1.data.lab import LabPartner
    lab_partner = LabPartner.objects.get(id="your-uuid-here")
    ```
You can also filter lab partners by attributes. For example, to list all active lab partners:
    ```python
    from canvas_sdk.v1.data.lab import LabPartner
    active_lab_partners = LabPartner.objects.filter(active=True)
    ```
##  LabPartnerTest 
The `LabPartnerTest` model represents a test offered by a lab partner. Each test is linked to a lab partner via a foreign key.
###  Basic Usage 
To retrieve tests for a given lab partner, you can access the related tests using the reverse relationship:
    ```python
    from canvas_sdk.v1.data.lab import LabPartner
    lab_partner = LabPartner.objects.get(id="your-uuid-here")
    tests = lab_partner.available_tests.all()
    ```
Alternatively, you can directly filter tests by attributes:
    ```python
    from canvas_sdk.v1.data.lab import LabPartnerTest
    tests_with_code = LabPartnerTest.objects.filter(order_code="XYZ123")
    ```
##  Attributes 
###  LabPartner 
Field Name | Type | Description  
---|---|---  
id | UUID | The universally unique identifier for the lab partner.  
dbid | Integer | The internal database identifier (primary key) for the lab partner.  
name | String | The name of the lab partner.  
active | Boolean | Indicates whether the lab partner is currently active.  
electronic_ordering_enabled | Boolean | Indicates if electronic ordering is enabled for this lab partner.  
keywords | Text | Keywords associated with the lab partner.  
default_lab_account_number | String | The default lab account number used for orders.  
###  LabPartnerTest Attributes 
Field Name | Type | Description  
---|---|---  
id | UUID | The universally unique identifier for the test record.  
dbid | Integer | The internal database identifier (primary key) for the test record.  
lab_partner | ForeignKey | A reference to the related `LabPartner` (accessible via the related name `available_tests`).  
order_code | String | A code used to identify the test order. May be blank.  
order_name | Text | The name of the test order.  
keywords | Text | Keywords associated with the test. May be blank.  
cpt_code | String | The CPT code for the test, if available. Can be blank or null.  
----- END PAGE https://docs.canvasmedical.com/sdk/data-lab-partner-and-test/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-labs/
##  Introduction 
The Canvas SDK provides comprehensive models for working with laboratory data throughout the entire lab workflow—from ordering tests to reviewing results. The primary models include:
  - **`LabOrder`** : Represents a lab order placed for a patient, including order details, transmission type, and associated tests
  - **`LabTest`** : Individual tests within a lab order, tracking status from creation through processing
  - **`LabReport`** : Contains the results returned from the lab, including all values and associated metadata
  - **`LabValue`** : Individual test results within a lab report, including values, units, and reference ranges
  - **`LabReview`** : Tracks the clinical review process for lab results, including provider comments and patient communication
##  Basic Usage 
To retrieve a `LabReport` model by id, use the `objects.get` method on the model. For example:
    ```python
    from canvas_sdk.v1.data.lab import LabReport
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    ```
##  Filtering 
To retrieve the `LabValue` instances that are associated with the `LabReport`, you can either call the `values` on the `LabReport` instance:
    ```python
    from canvas_sdk.v1.data.lab import LabReport
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = lab_report.values.all()
    ```
Or query the `LabValue` model and pass the `report` argument:
    ```python
    from canvas_sdk.v1.data.lab import LabReport, LabValue
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = LabValue.objects.filter(lab_report=lab_report)
    ```
Additionally, codings for lab values can be attained by querying the `LabValueCoding` model. To retrieve the codings associated with a `LabValue`, you can call `codings` on the `LabValue` instance:
    ```python
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport, LabValue
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = LabValue.objects.filter(lab_report=lab_report)
    for value in lab_values:
        log.info(value.codings.all())
    ```
Or query the `LabValueCoding` model directly:
    ```python
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport, LabValue, LabValueCoding
    lab_report = LabReport.objects.get(id="bcd287b7-8b04-4540-a1ea-6529eb576565")
    lab_values = LabValue.objects.filter(lab_report=lab_report)
    for value in lab_values:
        lab_value_codings = LabValueCoding.objects.filter(value=value)
        log.info(lab_value_codings)
    ```
To query all lab reports for a particular patient, the `patient` argument can be used:
    ```python
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    lab_report = LabReport.objects.filter(patient=patient)
    ```
##  Example 
The following plugin code will run every time a new Lab Report is created and log the patient it is for, along with the values and codings from the report's results:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    from canvas_sdk.v1.data.lab import LabReport
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.LAB_REPORT_CREATED)
        def compute(self):
            lab_report = LabReport.objects.select_related("patient").get(id=self.target)
            if lab_report.patient:
                log.info(f"{lab_report.patient.first_name} {lab_report.patient.last_name}")
            for value in lab_report.values.all():
                log.info(f"{value.value} {value.units}")
                for coding in value.codings.all():
                    log.info(coding.system)
                    log.info(coding.name)
                    log.info(coding.code)
            return []
    ```
For complete field documentation on all lab models, see the Attributes section below.
###  Working with Lab Orders and Tests 
You can also work with lab orders and their associated tests. Here's an example of querying a lab order and checking the status of its tests:
    ```python
    from canvas_sdk.v1.data.lab import LabOrder, LabTest
    # Get a lab order by ID
    lab_order = LabOrder.objects.get(id="abc123...")
    # Access all tests in the order
    for test in lab_order.tests.all():
        print(f"Test: {test.ontology_test_name}")
        print(f"Status: {test.status}")
        print(f"Code: {test.ontology_test_code}")
        # Check if results have been received
        if test.report:
            print(f"Report available with {test.report.values.count()} values")
    ```
###  Navigating Between Lab Orders and Reports 
Lab orders and lab reports are connected through the `LabTest` model. Here's how to navigate between them:
####  Getting the LabOrder from a LabReport 
    ```python
    from canvas_sdk.v1.data.lab import LabReport
    # Get a lab report
    lab_report = LabReport.objects.get(id="report-id")
    # Direct access to all orders via the reverse many-to-many relationship
    for lab_order in lab_report.laborder_set.all():
        print(f"Order ID: {lab_order.id}")
        print(f"Ordered by: {lab_order.ordering_provider.full_name if lab_order.ordering_provider else 'N/A'}")
        print(f"Date ordered: {lab_order.date_ordered}")
    # Alternatively, access the order through the tests
    for test in lab_report.tests.all():
        lab_order = test.order
        print(f"Order ID: {lab_order.id}")
        break  # Usually all tests in a report share the same order
    ```
####  Getting LabReports from a LabOrder 
    ```python
    from canvas_sdk.v1.data.lab import LabOrder
    # Get a lab order
    lab_order = LabOrder.objects.get(id="order-id")
    # Direct access to all reports via the many-to-many relationship
    for report in lab_order.reports.all():
        print(f"Report ID: {report.id}")
        print(f"Date performed: {report.date_performed}")
        print(f"Number of values: {report.values.count()}")
    # Alternatively, access reports through the tests if you need test-level details
    for test in lab_order.tests.all():
        if test.report:
            print(f"Test: {test.ontology_test_name}")
            print(f"Report ID: {test.report.id}")
    ```
###  Working with Lab Reviews 
Lab reviews track the clinical review process for lab results, including provider comments and patient communication. Here's how to work with the LabReport and LabReview relationship:
####  Accessing the Review from a LabReport 
    ```python
    from canvas_sdk.v1.data.lab import LabReport
    # Get a lab report
    lab_report = LabReport.objects.get(id="report-id")
    # Check if the report has been reviewed
    if lab_report.review:
        lab_review = lab_report.review
        print(f"Review status: {lab_review.status}")
        print(f"Internal comment: {lab_review.internal_comment}")
        print(f"Message to patient: {lab_review.message_to_patient}")
        # Access the provider who reviewed it
        if lab_review.originator:
            print(f"Reviewed by: {lab_review.originator.full_name}")
    else:
        print("Report has not been reviewed yet")
    ```
####  Accessing Reports from a LabReview 
    ```python
    from canvas_sdk.v1.data.lab import LabReview
    # Get a lab review
    lab_review = LabReview.objects.get(id="review-id")
    # Access all reports in this review batch
    for report in lab_review.reports.all():
        print(f"Report ID: {report.id}")
        print(f"Date performed: {report.date_performed}")
        print(f"Number of values: {report.values.count()}")
        # Check if this report requires signature
        if report.requires_signature:
            print("  ⚠️  Requires provider signature")
    ```
####  Finding Unreviewed Lab Reports 
    ```python
    from canvas_sdk.v1.data.lab import LabReport
    from canvas_sdk.v1.data.patient import Patient
    # Get all unreviewed lab reports for a patient
    patient = Patient.objects.get(id="patient-id")
    unreviewed_reports = LabReport.objects.filter(
        patient=patient,
        review__isnull=True,
        deleted=False
    )
    print(f"Found {unreviewed_reports.count()} unreviewed reports")
    for report in unreviewed_reports:
        print(f"Report from {report.date_performed} - {report.values.count()} values")
    ```
###  Filtering Lab Results by Abnormal Values 
A common use case is to identify abnormal lab values that may require clinical attention:
    ```python
    from canvas_sdk.v1.data.lab import LabReport, LabValue
    from canvas_sdk.v1.data.patient import Patient
    # Get all lab reports for a patient
    patient = Patient.objects.get(id="patient-id")
    lab_reports = LabReport.objects.filter(patient=patient)
    # Find all abnormal values
    for report in lab_reports:
        abnormal_values = report.values.filter(abnormal_flag__isnull=False).exclude(abnormal_flag="")
        if abnormal_values.exists():
            print(f"Report from {report.date_performed}:")
            for value in abnormal_values:
                for coding in value.codings.all():
                    print(f"  {coding.name}: {value.value} {value.units} (Flag: {value.abnormal_flag})")
    ```
##  Attributes 
###  LabReport 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
review_mode | String  
junked | Boolean  
requires_signature | Boolean  
assigned_date | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
transmission_type | TransmissionType  
for_test_only | Boolean  
external_id | String  
version | Integer  
requisition_number | String  
review | LabReview  
original_date | DateTime  
date_performed | DateTime  
custom_document_name | String  
originator | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
values | LabValue[]  
###  LabReview 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
internal_comment | String  
message_to_patient | String  
status | String  
patient | [Patient](/sdk/data-patient/#patient)  
patient_communication_method | String  
reports | LabReport[]  
tests | LabTest[]  
###  LabValue 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
report | LabReport  
value | String  
units | String  
abnormal_flag | String  
reference_range | String  
low_threshold | String  
high_threshold | String  
comment | String  
observation_status | String  
codings | LabValueCoding[]  
###  LabValueCoding 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
value | LabValue  
code | String  
name | String  
system | String  
###  LabOrder 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note/#note)  
ontology_lab_partner | String  
ordering_provider | [Staff](/sdk/data-staff/#staff)  
comment | String  
requisition_number | String  
is_patient_bill | Boolean  
date_ordered | DateTime  
fasting_status | Boolean  
specimen_collection_type | SpecimenCollectionType  
transmission_type | TransmissionType  
courtesy_copy_type | CourtesyCopyType  
courtesy_copy_number | String  
courtesy_copy_text | String  
parent_order | LabOrder  
healthgorilla_id | String  
manual_processing_status | ManualProcessingStatus  
manual_processing_comment | String  
labcorp_abn_url | URL  
reasons | LabOrderReason[]  
tests | LabTest[]  
reports | LabReport[]  
###  LabOrderReason 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
order | LabOrder  
mode | LabReasonMode  
reason_conditions | LabOrderReasonCondition[]  
###  LabOrderReasonCondition 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
reason | LabOrderReason  
condition | [Condition](/sdk/data-condition)  
###  LabTest 
Represents an individual test within a lab order. Each `LabTest` tracks the lifecycle of a specific test from order creation through processing and result receipt.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
ontology_test_name | String  
ontology_test_code | String  
status | LabTestOrderStatus  
report | LabReport  
specimen_type | String  
specimen_source_code | String  
specimen_source_description | String  
specimen_source_coding_system | String  
order | LabOrder  
aoe_code | String  
procedure_class | String  
##  Enumeration types 
###  TransmissionType 
Value | Label  
---|---  
F | fax  
H | hl7  
M | manual  
###  SpecimenCollectionType 
Value | Label  
---|---  
L | on location  
P | patient service center  
O | other  
###  CourtesyCopyType 
Value | Label  
---|---  
A | account  
F | fax  
P | patient  
###  ManualProcessingStatus 
Value | Label  
---|---  
NEEDS_REVIEW | Needs Review  
IN_PROGRESS | In Progress  
PROCESSED | Processed  
FLAGGED | Flagged  
###  LabReasonMode 
Value | Label  
---|---  
MO | monitor  
IN | investigate  
SF | screen for  
UNK | unknown  
###  LabTestOrderStatus 
Value | Label  
---|---  
NE | new  
SR | staged for requisition  
SE | sending  
SF | sending failed  
PR | processing  
PF | processing failed  
RE | received  
RV | reviewed  
IN | inactive  
----- END PAGE https://docs.canvasmedical.com/sdk/data-labs/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-letter/
##  Introduction 
The `Letter` model represents patient correspondence letters created within Canvas. Letters are associated with a [Note](/sdk/data-note/) and contain rendered content that can be printed or sent to patients.
##  Basic Usage 
###  Retrieve a specific letter 
To get a letter by identifier, use the `get` method on the `Letter` model manager:
    ```python
    from canvas_sdk.v1.data.letter import Letter
    letter = Letter.objects.get(id="b5a0c1d2-e3f4-5678-9abc-def012345678")
    ```
###  Find a letter for a specific note 
If you have a note object, you can access its associated letter using the `letter` attribute:
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    letter = note.letter
    ```
###  Find all letters created by a staff member 
If you have a staff object, you can find all letters they created using the `letters` attribute:
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="a1b2c3d4e5f6")
    staff_letters = staff.letters.all()
    ```
##  Filtering 
Letters can be filtered by any attribute that exists on the model.
###  By attribute 
Filtering for letters is done with the `filter` method on the `Letter` model manager:
    ```python
    from canvas_sdk.v1.data.letter import Letter
    # Find all printed letters
    printed_letters = Letter.objects.filter(printed__isnull=False)
    # Find letters created by a specific staff member
    staff_letters = Letter.objects.filter(staff_id="a1b2c3d4e5f6")
    ```
##  Attributes 
###  Letter 
Field Name | Type | Notes  
---|---|---  
id | UUID |   
dbid | Integer |   
created | DateTime |   
modified | DateTime |   
content | String | The rendered letter content  
printed | DateTime | When the letter was printed (null if not printed)  
note | [Note](/sdk/data-note/) | The note this letter is associated with  
staff | [Staff](/sdk/data-staff/#staff) | The staff member who created the letter (nullable)
----- END PAGE https://docs.canvasmedical.com/sdk/data-letter/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-medication-history/
##  Introduction 
The `MedicationHistoryMedication` model represents historical medication data for a patient, typically imported from external sources such as health information exchanges or pharmacy systems. The `MedicationHistoryResponse` model tracks responses to medication history requests.
##  Basic usage 
To get a medication history record by identifier, use the `get` method on the `MedicationHistoryMedication` model manager:
    ```python
    from canvas_sdk.v1.data.medication_history import MedicationHistoryMedication
    medication_history = MedicationHistoryMedication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the medication history for a patient can be accessed with the `medication_history_medications` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    medication_history = patient.medication_history_medications.all()
    ```
##  Codings 
The codings for a medication history record can be accessed with the `codings` attribute on a `MedicationHistoryMedication` object:
    ```python
    from canvas_sdk.v1.data.medication_history import MedicationHistoryMedication
    from logger import log
    medication_history = MedicationHistoryMedication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in medication_history.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Filtering 
Medication history records can be filtered by any attribute that exists on the model.
Filtering is done with the `filter` method on the `MedicationHistoryMedication` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.medication_history import MedicationHistoryMedication
    medications = MedicationHistoryMedication.objects.filter(dea_schedule="CII")
    ```
###  By date range 
Filter by last fill date or written date:
    ```python
    from canvas_sdk.v1.data.medication_history import MedicationHistoryMedication
    from datetime import datetime
    medications = MedicationHistoryMedication.objects.filter(
        last_fill_date__gte=datetime(2023, 1, 1)
    )
    ```
##  Attributes 
###  MedicationHistoryMedication 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
drug_description | String  
strength_value | String  
strength_form | String  
strength_unit_of_measure | String  
quantity | Float  
quantity_unit_of_measure | String  
quantity_code_list_qualifier | String  
days_supply | Integer  
last_fill_date | DateTime  
written_date | DateTime  
other_date | DateTime  
other_date_qualifier | String  
substitutions | Boolean  
refills_remaining | Integer  
diagnosis_code | String  
diagnosis_qualifier | String  
diagnosis_description | String  
secondary_diagnosis_code | String  
secondary_diagnosis_qualifier | String  
secondary_diagnosis_description | String  
dea_schedule | String  
potency_unit_code | String  
etc_path_id | Array[Integer]  
etc_path_name | Array[String]  
fill_number | Integer  
prescriber_order_number | String  
source_description | String  
source_qualifier | String  
source_payer_id | String  
source_type | String  
note | String  
sig | String  
prior_authorization_status | String  
prior_authorization | String  
pharmacy_name | String  
pharmacy_ncpdp_id | String  
pharmacy_npi | String  
prescriber_business_name | String  
prescriber_first_name | String  
prescriber_last_name | String  
prescriber_npi | String  
prescriber_dea_number | String  
codings | MedicationHistoryMedicationCoding[]  
###  MedicationHistoryMedicationCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
medication | MedicationHistoryMedication  
###  MedicationHistoryResponse 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
staff | [Staff](/sdk/data-staff/#staff)  
message_id | String  
related_to_message_id | String  
status | MedicationHistoryResponseStatus  
reason | String  
reason_code | String  
note | String  
start_date | Date  
end_date | Date  
##  Enumeration types 
###  MedicationHistoryResponseStatus 
Value | Label  
---|---  
approved | approved  
denied | denied  
----- END PAGE https://docs.canvasmedical.com/sdk/data-medication-history/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-medication-statement/
##  Introduction 
The `MedicationStatement` model represents a record of a medication statement by a patient from the past.
##  Basic usage 
To get a medication statement by identifier, use the `get` method on the `MedicationStatement` model manager:
    ```python
    from canvas_sdk.v1.data import MedicationStatement
    medication_statement = MedicationStatement.objects.get(id="61a1853f-168f-4ed3-80d2-44e5d144bcf3")
    ```
If you have a patient object, the medication statements for a patient can be accessed with the `medication_statements` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    medication_statements = patient.medication_statements.all()
    ```
You can also access the referenced medication with the `medication` attribute:
    ```python
    from canvas_sdk.v1.data import MedicationStatement
    medication_statement = MedicationStatement.objects.get(id="61a1853f-168f-4ed3-80d2-44e5d144bcf3")
    medication = medication_statement.medication
    ```
Or for a given medication, you can access all medication statements:
    ```python
    from canvas_sdk.v1.data import Medication
    medication = Medication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    medication_statements = medication.medication_statements.all()
    ```
##  Attributes 
###  MedicationStatement 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note)  
medication | [Medication](/sdk/data-medication)  
indications | [Assessment](/sdk/data-assessment)[]  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
originator | [CanvasUser](/sdk/data-canvasuser)  
created | DateTime  
modified | DateTime  
start_date_original_input | String  
start_date | Date  
end_date_original_input | String  
end_date | Date  
dose_quantity | Number  
dose_form | String  
dose_route | String  
dose_frequency | Number  
dose_frequency_interval | String  
sig_original_input | String  
----- END PAGE https://docs.canvasmedical.com/sdk/data-medication-statement/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-medication/
##  Introduction 
The `Medication` model represents a record of a medication that is being consumed by a patient, either now, in the past, or in the future. `Medication` records can represent both prescriptions and medication statements for a patient.
##  Basic usage 
To get a medication by identifier, use the `get` method on the `Medication` model manager:
    ```python
    from canvas_sdk.v1.data.medication import Medication
    medication = Medication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the medications for a patient can be accessed with the `medications` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    medications = patient.medications.all()
    ```
If you have a patient ID, you can get the medications for the patient with the `for_patient` method on the `Medication` model manager:
    ```python
    from canvas_sdk.v1.data.medication import Medication
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    medication = Medication.objects.for_patient(patient_id)
    ```
#  Codings 
The codings for a medication can be accessed with the `codings` attribute on an `Medication` object:
    ```python
    from canvas_sdk.v1.data.medication import Medication
    from logger import log
    medication = Medication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in medication.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Filtering 
Medications can be filtered by any attribute that exists on the model.
Filtering for medications is done with the `filter` method on the `Medication` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.medication import Medication
    medications = Medication.objects.filter(status="active")
    ```
###  By ValueSet 
Filtering by ValueSet works a little differently. The `find` method on the model manager is used to perform `ValueSet` filtering:
    ```python
    from canvas_sdk.v1.data.medication import Medication
    from canvas_sdk.value_set.v2022.medication import AdhdMedications
    medications = Medication.objects.find(AdhdMedications)
    ```
##  Attributes 
###  Medication 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
patient | [Patient](/sdk/data-patient/#patient)  
deleted | Boolean  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
status | String  
start_date | Date  
end_date | Date  
quantity_qualifier_description | String  
clinical_quantity_description | String  
potency_unit_code | String  
national_drug_code | String  
erx_quantity | String  
codings | MedicationCoding[]  
medication_statements | [MedicationStatement](/sdk/data-medication-statement)[]  
stopmedicationevent_set | [StopMedicationEvent](/sdk/data-stop-medication-event)[]  
###  MedicationCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
medication | Medication  
----- END PAGE https://docs.canvasmedical.com/sdk/data-medication/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-message/
#  Message Models 
The Canvas SDK defines messaging-related data models for sending, receiving, and tracking messages.
##  TransmissionChannel 
A `TextChoices` enum representing the available channels for transmitting messages.
Member | Value | Description  
---|---|---  
`MANUAL` | `manual` | Manual  
`TEXT_MESSAGE` | `sms` | Text Message  
`EMAIL` | `email` | Email  
`NOOP` | `noop` | No-op  
##  Message 
Represents an individual message record.
###  Fields 
Name | Type | Description  
---|---|---  
`id` | `UUIDField` | Unique identifier for the message.  
`dbid` | `BigIntegerField` | Database primary key.  
`created` | `DateTimeField` | Timestamp when the message was created.  
`modified` | `DateTimeField` | Timestamp when the message was last modified.  
`content` | `TextField` | The body text of the message.  
`sender` | `ForeignKey(CanvasUser)` | The user who sent the message. May be null.  
`recipient` | `ForeignKey(CanvasUser)` | The user who received the message. May be null.  
`note` | `ForeignKey(Note)` | Associated note (if any) for contextual linkage. May be null.  
`read` | `DateTimeField` | Timestamp when the recipient read the message. Null if unread.  
##  MessageAttachment 
Represents a file attachment linked to a message.
###  Fields 
Name | Type | Description  
---|---|---  
`id` | `UUIDField` | Unique identifier for the attachment.  
`dbid` | `BigIntegerField` | Database primary key.  
`file` | `TextField` | Storage path or identifier for the file.  
`content_type` | `CharField(max_length=255)` | MIME type of the attachment.  
`message` | `ForeignKey(Message)` | The parent message to which this belongs.  
##  MessageTransmission 
Tracks delivery attempts and status for a message.
###  Fields 
Name | Type | Description  
---|---|---  
`id` | `UUIDField` | Unique identifier for the transmission record.  
`dbid` | `BigIntegerField` | Database primary key.  
`created` | `DateTimeField` | Timestamp when the transmission was created.  
`modified` | `DateTimeField` | Timestamp when the transmission was last modified.  
`message` | `ForeignKey(Message)` | The message associated with this transmission.  
`delivered` | `BooleanField` | Whether delivery was successful.  
`failed` | `BooleanField` | Whether delivery failed.  
`contact_point_system` | `CharField(choices=TransmissionChannel)` | The channel used for delivery.  
`contact_point_value` | `CharField(max_length=255)` | The destination address or identifier (e.g., phone, email).  
`comment` | `TextField` | Optional comments or error details.  
`delivered_by` | `ForeignKey(Staff)` | The staff member who processed the delivery. May be null.
----- END PAGE https://docs.canvasmedical.com/sdk/data-message/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-note/
##  Introduction 
The `Note` model represents clinical notes that appear on a patient's chart. A `Note` can contain multiple [commands](/sdk/data-command).
##  Basic usage 
###  Retrieve a specific note 
To get a note by identifier, use the `get` method on the `Note` model manager:
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    ```
###  Find all notes for a patient 
If you have a patient object, the notes for a patient can be found using the `notes` attribute on the `Patient` instance:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="fd2ecd87c26044a6a755287f296dd17f")
    patient_notes = patient.notes.all()
    ```
###  Retrieve the content of commands in a note 
If you have a note object, the [commands](/sdk/data-command) for that note can be found using the `commands` attribute on the `Note` instance:
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    note_commands = note.commands.all()
    ```
You can also filter commands by their state or other attributes:
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # Get only committed commands
    committed_commands = note.commands.filter(state="committed")
    # Get commands by schema_key (e.g., prescriptions)
    prescriptions = note.commands.filter(schema_key="prescribe")
    ```
To access the content of a command, use the `data` attribute which contains a JSON object with the command's data:
    ```python
    import json
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    for command in note.commands.all():
        # Get the command type
        command_type = command.schema_key
        # Get the command data as a dictionary
        command_data = command.data
        # Pretty print the command data
        print(f"Command Type: {command_type}")
        print(json.dumps(command_data, indent=2))
    ```
For more information about command types and their data structure, see the [Command](/sdk/data-command/) documentation.
###  Understanding the note body structure 
The `body` field of a note contains a JSON array that represents the structure and layout of the note. It intermixes text content with references to commands:
    ```python
    import json
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # The body is an array of objects
    print(json.dumps(note.body, indent=2))
    ```
The body array contains objects of two types:
  1. **Text objects** : Represent free-form text content 
         ```json
         {"type": "text", "value": "Patient reports feeling better"}
         ```
  2. **Command objects** : Reference commands with their metadata 
         ```json
         {
           "type": "command",
           "value": "reasonForVisit",
           "data": {
             "id": 1095,
             "command_uuid": "691123c4-6c7d-415b-880b-2beefab9f64a"
           }
         }
         ```
The `command_uuid` in a command object corresponds to the `id` field of the [Command](/sdk/data-command/) model, allowing you to retrieve the full command data:
    ```python
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.command import Command
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # Find all command references in the note body
    for item in note.body:
        if item.get("type") == "command":
            command_uuid = item["data"]["command_uuid"]
            command = Command.objects.get(id=command_uuid)
            print(f"Command type: {command.schema_key}")
            print(f"Command data: {command.data}")
    ```
###  Retrieve the audit history for a note 
The audit history for a note can be found using the [`NoteStateChangeEvent`](/sdk/data-note/#notestatechangeevent) model. You can access this model directly or through the `state_history` relation on the note object.
    ```python
    from canvas_sdk.v1.data.note import Note, NoteStateChangeEvent
    note = Note.objects.first()
    # Use the state_history relation
    option_1 = note.state_history.all()
    # Use the note object to filter the QuerySet
    option_2 = NoteStateChangeEvent.objects.filter(note=note)
    # Use the note's UUID to filter the QuerySet, which joins to the note table
    # where the note's dbid column is equal to the note_id column of the note
    # state change event and the note's id column is equal to the note's UUID.
    option_3 = NoteStateChangeEvent.objects.filter(note__id=note.id)
    # Use the note's auto-increment database id to filter the QuerySet by the
    # foreign key column without joining to the notes table.
    option_4 = NoteStateChangeEvent.objects.filter(note_id=note.dbid)
    ```
In the above code sample, options 1, 2, and 4 produce identical SQL queries.
###  Determine if a note is locked 
To see if a note is presently locked, you can use the [`CurrentNoteStateEvent`](/sdk/data-note/#currentnotestateevent) model to check if the current note state is 'Locked'. (See: [NoteState](/sdk/data-note/#notestates) for an explanation of the different note states you might encounter)
    ```python
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent, NoteStates
    note = Note.objects.first()
    # You can retrieve the CurrentNoteStateEvent record for the note and check its
    # state attribute.
    if CurrentNoteStateEvent.objects.get(note=note).state == NoteStates.LOCKED:
        # This note is locked!
        pass
    # You can skip retrieving the record by just checking if a
    # CurrentNoteStateEvent record exists for that note with the state 'Locked'.
    if CurrentNoteStateEvent.objects.filter(note=note, state=NoteStates.LOCKED).exists():
        # This note is locked!
        pass
    ```
###  Find all open notes 
You can find all open notes by retrieving the note records with a current state which indicates it can be edited. (See list below)
    ```python
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent, NoteStates
    open_note_states = [
        NoteStates.NEW,
        NoteStates.PUSHED,
        NoteStates.CONVERTED,
        NoteStates.UNLOCKED,
        NoteStates.RESTORED,
        NoteStates.UNDELETED,
    ]
    # This will execute one query per CurrentNoteStateEvent object returned
    open_notes_via_list_comprehension = [event.note for event in CurrentNoteStateEvent.objects.filter(state__in=open_note_states)]
    # This will always execute two queries: one to find the note ids of open
    # notes, and a second query to fetch the note records by the ids returned in the
    # first query
    open_note_ids = CurrentNoteStateEvent.objects.filter(state__in=open_note_states).values_list('note_id', flat=True)
    open_notes_via_multiple_queries = Note.objects.filter(dbid__in=open_note_ids)
    ```
###  Get the current state of a given note 
To get a note's current state, retrieve its [`CurrentNoteStateEvent`](/sdk/data-note/#currentnotestateevent) and check the `state` attribute. If you are trying to assess if the current note state represents that note as being editable, you can call the `editable()` method on the `CurrentNoteStateEvent` object.
    ```python
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent
    note = Note.objects.first()
    current_note_state = CurrentNoteStateEvent.objects.get(note=note).state
    is_editable = current_note_state.editable()
    ```
###  Get the current claim of a given note 
You can retrieve the current claim using the method `get_claim()` presented in the Note object.
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.first()
    claim = note.get_claim()
    ```
###  Get the NoteType of a given note 
To get the note type for a specific note, use the `note_type_version` attribute which provides access to the related `NoteType` object:
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="89992c23-c298-4118-864a-26cb3e1ae822")
    # Get the note type name (e.g., "Office Visit")
    note_type_name = note.note_type_version.name
    # Access other note type attributes
    note_type_display = note.note_type_version.display
    note_type_code = note.note_type_version.code
    note_type_system = note.note_type_version.system
    ```
##  Filtering 
###  By attribute 
Notes can also be filtered by attribute. For example, to get all notes for a patient where the `datetime_of_service` is after a certain date, the following code can be used:
    ```python
    import arrow
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="fd2ecd87c26044a6a755287f296dd17f")
    recent_notes = Note.objects.filter(
        patient=patient,
        datetime_of_service__gte=arrow.now().shift(weeks=-3).datetime
    )
    ```
The `NoteType` model can also be used to find notes by type.
    ```python
    from canvas_sdk.v1.data.note import Note
    from canvas_sdk.v1.data.note import NoteType
    from canvas_sdk.v1.data.patient import Patient
    note_type = NoteType.objects.get(name="Office visit")
    patient = Patient.objects.get(id="fd2ecd87c26044a6a755287f296dd17f")
    patient_office_visits = Note.objects.filter(patient=patient, note_type_version=note_type)
    ```
##  Attributes 
###  Note 
Field Name | Type | Notes  
---|---|---  
id | UUID |   
dbid | Integer |   
created | DateTime |   
modified | DateTime |   
patient | [Patient](/sdk/data-patient/#patient) |   
note_type_version | NoteType |   
title | String |   
body | JSON | Array of objects representing the note structure. Each object has a `type` (either `"text"` or `"command"`) and a `value`. Command objects also include a `data` field with `id` and `command_uuid`.  
originator | [CanvasUser](/sdk/data-canvasuser) |   
provider | [Staff](/sdk/data-staff/#staff) |   
checksum | String |   
billing_note | String |   
related_data | JSON | Can contain one key, `roomNumber`, if the Note is an inpatient stay.  
datetime_of_service | DateTime |   
place_of_service | String |   
encounter | [Encounter](/sdk/data-encounter) |   
commands | QuerySet[[Command](/sdk/data-command)] | All commands associated with this note  
note_tasks | QuerySet[[NoteTask](/sdk/data-task)] | All tasks associated with this note  
###  NoteType 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
name | String  
icon | String  
category | NoteTypeCategories  
rank | Integer  
is_default_appointment_type | Boolean  
is_scheduleable | Boolean  
is_telehealth | Boolean  
is_billable | Boolean  
defer_place_of_service_to_practice_location | Boolean  
available_places_of_service | Array[PracticeLocationPOS]  
default_place_of_service | PracticeLocationPOS  
is_system_managed | Boolean  
is_visible | Boolean  
is_active | Boolean  
unique_identifier | UUID  
deprecated_at | DateTime  
is_patient_required | Boolean  
allow_custom_title | Boolean  
###  NoteStateChangeEvent 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
note | [Note](/sdk/data-note/)  
originator | [CanvasUser](/sdk/data-canvasuser)  
state | [NoteState](/sdk/data-note/#notestates)  
note_state_document | String  
note_state_html | String  
###  CurrentNoteStateEvent 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
state | [NoteState](/sdk/data-note/#notestates)  
note | [Note](/sdk/data-note/)  
##  Enumeration types 
###  NoteStates 
Value | Description | Notes  
---|---|---  
NEW | Created |   
PSH | Pushed the charges for |   
LKD | Locked |   
ULK | Unlocked |   
DLT | Deleted |   
RLK | Relocked |   
RST | Restored |   
RCL | Recalled |   
UND | Undeleted |   
DSC | Discharged |   
SCH | Scheduling | Used in appointment notes  
BKD | Booked | Used in appointment notes  
CVD | Converted | Used in appointment notes  
CLD | Canceled | Used in appointment notes  
NSW | No show | Used in appointment notes  
RVT | Reverted | Used in appointment notes  
CNF | Confirmed | Used for CCDA import notes  
###  NoteTypeCategories 
Value | Description  
---|---  
message | Message  
letter | Letter  
inpatient | Inpatient Visit Note  
review | Chart Review Note  
encounter | Encounter Note  
appointment | Appointment Note  
task | Task  
data | Data  
ccda | C-CDA  
schedule_event | Schedule Event  
###  PracticeLocationPOS 
Value | Description  
---|---  
01 | Pharmacy  
02 | Telehealth  
03 | Education Facility  
04 | Homeless Shelter  
09 | Prison  
10 | Telehealth in Patient's Home  
11 | Office  
12 | Home  
13 | Asssisted Living Facility  
14 | Group Home  
15 | Mobile Unit  
17 | Walk-In Retail Health Clinic  
19 | Off-Campus Outpatient Hospital  
20 | Urgent Care Facility  
21 | Inpatient Hospital  
22 | On-Campus Outpatient Hospital  
23 | Emergency Room Hospital  
24 | Ambulatory Surgery Center  
25 | Birthing Center  
26 | Military Treatment Facility  
27 | Outreach Site / Street  
31 | Skilled Nursing Facility  
32 | Nursing Facility  
33 | Custodial Care Facility  
34 | Hospice  
41 | Ambulance Land  
42 | Ambulance Air or Water  
49 | Independent Clinic  
50 | Federally Qualified Health Center  
51 | Inpatient Psychiatric Facility  
52 | Inpatient Psychiatric Facility - Partial Hospitalization  
53 | Community Mental Health Center  
54 | Intermediate Care Facility for Mentally Retarded  
55 | Residential Substance Abuse Treatment Facility  
56 | Psychiatric Residential Treatment Center  
57 | Non-Residential Substance Abuse Treatment Facility  
60 | Mass Immunization Center  
61 | Inpatient Rehabilitation Facility  
62 | Outpatient Rehabilitation Facility  
65 | End-Stage Renal Disease Treatment Facility  
71 | State or Local Public Health Clinic  
72 | Rural Health Clinic  
81 | Independent Laboratory  
99 | Other Place of Service
----- END PAGE https://docs.canvasmedical.com/sdk/data-note/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-observation/
##  Introduction 
The `Observation` model represents measurements or assertions made about a patient, such as vital signs, lab results, or other clinical findings.
##  Basic usage 
To get an observation by identifier, use the `get` method on the `Observation` model manager:
    ```python
    from canvas_sdk.v1.data.observation import Observation
    observation = Observation.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the observations for a patient can be accessed with the `observations` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    observations = patient.observations.all()
    ```
If you have a patient ID, you can get the observations for the patient with the `for_patient` method on the `Observation` model manager:
    ```python
    from canvas_sdk.v1.data.observation import Observation
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    observations = Observation.objects.for_patient(patient_id)
    ```
##  Codings 
The codings for an observation can be accessed with the `codings` attribute on an `Observation` object:
    ```python
    from canvas_sdk.v1.data.observation import Observation
    from logger import log
    observation = Observation.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for coding in observation.codings.all():
        log.info(f"system:  {coding.system}")
        log.info(f"code:    {coding.code}")
        log.info(f"display: {coding.display}")
    ```
##  Components 
The components for an observation can be accessed with the `components` attribute on an `Observation` object:
    ```python
    from canvas_sdk.v1.data.observation import Observation
    from logger import log
    observation = Observation.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for component in observation.components.all():
        log.info(f"name: {component.name}")
        log.info(f"value: {component.value_quantity}")
        log.info(f"unit: {component.value_quantity_unit}")
    ```
###  Component codings 
Component codings can be accessed similarly to codings on the observation, by using the `codings` attribute on an `ObservationComponent` object.
##  Filtering 
Observations can be filtered by any attribute that exists on the model.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.observation import Observation
    observations = Observation.objects.filter(effective_datetime__gte="2024-11-20")
    ```
###  By ValueSet 
Filtering by ValueSet works a little differently. The `find` method on the model manager is used to perform `ValueSet` filtering:
    ```python
    from canvas_sdk.v1.data.observation import Observation
    from canvas_sdk.value_set.v2022.physical_exam import Weight
    observations = Observation.objects.find(Weight)
    ```
##  Attributes 
###  Observation 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
patient | [Patient](/sdk/data-patient/#patient)  
is_member_of | Observation  
category | String (comma-separated list of categories  
units | String  
value | String  
note_id | Integer  
name | String  
effective_datetime | DateTime  
codings | ObservationCoding[]  
members | Observation[]  
components | ObservationComponent[]  
value_codings | ObservationValueCoding[]  
###  ObservationCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
observation | Observation  
###  ObservationComponent 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
observation | Observation  
value_quantity | String  
value_quantity_unit | String  
name | String  
codings | ObservationComponentCoding[]  
###  ObservationComponentCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
observation_component | ObservationComponent  
###  ObservationValueCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
observation | Observation  
----- END PAGE https://docs.canvasmedical.com/sdk/data-observation/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-organization/
##  Introduction 
The `Organization` model represents the overall Organization in a Canvas EMR instance. An `Organization` can have multiple related [Practice Locations](/sdk/data-practicelocation).
##  Basic usage 
Canvas instances can contain only a single `Organization` entry. To retrieve the `Organization` entry, you can either query by the organization's name:
    ```python
    from canvas_sdk.v1.data.organization import Organization
    organization = Organization.objects.get(full_name="Medical Organization")
    ```
Or since there will only be one `Organization` in an instance, it can also be fetched by using the `first` method:
    ```python
    from canvas_sdk.v1.data.organization import Organization
    organization = Organization.objects.first()
    ```
##  Attributes 
###  Organization 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
full_name | String  
short_name | String  
subdomain | String  
logo_url | String  
background_image_url | String  
background_gradient | String  
active | Boolean  
tax_id | String  
tax_id_type | [TaxIDType](/sdk/data-enumeration-types/#taxidtype)  
group_npi_number | String  
group_taxonomy_number | String  
include_zz_qualifier | Boolean  
##  OrganizationAddress 
The `OrganizationAddress` model represents a physical or mailing address associated with an Organization. Multiple addresses can be linked to a single Organization, each with its own type and details.
###  Attributes 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
organization | Organization  
use | [AddressUseWithBilling](/sdk/data-enumeration-types/#addressusewithbilling)  
type | [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude | Float  
latitude | Float  
start | Date  
end | Date  
country | String  
state | [AddressState](/sdk/data-enumeration-types/#addressstate)  
address_search_index | String  
line1 | String  
line2 | String  
city | String  
district | String  
state_code | String  
postal_code | String  
##  OrganizationContactPoint 
The `OrganizationContactPoint` model represents a contact method (such as phone, email, or fax) for an Organization. Multiple contact points can be associated with a single Organization, each with its own type, use, and status.
###  Attributes 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
organization | Organization  
system | [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value | String  
use | [ContactPointUse](/sdk/data-enumeration-types/#contactpointuse)  
use_notes | String  
rank | Integer  
state | [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
----- END PAGE https://docs.canvasmedical.com/sdk/data-organization/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-patient-consent/
##  Introduction 
The `PatientConsent` model represents documented patient consents in Canvas that ensure legal compliance and protect patient rights. Each `PatientConsent` is linked to a `Patient`, has a category (which is a `PatientConsentCoding`), and optionally a rejection reason (which is a `PatientConsentRejectionCoding`).
##  Usage 
The `PatientConsent` model can be used to find all of the patient consents for a given patient and organization:
    ```python
    >>> from canvas_sdk.v1.data import PatientConsent, Patient, Organization
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> organization_1 = Organization.objects.first()
    >>> patient_1_consents = PatientConsent.objects.filter(patient=patient_1, organization=organization_1)
    >>> print([consent.category.display for consent in patient_1_consents])
    ['Surgical Consent Form', 'Telehealth', 'HIPAA']
    ```
You can also access a patient's consents from the `Patient` model:
    ```python
    >>> from canvas_sdk.v1.data import PatientConsent, Patient
    >>> patient_1 = Patient.objects.get(id="aebe4d3f5d18410388dc69c4b5169fc3")
    >>> patient_1_consents = patient_1.patient_consent.all()
    >>> print([consent.category.display for consent in patient_1_consents])
    ['Surgical Consent Form', 'Telehealth', 'HIPAA']
    ```
And you can also access all of the PatientConsents for a given PatientConsentCoding (aka category):
    ```python
    >>> from canvas_sdk.v1.data import PatientConsentCoding
    >>> coding = PatientConsentCoding.objects.get(code='59284-0', system='LOINC')
    >>> consents = coding.patient_consent.all()
    >>> print([consent.state for consent in consents])
    ['accepted', 'accepted_via_patient_portal', 'rejected']
    ```
##  Attributes 
###  PatientConsent 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
patient | [Patient](/sdk/data-patient)  
category | PatientConsentCoding  
state | PatientConsentStatus  
effective_date | DateTime  
expired_date | DateTime  
rejection_reason | PatientConsentRejectionCoding  
originator | [CanvasUser](/sdk/data-canvasuser)  
###  PatientConsentCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
expiration_rule | PatientConsentExpirationRule  
is_mandatory | Boolean  
is_proof_required | Boolean  
show_in_patient_portal | Boolean  
summary | String  
###  PatientConsentRejectionCoding 
Field Name | Type  
---|---  
dbid | Integer  
system | String  
version | String  
code | String  
display | String  
user_selected | Boolean  
##  Enumeration types 
###  PatientConsentStatus 
Value | Label  
---|---  
accepted | Accepted  
accepted_via_patient_portal | Accepted Via Patient Portal  
rejected | Rejected  
rejected_via_patient_portal | Rejected Via Patient Portal  
###  PatientConsentExpirationRule 
Value | Label  
---|---  
never | Never  
in_one_year | In one year  
end_of_year | End of year
----- END PAGE https://docs.canvasmedical.com/sdk/data-patient-consent/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-patient/
##  Introduction 
The `Patient` model represents an individual receiving care or other health-related services.
##  Basic usage 
To get a patient by identifier, use the `get` method on the `Patient` model manager:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="b80b1cdc2e6a4aca90ccebc02e683f35")
    ```
##  Filtering 
Patients can be filtered by any attribute that exists on the model.
Filtering for patients is done with the `filter` method on the `Patient` model manager.
###  By attribute 
Specify attributes with `filter` to filter by those attributes:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patients = Patient.objects.filter(first_name="Bob", last_name="Loblaw", birth_date="1960-09-22")
    ```
##  Attributes 
###  Patient 
Field Name | Type  
---|---  
id | String  
dbid | Integer  
first_name | String  
last_name | String  
birth_date | Date  
sex_at_birth | SexAtBirth  
created | DateTime  
modified | DateTime  
prefix | String  
suffix | String  
middle_name | String  
maiden_name | String  
nickname | String  
sexual_orientation_term | String  
sexual_orientation_code | String  
gender_identity_term | String  
gender_identity_code | String  
preferred_pronouns | String  
biological_race_codes | Array[String]  
cultural_ethnicity_codes | Array[String]  
last_known_timezone | String  
mrn | String  
active | Boolean  
deceased | Boolean  
deceased_datetime | DateTime  
deceased_cause | String  
deceased_comment | String  
other_gender_description | String  
social_security_number | String  
administrative_note | String  
clinical_note | String  
mothers_maiden_name | String  
multiple_birth_indicator | Boolean  
birth_order | Integer  
default_location_id | Integer  
default_provider_id | Integer  
addresses | PatientAddress[]  
allergy_intolerances | [AllergyIntolerance](/sdk/data-allergy-intolerance/#allergyintolerance)[]  
billing_line_items | [BillingLineItem](/sdk/data-billing-line-item/)  
business_line | [BusinessLine](/sdk/data-business-line/)  
care_team_memberships | [CareTeamMembership](/sdk/data-care-team/#careteammembership)[]  
conditions | [Condition](/sdk/data-condition/#condition)[]  
coverages | [Coverage](/sdk/data-coverage/#coverage)[]  
dependent_coverages | [Coverage](/sdk/data-coverage/#coverage)[]  
detected_issues | [DetectedIssue](/sdk/data-detected-issue/#detectedissue)[]  
devices | [Device](/sdk/data-device/#device)[]  
external_identifiers | PatientExternalIdentifier[]  
imaging_orders | [ImagingOrder](/sdk/data-imaging/#imagingorder)[]  
imaging_reports | [ImagingReport](/sdk/data-imaging/#imagingreport)[]  
imaging_reviews | [ImagingReview](/sdk/data-imaging/#imagingreview)[]  
interviews | [Interview](/sdk/data-questionnaire/#interview)[]  
lab_orders | [LabOrder](/sdk/data-labs/#laborder)[]  
lab_reports | [LabReport](/sdk/data-labs/#labreport)[]  
lab_reviews | [LabReview](/sdk/data-labs/#labreview)[]  
medications | [Medication](/sdk/data-medication/#medication)[]  
metadata | PatientMetadata[]  
observations | [Observation](/sdk/data-observation/#observation)[]  
preferred_pharmacy | JSON  
protocol_overrides | [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)[]  
settings | PatientSetting  
subscribed_coverages | [Coverage](/sdk/data-coverage/#coverage)[]  
tasks | [Task](/sdk/data-task/#task)[]  
telecom | PatientContactPoint[]  
user | [CanvasUser](/sdk/data-canvasuser/)[]  
###  PatientAddress 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
line1 | String  
line2 | String  
city | String  
district | String  
state_code | String  
postal_code | String  
use | [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type | [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude | Float  
latitude | Float  
start | Date  
end | Date  
country | String  
state | String  
patient | Patient  
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_addresses = patient.addresses.all()
    for addr in patient_addresses:
      log.info(f"Patient address: {addr.city}, {addr.state_code}, {addr.postal_code}") # Seattle, WA, 98118
    ```
###  PatientContactPoint 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
system | [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value | String  
use | String  
use_notes | String  
rank | Integer  
state | [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
patient | Patient  
has_consent | Boolean  
last_verified | DateTime  
verification_token | String  
opted_out | Boolean  
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_contacts = patient.telecom.all()
    for contact in patient_contacts:
       log.info(f"Patient contact: {contact.system} - {contact.value}") # phone - 5555555555
    ```
###  PatientExternalIdentifier 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | Patient  
use | String  
identifier_type | String  
system | String  
value | String  
issued_date | Date  
expiration_date | Date  
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_external_identifiers = patient.external_identifiers.all()
    for identifier in patient_external_identifiers:
       log.info(f"Patient external identifier: {identifier.system}, {identifier.value}")  # https://www.example.com - abc123
    ```
###  PatientSetting 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | Patient  
name | String  
value | JSON  
###  PatientMetadata 
Field Name | Type  
---|---  
dbid | Integer  
patient | Patient  
key | String  
value | String  
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    patient_id = "d7af3e356368446c85b40a5d6ff7288e"
    patient = Patient.objects.get(id=patient_id)
    patient_metadata = patient.metadata.all()
    for metadata in patient_metadata:
       log.info(f"Patient metadata: {metadata.key}, {metadata.value}") # favorite_color - red
    ```
###  PatientFacilityAddress 
Field Name | Type  
---|---  
patientaddress | PatientAddress  
facility | Facility  
room_number | String  
##  Enumeration types 
###  SexAtBirth 
Value | Label  
---|---  
F | female  
M | male  
O | other  
UNK | unknown  
"" (empty string) | ""  
##  Computed Properties 
###  Patient 
  - `full_name`: The full name of the patient, combining first, middle, and last names.
  - `preferred_pharmacy`: The patient's preferred pharmacy for medication fulfillment.
  - `preferred_full_name`: The patient's preferred full name, if different from the legal name.
  - `preferred_first_name`: The patient's preferred first name, if different from the legal first name.
  - `primary_phone_number`: The patient's primary contact number.
----- END PAGE https://docs.canvasmedical.com/sdk/data-patient/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-payor-specific-charge/
##  Introduction 
The `PayorSpecificCharge` model represents charges specific to a [Transactor](/sdk/data-coverage/#transactor) in Canvas.
##  Usage 
The `PayorSpecificCharge` model can be used to find all of the charges specific to a single `Transactor`:
    ```python
    >>> from canvas_sdk.v1.data import PayorSpecificCharge, Transactor
    >>> aetna = Transactor.objects.get(payer_id="60054")
    >>> aetna_charges = PayorSpecificCharge.objects.filter(transactor=aetna)
    >>> print([charge.charge_amount for charge in aetna_charges])
    [150.00, 40.00, 99.99]
    ```
You can also access a transactor's specific charges from the `Transactor` model:
    ```python
    >>> from canvas_sdk.v1.data import Transactor
    >>> aetna = Transactor.objects.get(payer_id="60054")
    >>> aetna_charges = aetna.specific_charges.all()
    >>> print([charge.charge_amount for charge in aetna_charges])
    [150.00, 40.00, 99.99]
    ```
`
##  Attributes 
###  PayorSpecificCharge 
Field Name | Type  
---|---  
dbid | Integer  
transactor | [Transactor](/sdk/data-coverage/#transactor)  
charge | [ChargeDescriptionMaster](/sdk/data-charge-description-master)  
charge_amount | Decimal  
effective_date | Date  
end_date | Date  
part_of_capitated_set | Boolean
----- END PAGE https://docs.canvasmedical.com/sdk/data-payor-specific-charge/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-posting/
##  Introduction 
This module defines models related to payments and postings associated with healthcare claims.
##  Basic usage 
To retrieve a posting by ID:
    ```python
    from canvas_sdk.v1.data.posting import BasePosting
    posting = BasePosting.objects.get(dbid=1234)
    ```
To retrieve all active postings for a given claim:
    ```python
    from canvas_sdk.v1.data.claim import Claim
    claim = Claim.objects.get(id="<uuid>")
    claim_postings = claim.postings.active()
    ```
##  Attributes 
###  BasePosting 
Base model for aggregating multiple line item-level transactions (payments, adjustments, transfers) associated with a claim.
Field Name | Type  
---|---  
dbid | Integer  
corrected_posting | BasePosting  
claim | [Claim](/sdk/data-claim/#claim)  
payment_collection | PaymentCollection  
description | String  
entered_in_error | [CanvasUser](/sdk/data-canvasuser/)  
created | DateTime  
modified | DateTime  
**Computed Properties** :
  - `paid_amount`: Total paid
  - `contractual_adjusted_amount`: Adjustments marked as write-offs
  - `non_write_off_adjusted_amount`: Non-write-off adjustments
  - `transferred_amount`: Total transferred
  - `transferred_to_patient_amount`: Portion transferred to patient
  - `transferred_to_coverage_amount`: Portion transferred to another coverage
  - `adjusted_and_transferred_amount`: Combined adjusted and transferred amount
  - `posted_amount`: Total of payments and write-offs
###  CoveragePosting 
Represents an insurance payment or adjustment associated with a claim's coverage.
Field Name | Type  
---|---  
remittance | BaseRemittanceAdvice  
claim_coverage | [ClaimCoverage](/sdk/data-claim/#claimcoverage)  
crossover_carrier | String  
crossover_id | String  
payer_icn | String  
position_in_era | Integer  
###  PatientPosting 
Represents patient-side payments or adjustments, including links to copays or patient-level discounts.
Field Name | Type  
---|---  
claim_patient | [ClaimPatient](/sdk/data-claim/#claimpatient)  
patient_payment | BulkPatientPosting  
copay | BulkPatientPosting  
**Computed Properties** :
  - `discounted_amount`: Discount applied
  - `charges_amount`: Discount + paid amount
###  BulkPatientPosting 
Aggregates bulk patient payments on multiple claims.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
payment_collection | PaymentCollection  
total_paid | Decimal  
created | DateTime  
modified | DateTime  
discount | Discount  
payer | [Patient](/sdk/data-patient/)  
**Computed Properties** :
  - `total_posted_amount`: Sum of all posted amounts
  - `discounted_amount`: Sum of discounted amounts
###  BaseRemittanceAdvice 
Represents shared data for both electronic and manual remittance advice.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
payment_collection | PaymentCollection  
total_paid | Decimal  
created | DateTime  
modified | DateTime  
transactor | [Transactor](/sdk/data-coverage/#transactor/)  
era_id | String  
**Computed Properties** :
  - `total_posted_amount`: Sum of all posted amounts
###  PaymentCollection 
Captures metadata about the method and details of a collected payment.
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
total_collected | Decimal  
method | PostingMethods  
check_number | String  
check_date | Date  
deposit_date | Date  
description | String  
created | DateTime  
modified | DateTime  
###  NewLineItemPayment 
Represents a payment applied to a billing line item within a claim.
Field Name | Type  
---|---  
dbid | Integer  
posting | BasePosting  
billing_line_item | [BillingLineItem](/sdk/data-billing-line-item/)  
amount | Decimal  
charged | Decimal  
created | DateTime  
modified | DateTime  
###  NewLineItemAdjustment 
Represents an adjustment applied to a billing line item.
Field Name | Type  
---|---  
dbid | Integer  
posting | BasePosting  
billing_line_item | [BillingLineItem](/sdk/data-billing-line-item/)  
amount | Decimal  
code | String  
group | String  
deviated_from_posting_ruleset | Boolean  
write_off | Boolean  
created | DateTime  
modified | DateTime  
###  LineItemTransfer 
Represents a transfer of a line item balance to another coverage or patient.
Field Name | Type  
---|---  
dbid | Integer  
posting | BasePosting  
billing_line_item | [BillingLineItem](/sdk/data-billing-line-item/)  
amount | Decimal  
code | String  
group | String  
deviated_from_posting_ruleset | Boolean  
transfer_to | [ClaimCoverage](/sdk/data-claim/#claimcoverage)  
transfer_to_patient | Boolean  
created | DateTime  
modified | DateTime  
###  Discount 
Represents a discount applied to a claim or patient posting, linked by adjustment group and code.
Field Name | Type  
---|---  
dbid | Integer  
name | String  
adjustment_group | String  
adjustment_code | String  
discount | Decimal  
created | DateTime  
modified | DateTime  
##  Enumeration types 
###  PostingMethods 
Value | Label  
---|---  
cash | Cash  
check | Check  
card | Card  
other | Other
----- END PAGE https://docs.canvasmedical.com/sdk/data-posting/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-practicelocation/
##  Introduction 
The `PracticeLocation` model lists all the clinical practice locations that fall under an [Organization](/sdk/data-organization).
##  Basic usage 
To query a `PracticeLocation` by name, the `filter` method can be used like so:
    ```python
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.filter(full_name__icontains="downtown")
    ```
To retrieve a list of all practice locations:
    ```python
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_locations = PracticeLocation.objects.all()
    ```
To query addresses that are associated with a `PracticeLocation`, related `PracticeLocationAddress` model instances can be accessed by using the `addresses` attribute. For exmample:
    ```python
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.first()
    practice_location_addresses = practice_location.addresses.all()
    ```
Each `PracticeLocation` has location-specific settings that control certain behavior within the EMR application. To retrieve the available settings for a `PracticeLocation` instance, the `settings` attribute can be used to retrieve a list of names:
    ```python
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.first()
    available_settings = practice_location.settings.values_list('name', flat=True)
    ```
Additionally, a setting's value can be found by accessing the `value` attribute on the `PracticeLocationSetting`:
    ```python
    from canvas_sdk.v1.data.practicelocation import PracticeLocation
    practice_location = PracticeLocation.objects.first()
    preferred_lab_partner_text = practice_location.settings.get(name="preferredLabPartner").value
    ```
Please note that the content of each `value` field can contain any value that is JSON-serializable, which includes string values. This means that `value` could be any of the Python types `string`, `list` or `dict`.
##  Attributes 
###  PracticeLocation 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
organization | [Organization](/sdk/data-organization/#organization)  
place_of_service_code | String  
full_name | String  
short_name | String  
background_image_url | String  
background_gradient | String  
active | Boolean  
npi_number | String  
bill_through_organization | Boolean  
tax_id | String  
tax_id_type | [TaxIDType](/sdk/data-enumeration-types/#taxidtype)  
billing_location_name | String  
group_npi_number | String  
taxonomy_number | String  
include_zz_qualifier | Boolean  
addresses | PracticeLocationAddress  
###  PracticeLocationAddress 
Field Name | Type  
---|---  
dbid | Integer  
practice_location | PracticeLocation  
line1 | String  
line2 | String  
city | String  
district | String  
state_code | String  
postal_code | String  
use | [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type | [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude | Float  
latitude | Float  
start | Date  
end | Date  
country | String  
state | [AddressState](/sdk/data-enumeration-types/#addressstate)  
###  PracticeLocationSetting 
Field Name | Type  
---|---  
dbid | Integer  
practice_location | PracticeLocation  
name | String  
value | JSON  
##  PracticeLocationContactPoint 
The `PracticeLocationContactPoint` model represents a contact method (such as phone, email, or fax) for a Practice Location. Multiple contact points can be associated with a single Practice Location, each with its own type, use, and status.
###  Attributes 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
practice_location | PracticeLocation  
system | [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value | String  
use | [ContactPointUse](/sdk/data-enumeration-types/#contactpointuse)  
use_notes | String  
rank | Integer  
state | [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)
----- END PAGE https://docs.canvasmedical.com/sdk/data-practicelocation/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-protocol-current/
##  Introduction 
The `ProtocolCurrent` object represents the current state of clinical protocols applied to patients within Canvas. Protocols are typically structured plans or guidelines that outline specific medical interventions, treatments, or care pathways for managing various health conditions. The `ProtocolCurrent` object contains essential information about the protocol's status, associated patient, and relevant clinical details.
##  Basic Usage 
To get a protocol by identifier, use the `get` method on the `ProtocolCurrent` model manager:
    ```python
    from canvas_sdk.v1.data.protocol_current import ProtocolCurrent
    protocol = ProtocolCurrent.objects.get(id="12345678-1234-1234-1234-123456789012")
    ```
##  Filtering 
    ```python
    from canvas_sdk.v1.data.protocol_current import ProtocolCurrent
    protocols = ProtocolCurrent.objects.filter(status="active", patient_id="b80b1cdc2e6a4aca90ccebc02e683f35")
    ```
##  Attributes 
###  ProtocolResult 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
title | String  
narrative | String  
result_identifiers | Array[String]  
types | Array[String]  
protocol_key | String  
plugin_name | String  
status | String  
due_in | DateTime  
days_of_notice | Integer  
snoozed | Boolean  
sources | Array[String]  
recommendations | Array[String]  
top_recommendation_key | String  
next_review | DateTime  
feedback_enabled | Boolean  
plugin_can_be_snoozed | Boolean  
patient_id | UUID  
result_hash | String  
snooze_date | DateTime
----- END PAGE https://docs.canvasmedical.com/sdk/data-protocol-current/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-protocol-override/
##  Introduction 
The `ProtocolOverride` model represents an instance of a protocol being snoozed for a patient.
##  Basic usage 
To get a protocol override by identifier, use the `get` method on the `ProtocolOverride` model manager:
    ```python
    from canvas_sdk.v1.data.protocol_override import ProtocolOverride
    protocol_override = ProtocolOverride.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a patient object, the protocol overrides for a patient can be accessed with the `protocol_overrides` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    overrides = patient.protocol_overrides.all()
    ```
If you have a patient ID, you can get the protocol overrides for the patient with the `for_patient` method on the `ProtocolOverride` model manager:
    ```python
    from canvas_sdk.v1.data.protocol_override import ProtocolOverride
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    override = ProtocolOverride.objects.for_patient(patient_id)
    ```
##  Filtering 
Protocol overrides can be filtered by any attribute that exists on the model.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.protocol_override import ProtocolOverride
    overrides = ProtocolOverride.objects.filter(status="active")
    ```
##  Attributes 
###  ProtocolOverride 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
protocol_key | String  
is_adjustment | Boolean  
reference_date | DateTime  
cycle_in_days | Integer  
is_snooze | Boolean  
snooze_date | Date  
snoozed_days | Integer  
snooze_comment | String  
narrative | String  
cycle_quantity | Integer  
cycle_unit | IntervalUnit  
status | Status  
##  Enumeration types 
###  IntervalUnit 
Value | Label  
---|---  
days | days  
months | months  
years | years  
###  Status 
Value | Label  
---|---  
active | active  
inactive | inactive  
----- END PAGE https://docs.canvasmedical.com/sdk/data-protocol-override/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-questionnaire/
##  Introduction 
The `Questionnaire` model represents a structured set of questions intended to guide the collection of answers from end-users.
The `Interview` model represents answers to a structured set of questions represented by a `Questionnaire`.
##  Basic usage 
To get a questionnaire or interview by identifier, use the `get` method on the `Questionnaire` or `Interview` model managers:
    ```python
    from canvas_sdk.v1.data.questionnaire import Interview, Questionnaire
    questionnaire = Questionnaire.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    interview = Interview.objects.get(id="75df6d7f-d58d-443b-9fa0-ce43b4d7b2a0")
    ```
If you have a patient object, the interviews for a patient can be accessed with the `interviews` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    interviews = patient.interviews.all()
    ```
If you have a patient ID, you can get the interviews for the patient with the `for_patient` method on the `Interview` model manager:
    ```python
    from canvas_sdk.v1.data.questionnaire import Interview
    patient_id = "1eed3ea2a8d546a1b681a2a45de1d790"
    interviews = Interview.objects.for_patient(patient_id)
    ```
##  Questionnaire questions 
The questions for a questionnaire can be accessed with the `questions` attribute on an `Questionnaire` object:
    ```python
    from canvas_sdk.v1.data.questionnaire import Questionnaire
    from logger import log
    questionnaire = Questionnaire.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for question in questionnaire.questions.all():
        log.info(f"system: {question.code_system}")
        log.info(f"code: {question.code}")
        log.info(f"name: {question.name}")
    ```
##  Interview responses 
The interview responses for an interview can be accessed with the `interview_responses` attribute on an `Interview` object:
    ```python
    from canvas_sdk.v1.data.questionnaire import Interview
    from logger import log
    interview = Interview.objects.get(id="75df6d7f-d58d-443b-9fa0-ce43b4d7b2a0")
    for interview_response in interview.interview_responses.all():
        log.info(f"response option: {interview_response.response_option_value}")
    ```
##  Filtering 
Questionnaires and interviews can be filtered by any attribute that exists on the models.
Filtering for questionnaires and interviews is done with the `filter` method on the `Questionnaire` and `Interview` model managers.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.questionnaire import Interview, Questionnaire
    questionnaires = Questionnaire.objects.filter(name="Tobacco")
    interviews = Interview.objects.filter(progress_status="F")
    ```
###  By ValueSet 
Filtering by ValueSet works a little differently. The `find` method on the model manager is used to perform `ValueSet` filtering:
    ```python
    from canvas_sdk.v1.data.questionnaire import Questionnaire
    from canvas_sdk.value_set.v2022.assessment import TobaccoUseScreening
    questionnaires = Questionnaire.objects.find(TobaccoUseScreening)
    ```
##  Attributes 
###  ResponseOptionSet 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
status | String  
name | String  
code_system | String  
code | String  
type | String  
use_in_shx | Boolean  
options | ResponseOption[]  
questions | Question[]  
###  ResponseOption 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
status | String  
name | String  
code | String  
code_description | String  
value | String  
response_option_set | ResponseOptionSet  
ordering | Integer  
interview_responses | InterviewQuestionResponse[]  
###  Question 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
status | String  
name | String  
response_option_set | ResponseOptionSet  
acknowledge_only | Boolean  
show_prologue | Boolean  
code_system | String  
code | String  
interview_responses | InterviewQuestionResponse[]  
###  Questionnaire 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
status | String  
name | String  
expected_completion_time | Float  
can_originate_in_charting | Boolean  
use_case_in_charting | String  
scoring_function_name | String  
scoring_code_system | String  
scoring_code | String  
code_system | String  
code | String  
search_tags | String  
questions | Question[]  
use_in_shx | Boolean  
carry_forward | String  
interview_responses | InterviewQuestionResponse[]  
###  QuestionnaireQuestionMap 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
status | String  
questionnaire | Questionnaire  
question | Question  
###  Interview 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
status | String  
name | String  
language_id | Integer  
use_case_in_charting | String  
patient | [Patient](/sdk/data-patient/#patient)  
note_id | Integer  
appointment_id | Integer  
questionnaires | Questionnaire[]  
progress_status | String  
created | DateTime  
modified | DateTime  
interview_responses | InterviewQuestionResponse[]  
###  InterviewQuestionResponse 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
status | String  
interview | Interview  
questionnaire | Questionnaire  
question | Question  
response_option | ResponseOption  
response_option_value | String  
questionnaire_state | String  
interview_state | String  
comment | String  
----- END PAGE https://docs.canvasmedical.com/sdk/data-questionnaire/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-reason-for-visit/
##  Introduction 
The `ReasonForVisitSettingCoding` model represents the coding information used to populate the coding field within a Reason For Visit in Canvas.
##  Basic Usage 
To retrieve a specific coding record by its identifier, use the model manager's `get` method:
    ```python
    from canvas_sdk.v1.data import ReasonForVisitSettingCoding
    rfv_coding = ReasonForVisitSettingCoding.objects.get(id="e2b1e1e3-3f52-4a0a-bb3a-123456789abc")
    ```
You can also filter records by attributes. For example, to get all codings from a specific coding system:
    ```python
    from canvas_sdk.v1.data import ReasonForVisitSettingCoding
    codings = ReasonForVisitSettingCoding.objects.filter(system="http://snomed.info/sct")
    ```
##  Attributes 
###  ReasonForVisitSettingCoding 
Field Name | Type | Description  
---|---|---  
id | UUID | The universally unique identifier for this coding record.  
dbid | Integer | The database identifier for this coding record.  
code | String | The code representing the concept.  
display | String | The human-readable display name for the concept.  
system | String | The coding system (e.g., `http://snomed.info/sct`).  
version | String | The version of the coding system.  
duration | Array of Duration | An array of durations (as Python `timedelta` objects) associated with the coding.  
----- END PAGE https://docs.canvasmedical.com/sdk/data-reason-for-visit/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-referral/
##  Introduction 
The `Referral`, `ReferralReport`, and `ReferralReview` models represent referral results and their reviews.
##  Basic Usage 
To retrieve a `Referral`, `ReferralReport`, or `ReferralReview` by identifier, use the `get` method on the model manager:
    ```python
    from canvas_sdk.v1.data.referral import Referral, ReferralReport, ReferralReview
    referral = Referral.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    referral_report = ReferralReport.objects.get(id="c1a5a35a-4ee2-4a0e-85c0-21739dc8c4a8")
    referral_review = ReferralReview.objects.get(id="b3e6f74c-2a1b-4c8d-9f2e-31842ae7d3b9")
    ```
If you have a patient object, the referrals, reports, and reviews can be accessed with the `referral_set`, `referral_reports`, and `referral_reviews` attributes, respectively on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    referrals = patient.referral_set.all()
    reports = patient.referral_reports.all()
    reviews = patient.referral_reviews.all()
    ```
##  Filtering 
Referrals, reports, and reviews can be filtered by any attribute that exists on the models.
Filtering is done with the `filter` method on the `Referral`, `ReferralReport`, and `ReferralReview` model managers.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.referral import Referral, ReferralReport, ReferralReview
    referrals = Referral.objects.filter(priority="urgent")
    reports = ReferralReport.objects.filter(requires_signature=True)
    reviews = ReferralReview.objects.filter(status="completed")
    ```
##  Related Tasks 
To retrieve an Referral's related tasks, use the `get_task_objects` method on the Referral object.
    ```python
    from canvas_sdk.v1.data.referral import Referral
    referral = Referral.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    tasks = referral.get_task_objects().all()
    ```
##  Attributes 
###  Referral 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note/#note)  
assessments | [Assessment](/sdk/data-assessment/#assessment)  
service_provider | [ServiceProvider](/sdk/data-serviceprovider/#service-provider)  
clinical_question | String  
priority | String  
include_visit_note | Boolean  
notes | String  
date_referred | DateTime  
internal_comment | String  
forwarded | Boolean  
internal_task_comment | [TaskComment](/sdk/data-task/#taskcomment)  
task_ids | String  
###  ReferralReport 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
assigned_by | [CanvasUser](/sdk/data-canvasuser)  
review_mode | [DocumentReviewMode](/sdk/data-enumeration-types/#documentreviewmode)  
junked | Boolean  
requires_signature | Boolean  
assigned_date | DateTime  
team_assigned_date | DateTime  
team | [Team](/sdk/data-team/#team)  
patient | [Patient](/sdk/data-patient/#patient)  
referral | Referral  
specialty | String  
comment | String  
priority | Boolean  
original_date | Date  
review | ReferralReview  
###  ReferralReview 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
internal_comment | String  
message_to_patient | String  
status | String  
patient | [Patient](/sdk/data-patient/#patient)  
patient_communication_method | String
----- END PAGE https://docs.canvasmedical.com/sdk/data-referral/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-serviceprovider/
##  Introduction 
This module defines the data models used to manage Service Provider in the Canvas SDK.
##  Basic usage 
To retrieve an `ServiceProvider` by identifier, use the `get` method on the model manager:
    ```python
    from canvas_sdk.v1.data.service_provider import ServiceProvider
    service_provider = ServiceProvider.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    ```
To retrieve a service provider from an `ImagingOrder` or a `Referral`
    ```python
    from canvas_sdk.v1.data.imaging import ImagingOrder
    from canvas_sdk.v1.data.referral import Referral
    imaging_order = ImagingOrder.objects.get(id="9d2e0f58-338b-11ec-8d3d-0242ac130003")
    imaging_order_service_provider = imaging_order.imaging_center
    referral = Referral.objects.get(id="9d2e0f58-338b-11ec-8d3d-0242ac130004")
    referral_service_provider = referral.service_provider
    ```
To show a `ServiceProvider` full name or full name with specialty use the properties `full_name` or `full_name_and_specialty`
    ```python
    from canvas_sdk.v1.data.service_provider import ServiceProvider
    service_provider = ServiceProvider.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    full_name = service_provider.full_name
    full_name_and_specialty = service_provider.full_name_and_specialty
    ```
##  Service Provider 
###  Fields 
Name | Type  
---|---  
id | UUID  
dbid | Integer  
first_name | String  
last_name | String  
business_fax | String  
business_phone | String  
business_address | String  
specialty | String  
practice_name | String  
notes | String
----- END PAGE https://docs.canvasmedical.com/sdk/data-serviceprovider/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-staff/
##  Introduction 
The `Staff` model represents a staff member in a Canvas instance.
To get a `Staff` object by it's identifier, use the `get` method:
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    ```
`Staff` objects are commonly used in related models, for example the `Task` model. To see all of a staff member's assigned or created tasks, the following code can be used:
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    staff.assignee_tasks.all()
    # <QuerySet [<Task: Task object (3)>]>
    staff.creator_tasks.all()
    # <QuerySet [<Task: Task object (7)>]>
    ```
To show a Staff member's contact points (email, phone, etc.), the `telecom` attribute can be used. For example:
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    [(t.system, t.value,) for t in staff.telecom.all()]
    # [('phone', '8005551416'), ('email', 'support@canvasmedical.com')]
    ```
To show a `Staff` full name, credentialed name, the topmost clinical role or top role abbreviation use the properties `full_name`, `credentialed_name`, `top_clinical_role` or `top_role_abbreviation`.
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    staff.full_name
    # Larry Weed
    staff.credentialed_name
    # Larry Weed MD
    staff.top_clinical_role.name
    # Physician
    staff.top_role_abbreviation
    # MD
    ```
To get `Staff` licenses.
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="4150cd20de8a470aa570a852859ac87e")
    staff.licenses.all()
    # <QuerySet [<StaffLicense: CA License for Larry Weed>]>
    ```
##  Attributes 
###  Staff 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
prefix | String  
suffix | String  
first_name | String  
middle_name | String  
last_name | String  
maiden_name | String  
nickname | String  
previous_names | JSON  
birth_date | Date  
sex_at_birth | [PersonSex](/sdk/data-enumeration-types/#personsex)  
sexual_orientation_term | String  
sexual_orientation_code | String  
gender_identity_term | String  
gender_identity_code | String  
preferred_pronouns | String  
biological_race_codes | Array[String]  
biological_race_terms | Array[String]  
cultural_ethnicity_codes | Array[String]  
cultural_ethnicity_terms | Array[String]  
last_known_timezone | TimeZone  
active | Boolean  
primary_practice_location | [PracticeLocation](/sdk/data-practicelocation/)  
npi_number | String  
nadean_number | String  
group_npi_number | String  
bill_through_organization | Boolean  
tax_id | String  
tax_id_type | [TaxIDType](/sdk/data-enumeration-types/#taxidtype)  
spi_number | String  
personal_meeting_room_link | URL  
state | JSON  
user | [CanvasUser](/sdk/data-canvasuser)  
supervising_team | Staff[]  
notes | Note[]  
creator_tasks | [Task](/sdk/data-task/#task)[]  
assignee_tasks | [Task](/sdk/data-task/#task)[]  
comments | [TaskComment](/sdk/data-task/#taskcomment)[]  
care_team_memberships | [CareTeamMembership](/sdk/data-care-team/#careteammembership)[]  
teams | [Team](/sdk/data-team/#team)[]  
telecom | StaffContactPoint[]  
###  StaffContactPoint 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
system | [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value | String  
use | String  
use_notes | String  
rank | Integer  
state | [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
staff | Staff  
###  StaffAddress 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
line1 | String  
line2 | String  
city | String  
district | String  
state_code | String  
postal_code | String  
use | [AddressUse](/sdk/data-enumeration-types/#addressuse)  
type | [AddressType](/sdk/data-enumeration-types/#addresstype)  
longitude | Float  
latitude | Float  
start | Date  
end | Date  
country | String  
state | String  
staff | Staff  
###  StaffLicense 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
staff | Staff  
issuing_authority_long_name | String  
issuing_authority_url | URL  
license_or_certification_identifier | String  
issuance_date | Date  
expiration_date | Date  
license_type | LicenseType  
primary | Boolean  
state | String  
###  StaffPhoto 
Field Name | Type  
---|---  
dbid | Integer  
created | DateTime  
modified | DateTime  
staff | Staff  
url | String  
title | String  
###  StaffRole 
Field Name | Type  
---|---  
dbid | Integer  
staff | Staff  
internal_code | String  
public_abbreviation | String  
domain | RoleDomain  
name | String  
domain_privilege_level | Integer  
permissions | JSON  
role_type | RoleType  
##  Enumeration types 
###  License Type 
Value | Description  
---|---  
CLIA | CLIA  
DEA | DEA  
PTAN | PTAN  
STATE_LICENSE | State License  
TAXONOMY | Taxonomy  
SPI | SPI  
OTHER | Other  
###  Role Domain 
Value | Abbreviation | Description  
---|---|---  
CLINICAL | CLI | Clinical  
ADMINISTRATIVE | ADM | Administrative  
HYBRID | HYB | Hybrid  
###  Role Type 
Value | Description  
---|---  
NON_LICENSED | Non-Licensed  
LICENSED | Licensed  
PROVIDER | Provider  
##  Computed Properties 
  - `photo_url`: The URL of the staff member's photo, if available, or a placeholder image URL.
----- END PAGE https://docs.canvasmedical.com/sdk/data-staff/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-stop-medication-event/
##  Introduction 
The `StopMedicationEvent` model represents a record of a Stop Medication Event, when a medication is removed from a patient's medication list.
##  Basic usage 
To get a stop medication event by identifier, use the `get` method on the `StopMedicationEvent` model manager:
    ```python
    from canvas_sdk.v1.data import StopMedicationEvent
    stopped_medication = StopMedicationEvent.objects.get(id="61a1853f-168f-4ed3-80d2-44e5d144bcf3")
    ```
If you have a patient object, the stop medication events for a patient can be accessed with the `stopped_medications` attribute on a `Patient` object:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    stopped_medications = patient.stopped_medications.all()
    ```
You can also access the referenced medication with the `medication` attribute:
    ```python
    from canvas_sdk.v1.data import StopMedicationEvent
    stopped_medication = StopMedicationEvent.objects.get(id="61a1853f-168f-4ed3-80d2-44e5d144bcf3")
    medication = stopped_medication.medication
    ```
Or for a given medication, you can access all stop events:
    ```python
    from canvas_sdk.v1.data import Medication
    medication = Medication.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    stopped_medication_events = medication.stopmedicationevent_set.all()
    ```
##  Attributes 
###  StopMedicationEvent 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
patient | [Patient](/sdk/data-patient/#patient)  
note | [Note](/sdk/data-note)  
medication | [Medication](/sdk/data-medication)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
committer | [CanvasUser](/sdk/data-canvasuser)  
originator | [CanvasUser](/sdk/data-canvasuser)  
created | DateTime  
modified | DateTime  
rationale | String  
----- END PAGE https://docs.canvasmedical.com/sdk/data-stop-medication-event/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-task/
##  Introduction 
A `Task` represents a to-do item to be addressed. Tasks can be assigned to individual staff members and can also have associated comments and labels.
##  Basic usage 
To get a task by it's identifier, use the `get` method on the `Task` model manager:
    ```python
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
    ```
From a `Patient` object, tasks for the patient can be accessed with the `tasks` attribute:
    ```python
    import arrow
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.v1.data.task import TaskStatus
    patient = Patient.objects.get(id="36950971cb3e4174ad8b9d365abfd6d0")
    # All tasks for the patient
    tasks_for_patient = patient.tasks.all()
    # Tasks for the patient that are overdue
    tasks_for_patient_overdue = patient.tasks.filter(due__lte=arrow.utcnow().datetime, status=TaskStatus.OPEN)
    ```
`Task` objects are also able to have associated `TaskLabel` objects.
    ```python
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
    [(label.name, label.color,) for label in task.labels.all()]
    # [('Emergent', 'red')]
    ```
`Staff` members are able to leave comments on tasks. These are stored as associated `TaskComment` objects. For example:
    ```python
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
    [(comment.creator, comment.body,) for comment in task.comments.all()]
    # [(<Staff: Sam Jones>, "Please call patient.")]
    ```
###  Note Tasks and Initial Comments 
A `NoteTask` represents the link between a Task command and the `Task` it generates. When a task is created via a Task command, a `NoteTask` record is created that stores the original values entered in the command. Of importance is the **initial comment** that is provided during task creation in the `internal_comment` field.
This is important because `task.comments.all()` only returns manual comments added after the task is created through the interface—it does not include the original comment entered during task creation. To access that initial comment, you need to use the `NoteTask` model.
To get a note task by its identifier:
    ```python
    from canvas_sdk.v1.data.task import NoteTask
    note_task = NoteTask.objects.get(id="a1b2c3d4-e5f6-7890-abcd-ef1234567890")
    print(f"Initial comment: {note_task.internal_comment}")
    ```
From a `Task` object, you can access the associated `NoteTask` to retrieve the initial comment:
    ```python
    from canvas_sdk.v1.data.task import Task
    task = Task.objects.get(id="7895e1db-f8de-4660-a0a3-9e5b43a475c6")
    # Access the NoteTask to get the initial comment
    note_task = task.note_tasks.first()
    if note_task:
        print(f"Initial comment: {note_task.internal_comment}")
        print(f"Original title: {note_task.original_title}")
        print(f"Original assignee: {note_task.original_assignee}")
    ```
Common workflow pattern: handling a TASK_CREATED event and accessing the initial comment:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data.task import Task
    class TaskCreatedHandler(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.TASK_CREATED)]
        def compute(self):
            task_id = self.target
            task = Task.objects.get(id=task_id)
            # Get the initial comment from the NoteTask
            note_task = task.note_tasks.first()
            if note_task:
                initial_comment = note_task.internal_comment
                # Use the initial comment for your logic
                self.log(f"Task created with initial comment: {initial_comment}")
    ```
From a `Note` object, note tasks can be accessed with the `note_tasks` attribute:
    ```python
    from canvas_sdk.v1.data.note import Note
    note = Note.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    note_tasks = note.note_tasks.all()
    for note_task in note_tasks:
        print(f"Task: {note_task.original_title}")
        print(f"Initial comment: {note_task.internal_comment}")
    ```
##  Attributes 
###  Task 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
creator | [Staff](/sdk/data-staff/#staff)  
assignee | [Staff](/sdk/data-staff/#staff)  
patient | [Patient](/sdk/data-patient/#patient)  
task_type | TaskType  
tag | String  
title | String  
due | DateTime  
due_event | EventType  
status | TaskStatus  
comments | TaskComment[]  
labels | TaskLabel[]  
metadata | TaskMetadata[]  
note_tasks | NoteTask[]  
###  NoteTask 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvas-user/)  
committer | [CanvasUser](/sdk/data-canvas-user/)  
entered_in_error | [CanvasUser](/sdk/data-canvas-user/)  
deleted | Boolean  
note | [Note](/sdk/data-note/#note)  
task | Task  
patient | [Patient](/sdk/data-patient/#patient)  
original_title | String  
original_assignee | [Staff](/sdk/data-staff/#staff)  
original_team | [Team](/sdk/data-team/)  
original_role | [CareTeamRole](/sdk/data-care-team/#careteamrole)  
original_due | DateTime  
internal_comment | String  
labels | TaskLabel[]  
###  TaskComment 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
creator | [Staff](/sdk/data-staff/#staff)  
task | [Task](/sdk/data-task/#task)  
body | String  
###  TaskLabel 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
tasks | M2M  
position | Integer  
color | [ColorEnum](/sdk/data-enumeration-types/#colorenum)  
task_association | [Origin](/sdk/data-enumeration-types/#origin)  
name | String  
active | Boolean  
modules | TaskLabelModule  
claims | [Claim](/sdk/data-claim)[]  
###  TaskMetadata 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
task | Task  
key | String  
value | String  
    ```python
    from canvas_sdk.v1.data.task import Task
    from logger import log
    task_id = "7895e1db-f8de-4660-a0a3-9e5b43a475c6"
    task = Task.objects.get(id=task_id)
    task_metadata = task.metadata.all()
    for metadata in task_metadata:
       log.info(f"Task metadata: {metadata.key}, {metadata.value}") # external_system_id - EXT-12345
    ```
##  Enumeration types 
###  TaskType 
Value | Label  
---|---  
Task | Task  
Reminder | Reminder  
###  EventType 
Value | Label  
---|---  
Chart Open | Chart Open  
###  TaskStatus 
Value | Label  
---|---  
COMPLETED | Completed  
CLOSED | Closed  
OPEN | Open  
###  TaskLabelModule 
Value | Label  
---|---  
claims | Claims  
tasks | Tasks  
----- END PAGE https://docs.canvasmedical.com/sdk/data-task/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-team/
##  Introduction 
The `Team` model represents a team of staff members in a Canvas instance.
##  Basic usage 
To get an team by identifier, use the `get` method on the `Team` model manager:
    ```python
    from canvas_sdk.v1.data.team import Team
    team = Team.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    ```
If you have a staff object, the teams that a staff is a member of can be accessed with the `teams` attribute on a `Staff` object:
    ```python
    from canvas_sdk.v1.data.staff import Staff
    staff = Staff.objects.get(id="1eed3ea2a8d546a1b681a2a45de1d790")
    teams = staff.teams.all()
    ```
##  Team Members 
The members of a team can be access with the `members` attribute on a `Team` object:
    ```python
    from canvas_sdk.v1.data.team import Team
    from logger import log
    team = Team.objects.get(id="b80b1cdc-2e6a-4aca-90cc-ebc02e683f35")
    for member in team.members.all():
        log.info(f"first_name: {member.first_name}")
        log.info(f"last_name: {member.last_name}")
    ```
##  Filtering 
Teams can be filtered by any attribute that exists on the model.
Filtering for teams is done with the `filter` method on the `Team` model manager.
###  By attribute 
Specify an attribute with `filter` to filter by that attribute:
    ```python
    from canvas_sdk.v1.data.team import Team
    teams = Team.objects.filter(created__gt="2025-01-01")
    ```
##  Attributes 
###  Team 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
name | String  
responsibilities | Array[TeamResponsibility]  
members | [Staff](/sdk/data-staff/#staff)[]  
###  TeamContactPoint 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
system | [ContactPointSystem](/sdk/data-enumeration-types/#contactpointsystem)  
value | String  
use | [ContactPointUse](/sdk/data-enumeration-types/#contactpointuse)  
use_notes | String  
rank | Integer  
state | [ContactPointState](/sdk/data-enumeration-types/#contactpointstate)  
team | Team  
##  Enumeration types 
###  TeamResponsibility 
Field Name | Type  
---|---  
COLLECT_SPECIMENS_FROM_PATIENT | Collect specimens from a patient  
COMMUNICATE_DIAGNOSTIC_RESULTS_TO_PATIENT | Communicate diagnostic results to patient  
COORDINATE_REFERRALS_FOR_PATIENT | Coordinate referrals for a patient  
PROCESS_REFILL_REQUESTS | Process refill requests from a pharmacy  
PROCESS_CHANGE_REQUESTS | Process change requests from a pharmacy  
SCHEDULE_LAB_VISITS_FOR_PATIENT | Schedule lab visits for a patient  
POPULATION_HEALTH_CAMPAIGN_OUTREACH | Population health campaign outreach  
COLLECT_PATIENT_PAYMENTS | Collect patient payments  
COMPLETE_OPEN_LAB_ORDERS | Complete open lab orders  
REVIEW_ERA_POSTING_EXCEPTIONS | Review electronic remittance posting exceptions  
REVIEW_COVERAGES | Review incomplete patient coverages  
----- END PAGE https://docs.canvasmedical.com/sdk/data-team/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-uncategorized-clinical-document/
##  Introduction 
The `UncategorizedClinicalDocument` and `UncategorizedClinicalDocumentReview` models represent uncategorized clinical documents and their reviews.
##  Basic Usage 
    ```python
    from canvas_sdk.v1.data import UncategorizedClinicalDocument, UncategorizedClinicalDocumentReview
    document = UncategorizedClinicalDocument.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
    review = UncategorizedClinicalDocumentReview.objects.get(id="c1a5a35a-4ee2-4a0e-85c0-21739dc8c4a8")
    ```
##  Filtering 
Uncategorized clinical documents and reviews can be filtered by any attribute that exists on the models.
###  By review mode 
Filter documents by their review mode:
    ```python
    from canvas_sdk.v1.data import UncategorizedClinicalDocument
    from canvas_sdk.commands.commands.review import ReviewMode
    documents_to_review = UncategorizedClinicalDocument.objects.filter(review_mode=ReviewMode.REVIEW_REQUIRED)
    ```
###  Unreviewed documents 
To get uncategorized documents that have not been reviewed yet and require a review:
    ```python
    from canvas_sdk.v1.data import UncategorizedClinicalDocument
    from canvas_sdk.commands.commands.review import ReviewMode
    from django.db.models import Q
    unreviewed_documents = UncategorizedClinicalDocument.objects.filter(Q(review_mode=ReviewMode.REVIEW_REQUIRED), (Q(review__committer__isnull=True) | Q(review__entered_in_error__isnull=False)))
    ```
##  Attributes 
###  UncategorizedClinicalDocument 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
patient | [Patient](/sdk/data-patient/#patient)  
originator | [CanvasUser](/sdk/data-canvasuser)  
assigned_by | [CanvasUser](/sdk/data-canvasuser)  
review | UncategorizedClinicalDocumentReview  
team | [Team](/sdk/data-team/#team)  
name | String  
review_mode | [DocumentReviewMode](/sdk/data-enumeration-types/#documentreviewmode)  
junked | Boolean  
requires_signature | Boolean  
assigned_date | DateTime  
team_assigned_date | DateTime  
original_date | Date  
comment | String  
priority | Boolean  
###  UncategorizedClinicalDocumentReview 
Field Name | Type  
---|---  
id | UUID  
dbid | Integer  
created | DateTime  
modified | DateTime  
originator | [CanvasUser](/sdk/data-canvasuser)  
deleted | Boolean  
committer | [CanvasUser](/sdk/data-canvasuser)  
entered_in_error | [CanvasUser](/sdk/data-canvasuser)  
internal_comment | String  
message_to_patient | String  
status | String  
patient | [Patient](/sdk/data-patient/#patient)  
patient_communication_method | String
----- END PAGE https://docs.canvasmedical.com/sdk/data-uncategorized-clinical-document/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data-value-sets/
##  Introduction 
The Canvas SDK includes a library of built-in Value Sets that can be used within plugins to assist with finding conditions or medications related to Electronic Clinical Quality Measures. Plugin developers can also create their own Value Sets and use them in the same manner as the Canvas built-in `ValueSet` classes.
Built-in Value Sets that can be imported into plugins can be found in the Canvas SDK open source repo [here](https://github.com/canvas-medical/canvas-plugins/tree/main/canvas_sdk/value_set/).
##  Usage 
**Filtering Conditions by Value Set**
Value Set classes can be used directly in the data module to query for conditions that are included within them. For example, to find if a patient has been diagnosed with a condition whose coding falls under a particular Value Set, the `find` method can be used as follows:
    ```python
    from logger import log
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.v2022.condition import EssentialHypertension
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    patient_essential_hypertension_conditions = patient.conditions.find(EssentialHypertension)
    # The patient has been diagnosed with one or more conditions that match a coding within the EssentialHypertension value set
    if patient_essential_hypertension_conditions:
        for condition in patient_essential_hypertension_conditions:
            log.info(condition.codings.all().values())
    ```
**Filtering Medications by Value Set**
Similar to the `Condition` example above, the `find` method can also utilize Value Set classes to filter `Medication` records that fall under a value set:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.v2022.medication import DementiaMedications
    from logger import log
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    patient_dementia_medications = patient.medications.find(DementiaMedications)
    if patient_dementia_medications:
        for medication in patient_dementia_medications:
            log.info(medication.codings.all().values())
    ```
**Filtering with more than one Value Set**
Sometimes it may be desirable to filter using more than one Value Set. For example, finding all of a patient's conditions that belong within `EssentialHypertension` _or_ `DiagnosisOfHypertension`. In this case, the `find` supports the pipe (`|`) operator to filter conditions that match the codings in either Value Set:
    ```python
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.v2022.condition import EssentialHypertension, DiagnosisOfHypertension
    from logger import log
    patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
    patient_hypertension_conditions = patient.conditions.find(EssentialHypertension | DiagnosisOfHypertension)
    if patient_hypertension_conditions:
        for condition in patient_hypertension_conditions:
            log.info(condition.codings.all().values())
    ```
##  Creating Custom Value Sets 
The Canvas SDK allows plugin developers to create their own ValueSet classes that can be used in the same manner as the examples above. To do so, one can import and inherit the base `ValueSet` class:
    ```python
    from canvas_sdk.value_set.value_set import ValueSet
    ```
A new class containing Python sets of coding values can be defined like so:
    ```python
    from canvas_sdk.value_set.value_set import ValueSet
    class MyCustomValueSet(ValueSet):
        VALUE_SET_NAME = "My Custom Value Set"
        ICD10CM = {
            "T2601XA",  # Burn of right eyelid and periocular area, initial encounter
        }
        SNOMEDCT = {
            "284537006",  # Eyelid burn (disorder)
        }
    ```
The valid code system constants that can be used to define sets of codes in Value Sets are:
Name | URL  
---|---  
`CPT` | `http://www.ama-assn.org/go/cpt`  
`HCPCSLEVELII` | `https://coder.aapc.com/hcpcs-codes`  
`CVX` | `http://hl7.org/fhir/sid/cvx`  
`LOINC` | `http://loinc.org`  
`SNOMEDCT` | `http://snomed.info/sct`  
`FDB` | `http://www.fdbhealth.com/`  
`RXNORM` | `http://www.nlm.nih.gov/research/umls/rxnorm`  
`ICD10` | `ICD-10`  
`NUCC` | `http://www.nucc.org/`  
`CANVAS` | `CANVAS`  
`INTERNAL` | `INTERNAL`  
`NDC` | `http://hl7.org/fhir/sid/ndc`  
The following code is an example of a custom `ValueSet` in use within a plugin:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.value_set.value_set import ValueSet
    class MyCustomValueSet(ValueSet):
        VALUE_SET_NAME = "My Custom Value Set"
        ICD10CM = {
            "T2601XA",  # Burn of right eyelid and periocular area, initial encounter
        }
        SNOMEDCT = {
            "284537006",  # Eyelid burn (disorder)
        }
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_UPDATED)
        def compute(self):
            patient = Patient.objects.get(id="6cbc40b408294a5f9b41f57ba1b2b487")
            custom_value_set_conditions = patient.conditions.find(MyCustomValueSet)
            for vs in custom_value_set_conditions:
                log.info(vs)
            return []
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/data-value-sets/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/data/
The data module provides you with data to compute on. It provides curated, secure access to both PHI (e.g. patient data) and non-PHI (e.g. staff and practice-level data), representing the current state of your target Canvas instance. The module's classes offer convenience methods and operators that make business logic and clinical logic easy to express with standard terminologies like ICD-10, SNOMED-CT, CPT, and the like.
Data module classes are Django ORM models, which allow easy retrieval of data at runtime through Django's expressive [QuerySet API](https://docs.djangoproject.com/en/5.1/ref/models/querysets/).
The pages below provide listings of the models, their attributes, and examples of usage.
[ AllergyIntolerance Harmful or undesired physiological responses associated with exposure to a substance. ](/sdk/data-allergy-intolerance/) [ Application A plugin application. ](/sdk/data-application/) [ Appointment A scheduled meeting between a patient and a provider. ](/sdk/data-appointment/) [ Assessment Clinical assessment of a patient's condition. ](/sdk/data-assessment/) [ BannerAlert An alert notification linked to a patient. ](/sdk/data-banner-alert/) [ BillingLineItem A billable code linked to a patient note. ](/sdk/data-billing-line-item/) [ BusinessLine A group of patients that share a common brand under an organization. ](/sdk/data-business-line/) [ Calendar Calendars associated with providers. ](/sdk/data-calendar/) [ CanvasUser User accounts associated with other records. ](/sdk/data-canvasuser/) [ CareTeam Teams assigned for patient care. ](/sdk/data-care-team/) [ ChargeDescriptionMaster Billing charges in Canvas that can be added to the note footer. ](/sdk/data-charge-description-master/) [ Claim A healthcare claim. ](/sdk/data-claim/) [ Command Structured units of documentation in a patient's chart. ](/sdk/data-command/) [ CommonEnumerationTypes Common choice classes used in multiple models. ](/sdk/data-enumeration-types/) [ CompoundMedication Compound medications, which are custom-made medications tailored to a patient's specific needs. ](/sdk/data-compound-medication/) [ Condition Condition, diagnosis, or reason for seeking medical attention. ](/sdk/data-condition/) [ Coverage Patient insurance coverage. ](/sdk/data-coverage/) [ DetectedIssue Actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient. ](/sdk/data-detected-issue/) [ Device Type of a manufactured item that is used in the provision of healthcare. ](/sdk/data-device/) [ EligibilitySummary Summary of copay and coinsurance for a Coverage. ](/sdk/data-coverage/#eligilibitysummary/) [ Encounter A patient Encounter connected to a Note in Canvas. ](/sdk/data-encounter/) [ ExternalEvent External clinical events from ADT feeds such as admissions, discharges, and transfers. ](/sdk/data-external-event/) [ Facility A location where healthcare services are provided. ](/sdk/data-facility/) [ Imaging Analysis of imaging tests to obtain information about the health of a patient. ](/sdk/data-imaging/) [ Immunization A record of a vaccination that is being administered to a patient, either now, in the past, or in the future. ](/sdk/data-immunization/) [ Labs Analysis of clinical specimens to obtain information about the health of a patient. ](/sdk/data-labs/) [ LabPartner Lab partners and the tests they offer within Canvas. ](/sdk/data-lab-partner-and-test/) [ Letter Patient correspondence letters created within Canvas. ](/sdk/data-letter/) [ Medication A record of a medication that is being consumed by a patient, either now, in the past, or in the future. ](/sdk/data-medication/) [ Medication History A record of a patient's medication history, including medications that were taken in the past but are no longer active. ](/sdk/data-medication-history/) [ Medication Statement A record of a medication statement by a patient from the past. ](/sdk/data-medication-statement/) [ Message Messages sent to and from Canvas. ](/sdk/data-message/) [ Note Clinical notes on patient charts. ](/sdk/data-note/) [ Observation Measurements and simple assertions made about a patient. ](/sdk/data-observation/) [ Organization The clinical organization present in the Canvas EMR. ](/sdk/data-organization/) [ Patient Data used to categorize individuals for identification, records matching, and other purposes. ](/sdk/data-patient/) [ PatientConsent Documented patient consents that ensure legal compliance and protect patient rights. ](/sdk/data-patient-consent/) [ PayorSpecificCharge A billing charge specific to a certain transactor in Canvas. ](/sdk/data-payor-specific-charge/) [ Posting Payments and postings associated with healthcare claims. ](/sdk/data-posting/) [ PracticeLocation The practice locations present in the Canvas EMR. ](/sdk/data-practicelocation/) [ ProtocolCurrent The current state of clinical protocols applied to patients within Canvas. ](/sdk/data-protocol-current/) [ ProtocolOverride A record of a protocol being snoozed for a patient. ](/sdk/data-protocol-override/) [ Stop Medication Event A record of a Stop Medication Event, when a medication is removed from a patient's medication list. ](/sdk/data-stop-medication-event/) [ Questionnaire Groups of coded questions and the coded patient responses. ](/sdk/data-questionnaire/) [ ReasonForVisit The reason for a patient's visit. ](/sdk/data-reason-for-visit/) [ Referral A referral directing a specific patient to another provider or specialist. ](/sdk/data-referral/) [ ServiceProvider Data associated with Service Providers. ](/sdk/data-serviceprovider/) [ Staff Data associated with Staff members. ](/sdk/data-staff/) [ Task Data associated with Tasks. ](/sdk/data-task/) [ Team Data associated with Teams. ](/sdk/data-team/) [ Uncategorized Clinical Documents Data associated with uncategorized clinical documents and their reviews. ](/sdk/data-uncategorized-clinical-document/) [ ValueSets Lists of codes and terms from various clinical coding systems grouped by a defining concept. ](/sdk/data-value-sets/)
----- END PAGE https://docs.canvasmedical.com/sdk/data/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/default-homepage-effect/
##  Overview 
This allows developers to set a provider's default homepage in Canvas. The default homepage is the page that a provider sees when they log in to Canvas. This effect can be used to set the default homepage to a specific page or a plugin application.
    ```python
    from canvas_sdk.effects.default_homepage import DefaultHomepageEffect
    DefaultHomepageEffect(page=DefaultHomepageEffect.Pages.PATIENTS).apply()
    ```
    ```python
    from canvas_sdk.effects.default_homepage import DefaultHomepageEffect
    DefaultHomepageEffect(application_identifier="app_identifier").apply()
    ```
##  Structure 
###  **Pages**
An enumeration of pages that can be set as the default homepage:
Value  
---  
`PATIENTS`  
`SCHEDULE`  
`REVENUE`  
`CAMPAIGNS`  
`DATA_INTEGRATION`  
###  **DefaultHomepage**
A DefaultHomepage effect consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`page` | `Pages \| None` | Optional page  
`application_identifier` | `str \| None` | Optional application identifier  
If both `page` and `application_identifier` are provided, `application_identifier` will take precedence and the default homepage will be set to the specified application. If neither is provided, the default homepage will be set to the Canvas default homepage.
----- END PAGE https://docs.canvasmedical.com/sdk/default-homepage-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-appointment-labels/
#  Appointment Label Effects 
The appointment label effects provide programmatic management of labels in Canvas. Labels serve as visual indicators and categorization tools, enabling automated workflows and improved organization for appointments.
##  Overview 
Labels are a powerful way to categorize and track appointments. Canvas supports up to 3 labels per appointment, and these effects allow plugins to automatically manage labels based on business logic.
##  AddAppointmentLabel Effect 
The `AddAppointmentLabel` effect adds one or more labels to an existing appointment.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`appointment_id` | `str` | ID of the appointment to add labels to | Yes  
`labels` | `set[str]` | Set of label names to add (1-3 labels total per appointment) | Yes  
###  apply() → Effect 
Adds the specified labels to the appointment.
####  Returns 
An `Effect` object configured for adding appointment labels.
####  Behavior 
  - Labels are added to the appointment if the total count doesn't exceed 3
  - Labels are automatically sorted for consistency
  - Duplicate labels are ignored (labels are stored as a set)
  - Validates the appointment exists before adding labels
  - Validates label names are non-empty strings
  - Returns an error if adding labels would exceed the 3-label limit
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.appointment import AddAppointmentLabel
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class MyHandler(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.APPOINTMENT_CREATED)]
        def compute(self):
            # Add labels to an appointment
            effect = AddAppointmentLabel(
                appointment_id="appointment-uuid",
                labels={"URGENT", "FOLLOW_UP"}
            )
            return [effect.apply()]
    ```
If more than three labels are attempted to be added, a `ValidationError` will be raised.
    ```python
    from canvas_sdk.effects.note.appointment import AddAppointmentLabel
    from canvas_sdk.exceptions import ValidationError
    def handle_validation_errors():
        # Example of handling validation errors
        try:
            effect = AddAppointmentLabel(
                appointment_id="invalid-id",
                labels={"LABEL1", "LABEL2", "LABEL3", "LABEL4"}  # Would exceed limit
            )
            return [effect.apply()]
        except ValidationError as e:
            # Handle validation errors
            return []
    ```
* * *
##  RemoveAppointmentLabel Effect 
The `RemoveAppointmentLabel` effect removes one or more labels from an existing appointment.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`appointment_id` | `str` | ID of the appointment to remove labels from | Yes  
`labels` | `set[str]` | Set of label names to remove | Yes  
###  apply() → Effect 
Removes the specified labels from the appointment.
####  Returns 
An `Effect` object configured for removing appointment labels.
####  Behavior 
  - Removes the specified labels from the appointment
  - Non-existent labels are ignored (no error thrown)
  - Validates the appointment exists before removing labels
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.appointment import RemoveAppointmentLabel
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class MyHandler(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.APPOINTMENT_LABEL_REMOVED)]
        def compute(self):
            # Remove labels from an appointment
            effect = RemoveAppointmentLabel(
                appointment_id="appointment-uuid",
                labels={"CANCELLED", "RESCHEDULED"}
            )
            return [effect.apply()]
    ```
* * *
##  Implementation Details 
###  Label Constraints 
  - **Maximum labels** : 3 labels per appointment (enforced by validation)
  - **Label format** : Labels are strings, automatically sorted for consistency
  - **Uniqueness** : Labels are stored as a set, preventing duplicates
  - **Case sensitivity** : Label names are case-sensitive
###  Validation Messages 
The effects provide clear error messages for common issues:
  - `"Appointment {appointment_id} does not exist"` \- When appointment ID is invalid
  - `"Limit reached: Only 3 appointment labels allowed. Attempted to add {count} label(s) to appointment with {existing} existing label(s)."` \- When label limit would be exceeded
These effects work seamlessly with appointment label events:
  - `APPOINTMENT_LABEL_ADDED` \- Fired when labels are added
  - `APPOINTMENT_LABEL_REMOVED` \- Fired when labels are removed
For more information on these events, see [Appointment Events](/sdk/events/#appointments).
##  Related Documentation 
  - [Appointment Events](/sdk/events/#appointments) \- Event documentation
  - [Appointment Coverage Label Example](/sdk/examples/appointment_coverage_label/) \- Real-world example plugin
----- END PAGE https://docs.canvasmedical.com/sdk/effect-appointment-labels/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-appointment-metadata/
The `AppointmentMetadata` effect provides a flexible key-value storage system for appointment-specific data within the Canvas system. This effect enables the creation and updating of custom metadata entries associated with appointment records. This allows for extensible appointment information storage beyond standard scheduling fields.
##  Overview 
Appointment metadata serves as a powerful extension mechanism for storing custom appointment-related information that doesn't fit within the standard appointment data model. It uses the `.upsert(value)` method to apply a value to the key attributed with the Metadata effect object.
##  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`appointment_id` | `str` | Id of the [Appointment(/sdk/data-appointment/)] record to associate metadata with | Yes  
`key` | `str` | Unique identifier for the metadata entry within the appointment context | Yes  
##  Methods 
###  upsert(value: str) → Effect 
Creates or updates a metadata entry for the specified appointment and key combination.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`value` | `str` | The metadata value to store | Yes  
####  Returns 
An `Effect` object configured for upserting appointment metadata.
####  Behavior 
  - If a metadata entry with the specified key already exists for the appointment, it will be updated with the new value
  - If no entry exists, a new metadata entry will be created
  - The operation is idempotent - repeated calls with the same key and value will not create duplicate entries
##  Implementation Details 
###  Validation 
The effect performs comprehensive validation before execution:
  1. **Appointment Existence Validation** : Verifies that the referenced appointment exists in the system
  - Queries the appointment database to confirm the `appointment_id` corresponds to an existing appointment record
  - Returns a descriptive error if the appointment is not found
  1. **Field Validation** : Ensures all required fields are provided and properly formatted
  - Both `appointment_id` and `key` must be non-empty strings
  - The `value` parameter in the `upsert` method must be provided
###  Data Structure 
The effect payload is structured as JSON with the following schema:
    ```json
    {
      "data": {
        "appointment_id": "appointment-id",
        "key": "metadata-key",
        "value": "metadata-value"
      }
    }
    ```
##  Example Usage 
###  Basic Usage 
    ```python
    from canvas_sdk.effects.appointments_metadata.base import AppointmentsMetadata
    # Create a metadata entry for appointment state
    metadata = AppointmentsMetadata(
        appointment_id="550e8400e29b41d4a716446655440001",
        key="state"
    )
    # Upsert the metadata value
    effect = metadata.upsert("CA")
    ```
##  Best Practices 
###  Key Naming Conventions 
  1. **Use Descriptive Names** : Choose keys that clearly indicate the purpose of the metadata
  - Good: `external_mrn`, `preferred_pharmacy_id`, `risk_score_diabetes`
  - Avoid: `data1`, `temp`, `misc`
  1. **Namespace Your Keys** : When building integrations or modules, prefix keys to avoid collisions
  - Example: `integration_patient_id`, `module_diabetes_last_a1c_date`
###  Value Storage 
  1. **String Serialization** : All values are stored as strings. For complex data types:
         ```python
         import json
         from canvas_sdk.effects.appointments_metadata.base import AppointmentsMetadata
         metadata = AppointmentsMetadata(
             appointment_id="550e8400e29b41d4a716446655440001",
             key="result"
         )
         complex_data = {"scores": [85, 92, 78], "average": 85.0}
         metadata.upsert(json.dumps(complex_data))
         ```
  2. **Boolean Values** : Store as "true" or "false" strings for consistency
         ```python
         from canvas_sdk.effects.appointments_metadata.base import AppointmentsMetadata
         consented = True
         metadata = AppointmentsMetadata(
             appointment_id="550e8400e29b41d4a716446655440001",
             key="boolean_value"
         )
         metadata.upsert("true" if consented else "false")
         ```
##  Notes 
  - Metadata entries are appointment-specific and isolated - the same key can have different values for different appointments
  - There is no built-in versioning; updating a key overwrites the previous value
  - The system does not enforce any schema on metadata values - validation is the responsibility of the implementing code
----- END PAGE https://docs.canvasmedical.com/sdk/effect-appointment-metadata/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-banner-alerts/
The Canvas SDK allows you to place Banners on the Canvas UI.
##  Adding a Banner Alert 
To add a banner alert, import the `AddBannerAlert` class and create an instance of it.
Attribute |  | Type | Description  
---|---|---|---  
patient_id | required (if patient_filter is not provided) | String | The id of the [patient](/sdk/data-patient/) the alert should be associated with.  
patient_filter | required (if patient_id is not provided) | String | Patient queryset filters to apply the effect to multiple patients. For example, `{"active": True}` will apply to the effect to all active patients  
key | required | String | An identifier that categorizes the alert.  
narrative | required | String | The content of the alert. Maximum 90 characters.  
placement | required | list[Placement] | List of areas the alert should show.  
intent | optional | Intent | Affects the styling of the alert.  
href | optional | String | If given, the alert will appear as a link to this URL.  
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.banner_alert import AddBannerAlert
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_UPDATED)
        def compute(self):
            banner = AddBannerAlert(
                patient_id=self.target,
                key="test-alert",
                narrative="This is only a test.",
                placement=[
                    AddBannerAlert.Placement.CHART,
                    AddBannerAlert.Placement.APPOINTMENT_CARD,
                    AddBannerAlert.Placement.SCHEDULING_CARD,
                ],
                intent=AddBannerAlert.Intent.INFO,
                href="https://docs.canvasmedical.com",
            )
            return [banner.apply()]
    ```
To apply the effect to all active patients when a plugin is created or updated, include the `PLUGIN_CREATED` and/or `PLUGIN_UPDATED` events in the `RESPONDS_TO` list. Additionally, `patient_filter` can be used (instead of `patient_id`) on the `AddBannerAlert` class.
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.banner_alert import AddBannerAlert
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PATIENT_UPDATED),
            EventType.Name(EventType.PLUGIN_CREATED),
            EventType.Name(EventType.PLUGIN_UPDATED),
        ]
        def compute(self):
            banner = AddBannerAlert(
                key="test-alert",
                narrative="This is only a test.",
                placement=[
                    AddBannerAlert.Placement.CHART,
                    AddBannerAlert.Placement.APPOINTMENT_CARD,
                    AddBannerAlert.Placement.SCHEDULING_CARD,
                ],
                intent=AddBannerAlert.Intent.INFO,
                href="https://docs.canvasmedical.com",
            )
            if self.event.type in [EventType.PLUGIN_CREATED, EventType.PLUGIN_UPDATED]:
                banner.patient_filter = {"active": True}
            else:
                banner.patient_id = self.target
            return [banner.apply()]
    ```
###  Placement 
This determines where the banner alert appears.
####  `Placement.CHART`
This will place the banner under the patient's name on their chart
![](/assets/images/sdk/banner-alerts/banner_alert_placement_chart.png)
####  `Placement.TIMELINE`
This will place the banner on the top of the patient's timeline of notes in their chart
![](/assets/images/sdk/banner-alerts/banner_alert_placement_timeline.png)
####  `Placement.APPOINTMENT_CARD`
This will appear when you click an appointment on the calendar view
![](/assets/images/sdk/banner-alerts/banner_alert_placement_appointment_card.png)
####  `Placement.SCHEDULING_CARD`
This will appear when you select a patient during the scheduling of an appointment on the calendar view
![](/assets/images/sdk/banner-alerts/banner_alert_placement_scheduling_card.png)
####  `Placement.PROFILE`
This will place the banner under the patient's name on their patient registration page
![](/assets/images/sdk/banner-alerts/banner_alert_placement_profile.png)
###  Intent 
The type or severity of an alert. This will change the appearance of the banner alert.
####  `Intent.INFO`
![](/assets/images/sdk/banner-alerts/banner_alert_intent_info.png)
####  `Intent.WARNING`
![](/assets/images/sdk/banner-alerts/banner_alert_intent_warning.png)
####  `Intent.ALERT`
![](/assets/images/sdk/banner-alerts/banner_alert_intent_alert.png)
##  Removing a Banner Alert 
Removing a banner alert is done wih the `RemoveBannerAlert` class. Create an instance of the class, identifying the key of the alert and the patient id. Return the Effect by calling the `.apply()` method. Both the `key` and `patient_id` attributes are required.
    ```python
    from canvas_sdk.effects.banner_alert import RemoveBannerAlert
    banner_alert = RemoveBannerAlert(
        key='test-alert',
        patient_id="d4c933fe8f6948f6a7d2a42a2641b13b",
    )
    banner_alert.apply()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/effect-banner-alerts/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-batch-originate/
##  Overview 
The `BatchOriginateCommandEffect` provides an efficient way to insert multiple commands into a note simultaneously. When you need to create many commands at once, using batch originate significantly improves performance compared to individual originate operations.
**Parameters:**
Attribute | Type | Required | Description  
---|---|---|---  
`commands` | `list` | `true` | List of command instances to batch originate  
**Returns:**
An `Effect` that can be applied to originate all commands in a single operation.
##  How It Works 
The batch originate effect processes multiple commands in a single operation:
  1. **Command Preparation** : Each command in the list required all necessary fields for `originate`
  2. **Note Update** : The note is updated once with all command UUIDs, rather than updating for each command individually
This approach minimizes database round-trips and improves overall performance.
##  Basic Usage 
    ```python
    from canvas_sdk.commands import (
        PlanCommand,
        HistoryOfPresentIllnessCommand,
        QuestionnaireCommand,
        DiagnoseCommand
    )
    from canvas_sdk.effects.batch_originate import BatchOriginateCommandEffect
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import Questionnaire, Note
    from canvas_sdk.events import EventType
    class Handler(BaseHandler):
        def compute(self):
            note_uuid = Note.objects.last().id
            # Create multiple commands
            plan1 = PlanCommand()
            plan1.narrative = "Order labs for lipid panel"
            plan1.note_uuid = note_uuid
            plan2 = PlanCommand()
            plan2.narrative = "Schedule follow-up in 3 months"
            plan2.note_uuid = note_uuid
            hpi = HistoryOfPresentIllnessCommand()
            hpi.narrative = "Annual wellness visit"
            hpi.note_uuid = note_uuid
            diagnose = DiagnoseCommand()
            diagnose.icd10_code = "E11.9"
            diagnose.note_uuid = note_uuid
            diagnose.background = "Type 2 diabetes mellitus"
            # Add a questionnaire
            questionnaire = QuestionnaireCommand()
            questionnaire.note_uuid = note_uuid
            questionnaire_id = Questionnaire.objects.filter(
                name="Patient Health Questionnaire"
            ).first()
            if questionnaire_id:
                questionnaire.questionnaire_id = str(questionnaire_id.id)
            # Batch originate all commands
            commands_to_originate = [plan1, plan2, hpi, diagnose, questionnaire]
            return [BatchOriginateCommandEffect(commands=commands_to_originate).apply()]
    ```
##  Related Documentation 
  - [Commands Overview](/sdk/commands)
----- END PAGE https://docs.canvasmedical.com/sdk/effect-batch-originate/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-billing-line-items/
The Canvas SDK allows you to create, update, and remove Billing Line Items from the footer of a note.
##  Adding a Billing Line Item 
To add a billing line item to a note, import the `AddBillingLineItem` class, create an instance of it, and return the `.apply()` method from compute.
Attribute |  | Type | Description  
---|---|---|---  
note_id | required | String | The id of the [Note](/sdk/data-note/) where the line item should be associated.  
cpt | required | String | The billing code to use for the line item.  
units | optional | Integer | The number of units to bill for the code. Defaults to `1` if not provided.  
assessment_ids | optional | list[String] | List of Assessment ids from the note that are relevant to the code, also referred to as "diagnosis pointers".  
modifiers | optional | list[Coding] | The modifiers to create with the billing code.  
**Example:**
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Command, Assessment
    from canvas_sdk.effects.billing_line_item import AddBillingLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PERFORM_COMMAND__POST_ORIGINATE)
        ]
        def compute(self) -> list[Effect]:
            command_id = self.target
            command = Command.objects.get(id=command_id)
            note = command.note
            assessments = [
                str(i)
                for i in Assessment.objects.filter(note_id=note.dbid).values_list(
                    "id", flat=True
                )
            ]
            b = AddBillingLineItem(
                note_id=str(note.id),
                cpt="99213",
                units=1,
                assessment_ids=assessments,
                modifiers=[
                    {"code": "25", "system": "http://www.ama-assn.org/go/cpt"},
                    {"code": "59", "system": "http://www.ama-assn.org/go/cpt"},
                ],
            )
            return [b.apply()]
    ```
##  Updating a Billing Line Item 
To update a billing line item to a note, import the `UpdateBillingLineItem` class, create an instance of it, and return the `.apply()` method from compute.
Attribute |  | Type | Description  
---|---|---|---  
billing_line_item_id | required | String | The id of the [BillingLineItem](/sdk/data-billing-line-item/) to update.  
cpt | optional | String | The billing code to use for the line item.  
units | optional | Integer | The number of units to bill for the code.  
assessment_ids | optional | list[String] | List of Assessment ids from the note that are relevant to the code, also referred to as "diagnosis pointers".  
modifiers | optional | list[Coding] | The modifiers to create with the billing code.  
**Example:**
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Assessment, Command, BillingLineItem
    from canvas_sdk.effects.billing_line_item import UpdateBillingLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PERFORM_COMMAND__POST_COMMIT)
        ]
        def compute(self) -> list[Effect]:
            command_id = self.target
            command = Command.objects.get(id=command_id)
            note = command.note
            cpt = command.data["perform"]["value"]
            b_ids = BillingLineItem.objects.filter(cpt="99213", note=note).values_list(
                "id", flat=True
            )
            assessment = Assessment.objects.filter(note_id=note.dbid).first()
            updates = [
                UpdateBillingLineItem(
                    billing_line_item_id=str(b_id),
                    cpt=cpt,
                    units=1,
                    assessment_ids=[str(assessment.id)],
                    modifiers=[{"code": "47", "system": "http://www.ama-assn.org/go/cpt"}],
                )
                for b_id in b_ids
            ]
            return [update.apply() for update in updates]
    ```
##  Removing a Billing Line Item 
To remove a billing line item to a note, import the `RemoveBillingLineItem` class, create an instance of it, and return the `.apply()` method from compute.
Attribute |  | Type | Description  
---|---|---|---  
billing_line_item_id | required | String | The id of the [BillingLineItem](/sdk/data-billing-line-item/) to update.  
|  |  |   
**Example:**
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Command, BillingLineItem
    from canvas_sdk.effects.billing_line_item import RemoveBillingLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PERFORM_COMMAND__POST_ENTER_IN_ERROR)
        ]
        def compute(self) -> list[Effect]:
            command_id = self.target
            command = Command.objects.get(id=command_id)
            cpt = command.data["perform"]["value"]
            note_id = command.note.dbid
            b_ids = BillingLineItem.objects.filter(cpt=cpt, note_id=note_id).values_list(
                "id", flat=True
            )
            return [
                RemoveBillingLineItem(billing_line_item_id=str(b_id)).apply()
                for b_id in b_ids
            ]
    ```
For more information about the BillingLineItem data class, check out [this page](/sdk/data-billing-line-item).
----- END PAGE https://docs.canvasmedical.com/sdk/effect-billing-line-items/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-claims/
The Canvas SDK provides effects to facilitate managing claims. The `ClaimEffect` class provides a unified interface for:
  - adding labels to claims
  - removing labels from claims
  - moving claim to a queue
  - adding comments to claims
  - posting payments to claims
Additionally, the SDK provides a separate effect to update claim line items.
The following standalone effect classes are deprecated and will be removed in a future release. Please use the `ClaimEffect` class instead.
Deprecated Class | Old Import Path | New Equivalent  
---|---|---  
`AddClaimLabel` | `canvas_sdk.effects.claim_label` | `ClaimEffect.add_labels()`  
`RemoveClaimLabel` | `canvas_sdk.effects.claim_label` | `ClaimEffect.remove_labels()`  
`MoveClaimToQueue` | `canvas_sdk.effects.claim_queue` | `ClaimEffect.move_to_queue()`  
`AddClaimComment` | `canvas_sdk.effects.claim_comment` | `ClaimEffect.add_comment()`  
`PostClaimPayment` | `canvas_sdk.effects.payment` | `ClaimEffect.post_payment()`  
##  Claim Effect 
The `ClaimEffect` class facilitates operations on existing claims.
`from canvas_sdk.effects.claim import ClaimEffect`
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`claim_id` | `UUID` or `str` | Identifier for the claim | Yes  
###  Add Labels 
`ClaimEffect.add_labels()`: adds one or more labels to a claim, and optionally creates new labels before assigning them to the claim.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`labels` | `list[str or Label]` | List of label names and Label dataclasses* to apply to the claim | Yes  
*Labels can be passed in by name or as a Label dataclass. If the label with the provided name or values does not exist in your Canvas instance, it will be created and then applied to the specified claim. However, if a label already exists with the provided name or properties, it will add this existing label to the claim.
####  Label 
The `Label` dataclass represents a label with specific properties, including color and name.
Attribute | Type | Description | Required  
---|---|---|---  
`color` | [ColorEnum](/sdk/data-enumeration-types/#colorenum) | The color of the label in the UI | Yes  
`name` | `str` | The display name of the label | Yes  
####  Implementation Details 
  - Validates `claim_id` is provided and that the associated claim exists.
  - Validates that `labels` are provided and non-empty.
####  Example Usage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.claim import ClaimEffect, Label
    from canvas_sdk.v1.data import Note
    from canvas_sdk.v1.data.common import ColorEnum
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_CREATED)
        def compute(self) -> list[Effect]:
            """Creates and adds a new label the claim when charges are pushed.
            Adds the existing Urgent label when the note is locked."""
            note = Note.objects.get(id=self.event.context["note_id"])
            claim = note.get_claim()
            state = self.event.context["state"]
            if state == "PSH":
                claim_effect = ClaimEffect(claim_id=claim.id)
                return [claim_effect.add_labels([Label(color=ColorEnum.PINK, name="pushed not locked")])]
            elif state == "LKD":
                claim_effect = ClaimEffect(claim_id=claim.id)
                return [claim_effect.add_labels(["Urgent"])]
            return []
    ```
###  Remove Labels 
`ClaimEffect.remove_labels()`: removes existing labels from a claim.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`labels` | `list[str]` | List of label names to remove from the claim | Yes  
####  Implementation Details 
  - Validates `claim_id` is provided and that the associated claim exists
  - Validates `labels` is provided and non-empty
####  Example Usage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.claim import ClaimEffect
    from canvas_sdk.v1.data import Note
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_CREATED)
        def compute(self) -> list[Effect]:
            """When note is locked, remove the 'pushed not locked' label from the claim."""
            note = Note.objects.get(id=self.event.context["note_id"])
            claim = note.get_claim()
            state = self.event.context["state"]
            if state == "LKD":
                claim_effect = ClaimEffect(claim_id=claim.id)
                return [claim_effect.remove_labels(["pushed not locked"])]
            return []
    ```
###  Move to Queue 
`ClaimEffect.move_to_queue()`: moves a claim to a specific queue.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`queue` | `str` | The name of the queue to move the claim to, which must be a [valid name](/sdk/data-claim/#claimqueues) | Yes  
####  Implementation Details 
  - Validates `claim_id` is provided and that the associated claim exists
  - Validates `queue` is provided and the [queue with that name exists](/sdk/data-claim/#claimqueues)
####  Example Usage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.claim import ClaimEffect
    from canvas_sdk.v1.data import Note
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_CREATED)
        def compute(self) -> list[Effect]:
            if self.event.context["state"] == "ULK":
                note = Note.objects.get(id=self.event.context["note_id"])
                claim = note.get_claim()
                claim_effect = ClaimEffect(claim_id=str(claim.id))
                return [claim_effect.move_to_queue("NeedsClinicianReview")]
            return []
    ```
###  Add Comment 
`ClaimEffect.add_comment()`: creates a new comment on a claim.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`comment` | `str` | The comment text to add | Yes  
####  Implementation Details 
  - Validates `claim_id` is provided and that the associated claim exists
####  Example Usage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects.claim import ClaimEffect
    from canvas_sdk.v1.data import Patient, Claim
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.COVERAGE_CREATED)
        def compute(self) -> list[Effect]:
            pt = Patient.objects.get(id=self.event.context["patient"]["id"])
            # patient's claims that have not been submitted yet
            pt_claims = Claim.objects.filter(
                note__patient=pt, current_queue__queue_sort_ordering__in=[1, 2, 3, 4]
            )
            return [
                ClaimEffect(claim_id=claim.id).add_comment(
                    "Patient has a new coverage, please confirm if this claim's coverage info should be updated."
                )
                for claim in pt_claims
            ]
    ```
###  Post Payment 
`ClaimEffect.post_payment()`: posts a payment to a claim, specifying payment details and line item transactions. This method supports payments from insurance or patient and allows you to specify payments, adjustments, transfers, and write-offs on individual claim line items.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`claim_coverage_id` | `UUID`, `str`, or `'patient'` | Identifier for the coverage or the string `'patient'` for patient payments. | Yes  
`line_item_transactions` | `list[LineItemTransaction]` | List of LineItemTransactions for claim line items. | Yes  
`method` | `PaymentMethod` | The PaymentMethod used (e.g., `cash`, `check`, `card`, `other`). | Yes  
`move_to_queue_name` | `str` | Name of the queue to move the claim to after payment. | No  
`claim_description` | `str` | Description for the claim allocation. | No  
`check_date` | `date` | Date of the check (required if method is `check`). | No  
`check_number` | `str` | Check number (required if method is `check`). | No  
`deposit_date` | `date` | Date the payment was deposited. | No  
`payment_description` | `str` | Description of the payment. | No  
####  Validations and Implementation Details 
  - `check_number` and `check_date` are required if payment method is `check`
  - `claim_id` must correspond to a valid existing claim. For insurance payments, there are a few ways to help you identify the correct claim using the [Claim](/sdk/data-claim/#claim), [ClaimSubmission](/sdk/data-claim/#claimsubmission), [ClaimCoverage](/sdk/data-claim/#claimcoverage) data models: 
    - `Claim.account_number` is the identifier that Canvas sends to the clearinghouse as a unique Canvas identifier for the claim.
    - `ClaimSubmission.clearinghouse_claim_id` is the identifier that the clearinghouse sends back to Canvas after they have accepted the claim, and is used for the clearinghouse's internal tracking of the claim.
    - `ClaimCoverage.payer_icn` is the identifier that the insurance company uses for their internal tracking of the claim, and is usually provided to Canvas via the clearinghouse.
  - `claim_coverage_id` must be either the string `"patient"` or correspond to a valid and **active** [ClaimCoverage](/sdk/data-claim/#claimcoverage) for the Claim. 
    - A helpful way to identify the correct claim coverage is to use the method `get_coverage_by_payer_id(payer_id: str, subscriber_number: str | None = None)` on the [Claim](/sdk/data-claim/#claim) data model, where `payer_id` is the standard id for the insurance company. You can optionally provide `subscriber_number` if it's possible that the patient has multiple coverages from the same payer and you want to identify the correct coverage.
  - `move_to_queue_name` must be a valid label from [ClaimQueue](/sdk/data-claim/#claimqueues), but is not required. If provided, the claim will move to this queue after payment is applied.
####  LineItemTransaction 
Attribute | Type | Description | Required  
---|---|---|---  
`claim_line_item_id` | `UUID` or `str` | Identifier for the claim line item. | Yes  
`charged` | `Decimal` | Charged amount for the line item. | No  
`allowed` | `Decimal` | Allowed amount for the line item. | No  
`payment` | `Decimal` | Payment amount for the line item. | No  
`adjustment` | `Decimal` | Adjustment amount for the line item. | No  
`adjustment_code` | `str` | Code describing the adjustment. | No  
`transfer_remaining_balance_to` | `UUID`, `str`, or `'patient'` | Transfer remaining balance to another payer or patient. | No  
`write_off` | `bool` | Whether to write off the remaining balance. | No  
#####  LineItemTransaction Validations 
  - `claim_line_item_id` must be a valid and **active** line item for the claim. It is recommended to search for it using `.active()` and by `proc_code`, e.g. `claim.line_items.active().filter(proc_code="99215").first()`
  - There can be many LineItemTransactions for the same `claim_line_item_id`, but the first LineItemTransaction for a claim line item must specify either a payment or an adjustment (or allowed amount); subsequent transactions require an adjustment.
  - If an `adjustment` is specified, an `adjustment_code` must also be provided.
  - If the adjustment code is for a transfer (code starts with "Transfer"), a valid `transfer_remaining_balance_to` must be provided, and it cannot be the same payer as the `claim_coverage_id` payer.
  - `transfer_remaining_balance_to` can only be made to the patient (using the string `"patient"`) or to an **active** `claim_coverage_id` for the claim.
  - Adjustments cannot simultaneously write off and transfer the same amount; only one of `write_off` or `transfer_remaining_balance_to` should be set on LineItemTransactions where `adjustment` is present.
  - Adjustments and transfers are not allowed for COPAY charges, i.e. claim line items where the proc_code = `COPAY`. Only payments are allowed for those line items.
  - `payment` on COPAY line items must have a `claim_coverage_id` equal to `"patient"`.
  - `allowed` should be empty or $0 if `claim_coverage_id` is equal to `"patient"`.
####  PaymentMethod Enumeration Type 
Enum | Value  
---|---  
`CASH` | cash  
`CHECK` | check  
`CARD` | card  
`OTHER` | other  
####  Example Usage 
The most common use case for this method will be with the [SimpleAPI](/sdk/handlers-simple-api-http/) handler.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.v1.data import ClaimLineItem, Claim
    from decimal import Decimal
    from canvas_sdk.effects.claim import (
        ClaimEffect,
        PaymentMethod,
        LineItemTransaction,
    )
    from datetime import date
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/post-claim-payment"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            # replace with desired authentication logic
            return True
        def get_claim_line_item(self, claim: Claim, proc_code: str) -> ClaimLineItem | None:
            return claim.line_items.active().filter(proc_code=proc_code).first()
        def create_line_item_transactions(
            self, charge: dict, claim: Claim, next_coverage_id: str
        ) -> list[LineItemTransaction]:
            transactions = []
            if not (line_item := self.get_claim_line_item(claim, charge.get("proc_code"))):
                return transactions
            charged = Decimal(charge["charge"])
            payment = Decimal(charge["paid"])
            allowed = Decimal(charge["allowed"])
            adjustments = charge.get("adjustment", [])
            first_adjustment = adjustments[0]
            payment = LineItemTransaction(
                claim_line_item_id=line_item.id,
                charged=charged,
                payment=payment,
                allowed=allowed,
                adjustment=Decimal(first_adjustment["amount"]),
                adjustment_code=f"{first_adjustment['group']}-{first_adjustment['code']}",
                # replace with whatever logic needed for resolving remaining balance
                transfer_remaining_balance_to="patient"
                if first_adjustment["group"] == "PR"
                else next_coverage_id,
            )
            transactions.append(payment)
            additional_adjustments = adjustments[1:]
            for adj in additional_adjustments:
                transaction = LineItemTransaction(
                    claim_line_item_id=line_item.id,
                    adjustment=Decimal(adj["amount"]),
                    adjustment_code=f"{adj['group']}-{adj['code']}",
                    # replace with whatever logic needed for resolving remaining balance
                    transfer_remaining_balance_to="patient"
                    if adj["group"] == "PR"
                    else next_coverage_id,
                )
                transactions.append(transaction)
            return transactions
        def get_claim(
            self, account_number: str, clearinghouse_claim_id: str
        ) -> Claim | None:
            return (
                Claim.objects.filter(account_number=account_number).first()
                or Claim.objects.filter(
                    submissions__clearinghouse_claim_id=clearinghouse_claim_id,
                ).first()
            )
        def post_payment(
            self,
            claim_payment_info: dict,
            check_number: str,
            check_date: str,
            payer_id: str,
        ) -> Effect | None:
            account_number = claim_payment_info.get("pcn")
            clearinghouse_claim_id = claim_payment_info.get("payer_icn")
            if not (claim := self.get_claim(account_number, clearinghouse_claim_id)):
                return None
            insurance_number = claim_payment_info.get("ins_number")
            if not (coverage := claim.get_coverage_by_payer_id(payer_id, insurance_number)):
                return None
            next_coverage_id = (
                claim.coverages.active().exclude(payer_id=payer_id).first().id
            )
            line_item_transactions = []
            for c in claim_payment_info.get("charge", []):
                line_item_transactions.extend(
                    self.create_line_item_transactions(c, claim, next_coverage_id)
                )
            claim_effect = ClaimEffect(claim_id=claim.id)
            return claim_effect.post_payment(
                claim_coverage_id=coverage.id,
                line_item_transactions=line_item_transactions,
                method=PaymentMethod.CHECK,
                check_date=date.fromisoformat(check_date),
                check_number=check_number,
                deposit_date=date.fromisoformat(check_date),
                payment_description="Aetna 835 payment",
                claim_description="Payment applied via 835",
            )
        def post(self) -> list[Response | Effect]:
            payment_info = self.request.json()
            check_number = payment_info.get("check_number")
            check_date = payment_info.get("paid_date")
            payer_id = payment_info.get("payerid")
            payments = [
                p
                for claim in payment_info.get("claim", [])
                if (p := self.post_payment(claim, check_number, check_date, payer_id))
            ]
            return payments + [JSONResponse({"message": "ok"})]
    ```
With the above plugin installed, an example call to the endpoint would look like this:
    ```bash
    curl -X POST "http://localhost:8000/plugin-io/api/pmt/routes/post-claim-payment" \
      -H "Content-Type: application/json" \
      -H "Authorization: <api-key>" \
      -d '{
        "paid_date": "2025-11-06",
        "eraid": "23853671",
        "check_number": "397547083-1662491258",
        "paid_amount": "346.00",
        "payerid": "60054",
        "claim": [
            {
                "pcn": "124974-1",
                "payer_icn": "TST397547083",
                "total_charge": "48",
                "from_dos": "20250827",
                "pat_name_f": "ETHYL",
                "ins_name_l": "BATES",
                "total_paid": "0",
                "thru_dos": null,
                "pat_name_l": "BATES",
                "ins_number": "412098745",
                "ins_name_f": "NORMAN",
                "charge": [
                    {
                        "chgid": "221043771",
                        "from_dos": "20220827",
                        "adjustment": [{"amount": "48", "group": "OA", "code": "109"}],
                        "paid": "0",
                        "allowed": "0",
                        "proc_code": "99212",
                        "charge": "48",
                        "thru_dos": null,
                        "units": "1"
                    }
                ]
            },
            {
                "pcn": "21830-1",
                "payer_icn": "TST397547094",
                "total_charge": "75",
                "from_dos": "20220827",
                "pat_name_f": "MARYLOU",
                "ins_name_l": "DENNIS",
                "total_paid": "45",
                "thru_dos": null,
                "pat_name_l": "DENNIS",
                "ins_number": "223444467",
                "ins_name_f": "ROBERT",
                "charge": [
                    {
                        "chgid": "221043716",
                        "from_dos": "20220827",
                        "adjustment": [
                            {"amount": "15", "group": "CO", "code": "45"},
                            {"amount": "10", "group": "PR", "code": "2"},
                            {"amount": "5", "group": "PR", "code": "3"}
                        ],
                        "paid": "45",
                        "allowed": "60",
                        "proc_code": "99213",
                        "charge": "75",
                        "thru_dos": null,
                        "units": "1"
                    }
                ]
            }
        ]
    }'
    ```
* * *
##  UpdateClaimLineItem 
The `UpdateClaimLineItem` effect allows you to update the `charge` field and `linked_diagnosis_codes` on a specified claim line item.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`claim_line_item_id` | `UUID` or `str` | Identifier for the claim line item | Yes  
`charge` | `float` | The charge amount to update on the claim line item | No  
`linked_diagnosis_codes` | `list[UUID or str]` | List of [ClaimLineItemDiagnosisCode](/sdk/data-claim/#claimlineitemdiagnosiscode) IDs to link to the claim line item | No  
###  Implementation Details 
  - Validates `claim_line_item_id` is provided and that the associated claim line item exists
  - If `linked_diagnosis_codes` is provided, validates that all [ClaimLineItemDiagnosisCode](/sdk/data-claim/#claimlineitemdiagnosiscode) IDs correspond to existing diagnosis codes on the claim line item
  - The `linked_diagnosis_codes` list represents the complete set of diagnosis codes that will be linked to the claim line item when the effect is applied. Any diagnosis codes not included in this list will be unlinked. If you wish to add a new code to the existing linked codes, you must first retrieve the current list and include all codes you want to remain linked: `list(claim_line_item.diagnosis_codes.filter(linked=True).values_list("id", flat=True)) + [new_code_id]`
###  Example Usage 
Updating charge amount.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Note, ClaimLineItem
    from canvas_sdk.effects.claim_line_item import UpdateClaimLineItem
    class Protocol(BaseProtocol):
        """When a note is unlocked, update the associated claim's line items to have a charge of $0.00.
        When a note is locked, update the associated claim's line items to have a charge of $500.00."""
        RESPONDS_TO = EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_CREATED)
        def get_line_items(self) -> ClaimLineItem:
            note = Note.objects.get(id=self.event.context["note_id"])
            claim = note.get_claim()
            return claim.get_active_claim_line_items()
        def update_charge(self, id: str, charge: float) -> Effect:
            return UpdateClaimLineItem(claim_line_item_id=id, charge=charge).apply()
        def update_all_items(self, charge: float) -> list[Effect]:
            return [self.update_charge(line_item.id, charge) for line_item in self.get_line_items()]
        def compute(self) -> list[Effect]:
            if self.event.context["state"] == "ULK":
                return self.update_all_items(0.00)
            if self.event.context["state"] == "LKD":
                return self.update_all_items(500.00)
            return []
    ```
Linking and un-linking diagnosis codes.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Note, ClaimLineItem
    from canvas_sdk.effects.claim_line_item import UpdateClaimLineItem
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_CREATED),
        ]
        def compute(self) -> list[Effect]:
            effects = []
            note = Note.objects.get(id=self.event.context["note_id"])
            if not (claim := note.get_claim()):
                return effects
            state = self.event.context["state"]
            if state == "PSH":
                # only link proc codes starting with "99" to diag codes starting with "I"
                items = claim.line_items.filter(proc_code__startswith="99")
                return self.generate_effects(items, self.get_diags_that_start_with_I)
            if state == "LKD":
                # link all proc codes to all diag codes
                items = claim.line_items.all()
                return self.generate_effects(items, self.get_all_diags)
            if state == "ULK":
                # unlink proc codes starting with "99" from diag codes starting with "I"
                items = claim.line_items.filter(proc_code__startswith="99")
                return self.generate_effects(items, self.get_diags_that_dont_start_with_I)
            if state == "DLT":
                # unlink all proc codes from all diag codes
                items = claim.line_items.all()
                return self.generate_effects(items, self.get_no_diags)
            return effects
        def get_diags_that_start_with_I(self, item: ClaimLineItem) -> list[str]:
            return list(
                item.diagnosis_codes.filter(code__startswith="I").values_list(
                    "id", flat=True
                )
            )
        def get_diags_that_dont_start_with_I(self, item: ClaimLineItem) -> list[str]:
            return list(
                item.diagnosis_codes.exclude(code__startswith="I").values_list(
                    "id", flat=True
                )
            )
        def get_all_diags(self, item: ClaimLineItem) -> list[str]:
            return list(item.diagnosis_codes.values_list("id", flat=True))
        def get_no_diags(self, item: ClaimLineItem) -> list[str]:
            return []
        def generate_effects(self, items, get_diag_ids) -> list[Effect]:
            return [
                UpdateClaimLineItem(
                    claim_line_item_id=item.id, linked_diagnosis_codes=get_diag_ids(item)
                ).apply()
                for item in items
            ]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/effect-claims/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-command-validation/
The Canvas SDK allows you to validate commands and return structured error messages that will be displayed to users in the Canvas UI.
##  Command Validation Effect 
To add validation errors to a command, import the `CommandValidationErrorEffect` class and create an instance of it. This effect is typically used in conjunction with the `PLAN_COMMAND__POST_VALIDATION` event (or similar validation events for other command types).
###  Parameters 
The `CommandValidationErrorEffect` class accepts an optional list of `ValidationError` objects during initialization:
Attribute | Type | Required | Description  
---|---|---|---  
`errors` | list[ValidationError] | optional | List of validation errors to be displayed to the user.  
###  ValidationError 
Each `ValidationError` object represents a single validation error message:
Attribute | Type | Required | Description  
---|---|---|---  
`message` | String | required | The validation error message to display. Must not be empty.  
###  Adding Validation Errors 
There are several ways to add validation errors to the effect:
####  Method 1: Using `add_error()` method 
The `add_error()` method allows you to incrementally build validation errors and supports method chaining:
    ```python
    from canvas_sdk.commands import PlanCommand
    from canvas_sdk.commands.validation import CommandValidationErrorEffect
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__POST_VALIDATION)
        def compute(self) -> list[Effect]:
            narrative = self.context["fields"]["narrative"]
            # Create the validation effect
            effect = CommandValidationErrorEffect()
            # Add validation errors using the add_error method
            if not narrative or len(narrative.strip()) < 10:
                effect.add_error("Narrative must be at least 10 characters long")
            if "TODO" in narrative.upper():
                effect.add_error("Narrative cannot contain TODO items")
            # Return the effect using the apply() method
            return [effect.apply()]
    ```
####  Method 2: Method chaining 
The `add_error()` method returns `self`, allowing for clean method chaining:
    ```python
    from canvas_sdk.commands.validation import CommandValidationErrorEffect
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__POST_VALIDATION)
        def compute(self) -> list[Effect]:
            narrative = self.context["fields"]["narrative"]
            effect = CommandValidationErrorEffect()
            if not narrative:
                effect.add_error("Narrative is required").add_error("Please provide details about the plan")
            return [effect.apply()]
    ```
####  Method 3: Initialize with errors 
You can also initialize the effect with a list of `ValidationError` objects:
    ```python
    from canvas_sdk.commands.validation import CommandValidationErrorEffect, ValidationError
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__POST_VALIDATION)
        def compute(self) -> list[Effect]:
            narrative = self.context["fields"]["narrative"]
            errors = []
            if not narrative:
                errors.append(ValidationError("Narrative is required"))
            if narrative and len(narrative.strip()) < 10:
                errors.append(ValidationError("Narrative must be at least 10 characters long"))
            effect = CommandValidationErrorEffect(errors=errors)
            return [effect.apply()]
    ```
##  Example Use Case 
Here's a complete example that validates a Plan command to ensure it meets specific requirements:
    ```python
    from canvas_sdk.commands import PlanCommand
    from canvas_sdk.commands.validation import CommandValidationErrorEffect
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        """
        Example protocol demonstrating command validation.
        This protocol validates Plan commands to ensure they meet
        organizational requirements before being committed.
        """
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__POST_VALIDATION)
        def compute(self) -> list[Effect]:
            log.info("Running command validation protocol.")
            # Extract command fields from context
            narrative = self.context["fields"]["narrative"]
            # Create the validation effect
            effect = CommandValidationErrorEffect()
            # Perform validation checks
            if not narrative or not narrative.strip():
                effect.add_error("Narrative is required and cannot be empty")
            elif len(narrative.strip()) < 10:
                effect.add_error("Narrative must be at least 10 characters long")
            # Check for prohibited content
            prohibited_terms = ["TODO", "TBD", "FIXME"]
            if any(term in narrative.upper() for term in prohibited_terms):
                effect.add_error("Narrative cannot contain placeholder text (TODO, TBD, FIXME)")
            # Check for required keywords (example: follow-up plans must mention timeline)
            if "follow" in narrative.lower() and not any(word in narrative.lower() for word in ["week", "month", "day"]):
                effect.add_error("Follow-up plans must include a specific timeline")
            # Return the effect
            return [effect.apply()]
    ```
##  Behavior 
  - When validation errors are returned, they will be displayed to the user in the Canvas UI
  - The command will not be committed if validation errors are present
  - Multiple validation errors can be returned at once, and all will be displayed to the user
##  Related Events 
The command validation effect can be used with command validation events. All command types support `__POST_VALIDATION` events following the naming pattern:
`{COMMAND_KEY}_COMMAND__POST_VALIDATION`
For example:
  - `PLAN_COMMAND__POST_VALIDATION`
  - `PRESCRIBE_COMMAND__POST_VALIDATION`
  - `DIAGNOSE_COMMAND__POST_VALIDATION`
For more information about command events and their context objects, see the [Events documentation](/sdk/events/).
----- END PAGE https://docs.canvasmedical.com/sdk/effect-command-validation/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-compound-medication/
The Compound Medication effects enable the creation and management of compound medication formulations within the Canvas system. These effects support the customization of medications prepared by compounding pharmacies according to prescriptions.
##  Create Compound Medication 
The `CreateCompoundMedication` effect creates a new compound medication formulation in the system.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`formulation` | `str` | The compound medication formulation (max 105 characters) | Yes  
`potency_unit_code` | `str` | The unit of measurement for the medication | Yes  
`controlled_substance` | `str` | The controlled substance schedule | Yes  
`controlled_substance_ndc` | `str` or `None` | NDC code for controlled substances (dashes removed) | No*  
`active` | `bool` | Whether the compound medication is active | No  
*Required when `controlled_substance` is not "N" (None)
###  Example Usage 
    ```python
    from canvas_sdk.effects.compound_medications import CompoundMedication as CompoundMedicationEffect
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.events import EventType
    from canvas_sdk.v1.data.compound_medication import CompoundMedication as CompoundMedicationModel
    class CompoundMedicationCreator(BaseHandler):
      RESPONDS_TO = [EventType.Name(EventType.PATIENT_CREATED)]
      def compute(self):
        # Create a non-controlled compound medication
        compound_med = CompoundMedicationEffect(
          formulation="Testosterone 200mg/mL in Grapeseed Oil",
          potency_unit_code=CompoundMedicationModel.PotencyUnit.Milliliter,
          controlled_substance=CompoundMedicationModel.ControlledSubstanceSchedule.SCHEDULE_NOT_SCHEDULED,
          active=True
        )
        # Create a controlled substance compound medication
        controlled_compound = CompoundMedicationEffect(
          formulation="Hydrocodone 5mg/Acetaminophen 325mg Capsule",
          potency_unit_code=CompoundMedicationModel.PotencyUnit.Capsule,
          controlled_substance=CompoundMedicationModel.ControlledSubstanceSchedule.SCHEDULE_II,
          controlled_substance_ndc="12345678901",
          active=True
        )
        return [compound_med.create(), controlled_compound.create()]
    ```
##  Update Compound Medication 
The `UpdateCompoundMedication` effect modifies an existing compound medication formulation.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`compound_medication_id` | `str` | The ID of the compound medication to update | Yes  
`formulation` | `str` or `None` | The compound medication formulation (max 105 characters) | No  
`potency_unit_code` | `str` or `None` | The unit of measurement for the medication | No  
`controlled_substance` | `str` or `None` | The controlled substance schedule | No  
`controlled_substance_ndc` | `str` or `None` | NDC code for controlled substances (dashes removed) | No  
`active` | `bool` or `None` | Whether the compound medication is active | No  
###  Example Usage 
    ```python
    from canvas_sdk.effects.compound_medications import CompoundMedication as CompoundMedicationEffect
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.compound_medication import CompoundMedication as CompoundMedicationModel
    from canvas_sdk.events import EventType
    class CompoundMedicationUpdater(BaseHandler):
      RESPONDS_TO = [EventType.Name(EventType.PLUGIN_CREATED)]
      def compute(self):
        # Find a compound medication to update
        compound_med = CompoundMedicationModel.objects.filter(
            formulation__contains="Testosterone"
        ).first()
        if compound_med:
            # Update to make it a controlled substance
            update_effect = CompoundMedicationEffect(
                compound_medication_id=str(compound_med.id),
                controlled_substance="III",
                controlled_substance_ndc="98765432101"
            )
            return [update_effect.update()]
        return []
    ```
##  Implementation Details 
  - **Formulation Validation** : The formulation field is limited to 105 characters
  - **NDC Formatting** : Any dashes in the NDC code are automatically removed during processing
  - **Cross-field Validation** : When a controlled substance schedule is specified (anything other than "N"), an NDC code must be provided
  - **Default Values** : If not specified, `active` defaults to `True` for new compound medications
  - **Potency Unit Codes** : Must use valid codes as defined in the [PotencyUnit](/sdk/data-compound-medication/#potencyunit) enumeration
  - **Controlled Substance Schedules** : Must use valid values as defined in the [ControlledSubstanceSchedule](/sdk/data-compound-medication/#controlledsubstanceschedule) enumeration
##  Validation 
Both effects perform validation before execution:
###  Create Effect Validation: 
  - Validates all required fields are provided
  - Ensures `potency_unit_code` is a valid value from the PotencyUnit enumeration
  - Ensures `controlled_substance` is a valid schedule from the ControlledSubstanceSchedule enumeration
  - Validates NDC is provided for controlled substances (when schedule is not "N")
  - Checks formulation length does not exceed 105 characters
###  Update Effect Validation: 
  - Verifies the compound medication exists before updating
  - Validates any provided fields follow the same rules as creation
  - Ensures NDC is provided if updating to a controlled substance
  - Only updates fields that are explicitly provided (partial updates supported)
##  Error Handling 
If validation fails, a `ValidationError` is raised with detailed error messages indicating which fields failed validation and why. Error messages are aggregated to provide comprehensive feedback about all validation failures at once.
----- END PAGE https://docs.canvasmedical.com/sdk/effect-compound-medication/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-create-patient-external-identifier/
Creates a new external identifier for a patient.
###  Parameters 
Name | Type | Description  
---|---|---  
patient_id | UUID | The unique identifier of the patient.  
system | String | The system for the external identifier (url).  
value | String | The value of the external identifier.  
###  Example 
    ```python
    from canvas_sdk.effects.patient import CreatePatientExternalIdentifier
    effect = CreatePatientExternalIdentifier(
        patient_id="1eed3ea2a8d546a1b681a2a45de1d790",
        system="https://www.va.gov/",
        value="VET123456"
    )
    effect.create()
    ```
This effect will create a new external identifier for the specified patient.
----- END PAGE https://docs.canvasmedical.com/sdk/effect-create-patient-external-identifier/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-create-patient-preferred-pharmacies/
Creates preferred pharmacies for a patient.
###  Parameters 
Name | Type | Description  
---|---|---  
patient_id | `str` or `UUID` | The unique identifier of the patient.  
pharmacies | `list[PatientPreferredPharmacy]` | List of pharmacies to create.  
###  PatientPreferredPharmacy 
The `PatientPreferredPharmacy` dataclass represents a patient's preferred pharmacy, and if it's their default pharmacy.
###  Validation 
When this effect is interpreted, Canvas validates the `ncpdp_id` before setting the preferred pharmacy. If the `ncpdp_id` is invalid or does not exist, the effect will fail.
To ensure the `ncpdp_id` exists before using this effect, you can verify it using Canvas's [pharmacy HTTP utility](/sdk/utils/#making-requests-to-the-pharmacy-service) to check the pharmacy beforehand.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`ncpdp_id` | `str` | The NCPDC identifier of the pharmacy. | Yes  
`default` | `bool` | Indicates if this is the patient's default pharmacy. | No, defaults to `False`  
###  Example 
    ```python
    from canvas_sdk.effects.patient import CreatePatientPreferredPharmacies, PatientPreferredPharmacy
    from canvas_sdk.v1.data import Patient as PatientModel
    first_patient_id = PatientModel.objects.values_list("id", flat=True).first()
    preferred_pharmacies_effect = CreatePatientPreferredPharmacies(
                                    pharmacies=[PatientPreferredPharmacy(ncpdp_id="0586163", default=True)],
                                    patient_id=first_patient_id
    )
    preferred_pharmacies_effect.create()
    ```
This effect will create a new preferred pharmacy for the specified patient.
Since the `default` attribute is set to `True`, it will mark this pharmacy as the patient's default preferred pharmacy.
----- END PAGE https://docs.canvasmedical.com/sdk/effect-create-patient-preferred-pharmacies/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-event-validation-error/
##  Overview 
The `EventValidationError` effect is used to block the creation of an event (such as a NoteStateChangeEvent create) when custom validation fails. If this effect is returned by a protocol in response to an event (e.g., `NOTE_STATE_CHANGE_EVENT_PRE_CREATE`), the event is aborted and the provided error message is surfaced to the user.
##  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
errors | list[ValidationError] | List of validation errors to display to the user. | Yes  
###  ValidationError dataclass 
Each item in the `errors` list is a `ValidationError` dataclass with the following fields:
Field | Type | Description  
---|---|---  
message | string | The error message to display to the user.  
##  Example Usage 
Return an `EventValidationError` from your protocol's `compute` method to block the event and show a message to the user. You can also return other effects alongside `EventValidatinoError`.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data import Note
    from canvas_sdk.v1.data.coverage import CoverageStack
    from canvas_sdk.effects.validation import EventValidationError, ValidationError
    from canvas_sdk.effects.banner_alert import AddBannerAlert, RemoveBannerAlert
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_PRE_CREATE)
        def handle_no_coverage(self, patient_id: str, note: Note) -> list[Effect]:
            """If the patient has no coverage, add banner alert and do not allow notes to be locked or charges pushed."""
            if note.patient.coverages.filter(stack=CoverageStack.IN_USE).count() == 0:
                return [
                    EventValidationError(
                        errors=[
                            ValidationError(
                                message="Patient has no coverage. Do not send claim to billing department until coverage(s) have been added."
                            )
                        ]
                    ).apply(),
                    AddBannerAlert(
                        patient_id=patient_id,
                        key="no_coverage",
                        narrative="Patient has no documented coverages.",
                        placement=[
                            AddBannerAlert.Placement.CHART,
                            AddBannerAlert.Placement.APPOINTMENT_CARD,
                        ],
                        intent=AddBannerAlert.Intent.ALERT,
                    ).apply(),
                ]
            return [RemoveBannerAlert(patient_id=patient_id, key="no_coverage").apply()]
        def handle_no_billing_line_items(self, note: Note) -> Effect | None:
            """If the note has no billing line items, do not allow notes to be locked or charges pushed."""
            if note.billing_line_items.filter(status="active").count() > 0:
                return None
            val_effect = EventValidationError()
            val_effect.add_error(
                "Cannot lock or push charges for a note with no billing line items."
            )
            return val_effect.apply()
        def compute(self) -> list[Effect]:
            state = self.event.context["state"]
            if state not in ["PSH", "LKD"]:
                return []
            note = Note.objects.get(id=self.event.context["note_id"])
            patient_id = str(note.patient.id)
            effects = self.handle_no_coverage(patient_id=patient_id, note=note)
            if v := self.handle_no_billing_line_items(note=note):
                effects.append(v)
            return effects
    ```
##  Implementation Details 
  - If an `EventValidationError` is returned, the event is aborted and the error message is shown in the UI (if initiated from the UI).
  - This effect is typically used for pre-create validation of events, such as note state changes.
----- END PAGE https://docs.canvasmedical.com/sdk/effect-event-validation-error/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-external-event/
The `ExternalEvent` effect provides a way to create and update external clinical events within the Canvas platform. External events represent clinical encounters from external data sources such as ADT (Admission, Discharge, Transfer) feeds, enabling tracking of patient visits that occur outside of Canvas.
##  Attributes 
Name | Type | Description  
---|---|---  
`external_event_id` | `str` or `UUID` or `None` | Unique identifier of an existing external event. Must be unset when creating; required when updating.  
`patient_id` | `str` or `None` | ID of the patient for this event. Required when creating.  
`visit_identifier` | `str` or `None` | Identifier for the visit/encounter. Required when creating.  
`message_control_id` | `str` or `None` | Unique identifier for the message (e.g., HL7 message control ID). Required when creating.  
`event_type` | `str` or `None` | Type of event (e.g., "ADT^A01" for admission). Required when creating.  
`event_datetime` | `datetime` or `None` | Date and time when the event occurred.  
`event_cancelation_datetime` | `datetime` or `None` | Date and time when the event was cancelled. Set this to mark an event as cancelled.  
`message_datetime` | `datetime` or `None` | Date and time when the message was sent.  
`information_source` | `str` or `None` | Source of the event information (e.g., hospital name, system name).  
`facility_name` | `str` or `None` | Name of the facility where the event occurred.  
`raw_message` | `str` or `None` | Raw message content (e.g., original HL7 message).  
##  Validation & Errors 
Before any effect is emitted, the model runs these checks:
###  Create Validation 
  - **external_event_id** must **not** be set (will be generated by the system)
  - **patient_id** is **required**
  - **visit_identifier** is **required**
  - **message_control_id** is **required**
  - **event_type** is **required**
###  Update Validation 
  - **external_event_id** is **required** and must reference an existing external event
  - All other fields are optional; only dirty (modified) fields are updated
##  Effect Methods 
###  `create()`
Create a new external event record.
  - **Effect Type:** `CREATE_EXTERNAL_EVENT`
  - **Payload:** `{ "data": { patient_id, visit_identifier, message_control_id, event_type, ... } }`
###  `update()`
Update an existing external event.
  - **Effect Type:** `UPDATE_EXTERNAL_EVENT`
  - **Payload:** `{ "data": { external_event_id, <dirty_fields> } }`
  - Only fields marked dirty (modified on the model) are included in the update.
##  Example Usage 
    ```python
    from datetime import datetime
    from canvas_sdk.effects.external_event import ExternalEvent
    from canvas_sdk.v1.data.external_event import ExternalEvent as ExternalEventModel
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.first()
    ```
###  Create an Admission Event 
    ```python
    # Create an external event for a hospital admission
    admission_event = ExternalEvent(
        patient_id=str(patient.id),
        visit_identifier="VISIT-2024-001234",
        message_control_id="MSG-20240115-143052",
        event_type="ADT^A01",  # Admission
        event_datetime=datetime.now(),
        message_datetime=datetime.now(),
        information_source="General Hospital ADT Feed",
        facility_name="General Hospital - Main Campus",
        raw_message="MSH|^~\\&|HOSPITAL|FAC|CANVAS|...",
    )
    effect_create = admission_event.create()
    ```
###  Create a Discharge Event 
    ```python
    # Create an external event for a discharge
    discharge_event = ExternalEvent(
        patient_id=str(patient.id),
        visit_identifier="VISIT-2024-001234",  # Same visit as admission
        message_control_id="MSG-20240118-091530",
        event_type="ADT^A03",  # Discharge
        event_datetime=datetime.now(),
        message_datetime=datetime.now(),
        information_source="General Hospital ADT Feed",
        facility_name="General Hospital - Main Campus",
    )
    effect_discharge = discharge_event.create()
    ```
###  Cancel an Existing Event 
    ```python
    # Find an existing external event to cancel
    existing_event = ExternalEventModel.objects.filter(
        patient__id=patient.id,
        event_cancelation_datetime__isnull=True,  # Not already cancelled
    ).first()
    if existing_event:
        # Cancel the event by setting the cancelation datetime
        cancel_effect = ExternalEvent(
            external_event_id=str(existing_event.id),
            event_cancelation_datetime=datetime.now(),
        )
        effect_cancel = cancel_effect.update()
    ```
###  Update Event Details 
    ```python
    # Update an existing external event with additional information
    existing_event = ExternalEventModel.objects.filter(patient__id=patient.id).first()
    if existing_event:
        updated_event = ExternalEvent(
            external_event_id=str(existing_event.id),
            facility_name="General Hospital - West Wing (Corrected)",
            raw_message="MSH|^~\\&|HOSPITAL|FAC|CANVAS|...|CORRECTED",
        )
        effect_update = updated_event.update()
    ```
###  Create Event with All Fields 
    ```python
    # Create an external event with all optional fields populated
    complete_event = ExternalEvent(
        # Required fields
        patient_id=str(patient.id),
        visit_identifier="VISIT-2024-005678",
        message_control_id="MSG-20240120-163045",
        event_type="ADT^A01",
        # Optional datetime fields
        event_datetime=datetime(2024, 1, 20, 16, 30, 0),
        message_datetime=datetime(2024, 1, 20, 16, 30, 45),
        # Optional string fields
        information_source="Regional Medical Center - HL7 Interface",
        facility_name="Regional Medical Center - Emergency Department",
        raw_message="MSH|^~\\&|RMC|ED|CANVAS|RECV|20240120163045||ADT^A01|MSG123|P|2.5",
    )
    effect_complete = complete_event.create()
    ```
##  Common Event Types 
The `event_type` field typically contains HL7 ADT event codes:
Event Type | Description  
---|---  
ADT^A01 | Admit/Visit Notification  
ADT^A02 | Transfer a Patient  
ADT^A03 | Discharge/End Visit  
ADT^A04 | Register a Patient  
ADT^A08 | Update Patient Information  
ADT^A11 | Cancel Admit/Visit Notification  
ADT^A12 | Cancel Transfer  
ADT^A13 | Cancel Discharge/End Visit  
----- END PAGE https://docs.canvasmedical.com/sdk/effect-external-event/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-messages/
The `Message` effect provides a unified way to create, edit, and transmit messages between users (patients or staff) within the Canvas platform. It supports standalone creation, immediate send after creating, edits, and dedicated send operations.
##  Attributes 
Name | Type | Description  
---|---|---  
`message_id` | `str` or `UUID` or `None` | Unique identifier of an existing message. Must be unset when creating a new message; required when editing.  
`content` | `str` or `None` | The text body of the message. Required when creating; cannot be empty.  
`sender_id` | `str` or `UUID` | ID of the user (Patient or Staff) who is sending the message.  
`recipient_id` | `str` or `UUID` | ID of the user (Patient or Staff) who will receive the message.  
`read` | `datetime` or `None` | Timestamp indicating when the message was read by the recipient. Defaults to `None` (unread).  
##  Validation & Errors 
Before any effect is emitted, the model runs these checks:
  - **Sender and Recipient Exist** Verifies that both `sender_id` and `recipient_id` belong to either a `Patient` or a `Staff` record.
  - **Create vs. Edit Constraints**
    - **Create** and **Create-and-Send** must **not** include `message_id`.
    - **Create** and **Create-and-Send** must include non-empty `content` (content cannot be blank or whitespace-only).
    - **Edit** operations **must** include a valid `message_id` that already exists in the database.
##  Caveats 
  - **Role Constraints:** Sender and Recipient must always be one of Patient or Staff. Patient-to-Patient messaging is not allowed.
  - **UI Refresh Required:** Due to system constraints, editing a message requires a manual UI refresh for updated content to display.
  - **No Attachments Supported:** The Message effect does not yet support attachments.
  - **Immediate Post for Patient-to-Staff:** Messages created from a Patient to Staff cannot be drafted and will immediately appear in the timeline. This means that `CREATE_AND_SEND` and `SEND` effects will fail in these scenarios. You should only use the `CREATE` method for Patient-to-Staff messaging.
##  Effect Methods 
###  `create()`
Originate a new message record without sending.
  - **Effect Type:** `CREATE_MESSAGE`
  - **Payload:** `{ "data": { content, sender_id, recipient_id } }`
###  `create_and_send()`
Create the message and immediately send it in one operation.
  - **Effect Type:** `CREATE_AND_SEND_MESSAGE`
  - **Payload:** `{ "data": { content, sender_id, recipient_id } }`
###  `edit()`
Modify an existing message's content.
  - **Effect Type:** `EDIT_MESSAGE`
  - **Payload:** `{ "data": { message_id, content?, sender_id?, recipient_id? } }`
  - Only fields marked dirty (modified on the model) are included; unchanged fields remain intact in the system.
###  `send()`
Send an already-created message. Useful if you separated creation from transmission.
  - **Effect Type:** `SEND_MESSAGE`
  - **Payload:** `{ "data": { message_id } }`
##  Example Usage 
    ```python
    from canvas_sdk.v1.data.message import Message as MessageModel
    from canvas_sdk.v1.data.patient import Patient
    from canvas_sdk.v1.data.staff import Staff
    from canvas_sdk.effects.note.message import Message
    staff = Staff.objects.first()
    patient = Patient.objects.first()
    ```
###  Create (originate) only 
    ```python
    m1 = Message(
        content="Your lab results are available.",
        sender_id=staff.id,
        recipient_id=patient.id
    )
    effect_create = m1.create()
    ```
###  Create and send in one step 
    ```python
    m2 = Message(
        content="Your appointment is confirmed.",
        sender_id=staff.id,
        recipient_id=patient.id
    )
    effect_create_and_send = m2.create_and_send()
    m = MessageModel.objects.get(message_id="msg-1234")
    ```
###  Edit an existing message 
    ```python
    m3 = Message(
        message_id=m.id,
        content="Updated: Your appointment has moved to 3pm."
    )
    effect_edit = m3.edit()
    ```
###  Send an existing message 
    ```python
    m4 = Message(message_id=m.id)
    effect_send = m4.send()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/effect-messages/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-notes/
The Canvas SDK provides effects to facilitate creating, updating, and managing **visit notes** , **appointments** , and **schedule events**. Below you'll find detailed documentation for each effect type and their operations.
##  Note Effect 
The `Note` effect facilitates the creation and updating of visit notes for patients.
###  Create Note 
Creates a new note. Can be passed an optional UUID as `instance_id` from the `uuid.uuid4` library, or will be assigned one if not present. Passing a user-set UUID as the `instance_id` allows for [assigning commands to the note](/sdk/commands/#chaining-methods-with-a-user-set-uuid) in the same plugin action.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier for the note | No  
`note_type_id` | `UUID` or `str` | Identifier for the note type | Yes  
`datetime_of_service` | `datetime.datetime` | When the service was provided | Yes  
`patient_id` | `str` | Identifier for the patient | Yes  
`practice_location_id` | `UUID` or `str` | Identifier for the practice location | Yes  
`provider_id` | `str` | Identifier for the provider | Yes  
`title` | `str` or `None` | Optional title for the note | No  
####  Implementation Details 
  - Validates that the note type exists and has an appropriate category
  - Ensures the patient exists in the system
  - Verifies that the practice location and provider are valid
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(
                note_type_id="note-type-uuid",
                datetime_of_service=datetime.datetime.now(),
                patient_id="patient-uuid",
                practice_location_id="practice-location-uuid",
                provider_id="provider-uuid"
            )
            return [note_effect.create()]
    ```
###  Update Note 
Updates an existing note. Only certain fields can be modified after creation.
####  Attributes 
Attribute | Type | Description | Required | Updatable  
---|---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note to update | Yes | No  
`title` | `str` or `None` | Updated title for the note | No | Yes  
`datetime_of_service` | `datetime.datetime` | Updated service date/time | No | Yes  
`practice_location_id` | `UUID` or `str` | Updated practice location | No | Yes  
`provider_id` | `str` | Updated provider | No | Yes  
**Note** : `patient_id` and `note_type_id` cannot be updated after creation.
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            note_effect.title = "Updated Consultation Notes"
            note_effect.datetime_of_service = datetime.datetime.now()
            return [note_effect.update()]
    ```
###  Fax Note 
Sends an existing note via fax to a specified recipient. This effect allows you to transmit patient notes to external healthcare providers or facilities.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`note_id` | `UUID` or `str` | Identifier of the note to fax | Yes  
`recipient_name` | `str` | Name of the fax recipient | Yes  
`recipient_fax_number` | `str` | Fax number of the recipient. Should include the country code | Yes  
`include_coversheet` | `bool` | Whether to include a coversheet with the fax | No  
`subject` | `str` or `None` | Subject line for the coversheet (required if coversheet used) | No  
`comment` | `str` or `None` | Additional comments for coversheet (required if coversheet used) | No  
`location_id` | `UUID` or `str` or `None` | Practice location ID (required if coversheet used) | No  
####  Implementation Details 
  - Validates that the note exists in the system
  - If `include_coversheet` is `True`, the following fields become required: 
    - `subject`: The subject line for the coversheet
    - `comment`: Additional comments to include on the coversheet
    - `location_id`: The practice location identifier (must exist in the system)
  - Validates that the practice location exists if provided
####  Example Usage 
    ```python
    from canvas_sdk.effects.fax.note import FaxNoteEffect
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            # Basic fax without coversheet
            fax_effect = FaxNoteEffect(
                note_id="existing-note-uuid",
                recipient_name="Dr. Jane Smith",
                recipient_fax_number="15551234567"
            )
            return [fax_effect.apply()]
    ```
####  Example with Coversheet 
    ```python
    from canvas_sdk.effects.fax.note import FaxNoteEffect
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            # Fax with coversheet
            fax_effect = FaxNoteEffect(
                note_id="existing-note-uuid",
                recipient_name="Dr. Jane Smith",
                recipient_fax_number="15551234567",
                include_coversheet=True,
                subject="Patient Referral - Follow-up Care",
                comment="Please review attached consultation notes for continuing care.",
                location_id="practice-location-uuid"
            )
            return [fax_effect.apply()]
    ```
###  Push Charges 
Pushes the charges from the Note to its associated Claim in the Revenue module. Has the exact same effect as clicking on the `Push charges` button in the Note footer.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note to update | Yes  
**Note** : `instance_id` must be a valid, existing Note, and its NoteTypeVersion must have `is_billable` = True.
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.push_charges()]
    ```
> **Info:** This effect will be originated by the current actor that triggered the event, with a fallback to Canvas Bot if no actor is found. 
###  Lock 
Locks an existing note, preventing further modifications. Has the exact same effect as clicking on the `Lock` button in the Note footer.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note to lock | Yes  
**Note** : `instance_id` must be a valid, existing Note that is not already locked.
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.lock()]
    ```
> **Info:** This effect will be originated by the current actor that triggered the event, with a fallback to Canvas Bot if no actor is found. 
###  Sign 
Signs an existing note, marking it as reviewed and approved by the provider. Has the exact same effect as clicking on the `Sign` button in the Note footer.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note to sign | Yes  
**Note** : `instance_id` must be a valid, existing Note that is not already signed.
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.sign()]
    ```
> **Info:** This effect will be originated by the current actor that triggered the event, with a fallback to Canvas Bot if no actor is found. 
###  Unlock 
Unlocks a previously locked/signed note, allowing modifications again. Has the exact same effect as clicking on the `Unlock/Amend` button in the Note footer.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note to unlock | Yes  
**Note** : `instance_id` must be a valid, existing Note that is currently locked.
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.unlock()]
    ```
> **Info:** This effect will be originated by the current actor that triggered the event, with a fallback to Canvas Bot if no actor is found. 
###  Check In 
Marks a patient as checked in for their appointment. Has the exact same effect as clicking on the `Check In` button in the Appointment note.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note for check-in | Yes  
**Note** : `instance_id` must be a valid, existing Note associated with an appointment.
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.check_in()]
    ```
> **Info:** This effect will be originated by the current actor that triggered the event, with a fallback to Canvas Bot if no actor is found. 
###  No Show 
Marks an appointment as a no-show when the patient does not arrive. Has the exact same effect as marking an appointment as `No Show` in the Appointment note.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the note to mark no-show | Yes  
**Note** : `instance_id` must be a valid, existing Note associated with an appointment.
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.note import Note
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            note_effect = Note(instance_id="existing-note-uuid")
            return [note_effect.no_show()]
    ```
> **Info:** This effect will be originated by the current actor that triggered the event, with a fallback to Canvas Bot if no actor is found. 
##  ScheduleEvent Effect 
The `ScheduleEvent` effect enables creating, updating, and deleting schedule events for providers, with optional patient association.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`note_type_id` | `UUID` or `str` | Identifier for the note type (must be of category `SCHEDULE_EVENT`) | Yes  
`patient_id` | `str` or `None` | Identifier for the patient (if applicable) | Conditional  
`description` | `str` or `None` | Custom description for the event | Conditional  
`start_time` | `datetime.datetime` | Start time of the event | Yes  
`duration_minutes` | `int` | Duration of the event in minutes | Yes  
`practice_location_id` | `UUID` or `str` | Identifier for the practice location | Yes  
`provider_id` | `str` | Identifier for the provider | Yes  
`status` | `AppointmentProgressStatus` or `None` | Status of the event | No  
`external_identifiers` | `list[AppointmentIdentifier]` or `None` | External system identifiers | No  
###  Implementation Details 
  - Validates that the note type exists and is of category `SCHEDULE_EVENT`
  - Ensures patient is provided if the note type requires it
  - Verifies that custom descriptions are only used for note types that allow them
  - Validates that the practice location and provider exist
###  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(
                note_type_id="schedule-event-note-type-uuid",
                patient_id="patient-uuid",  # Optional depending on note type
                description="Team meeting",  # Optional depending on note type
                start_time=datetime.datetime.now(),
                duration_minutes=30,
                practice_location_id="practice-location-uuid",
                provider_id="provider-uuid"
            )
            return [schedule_event_effect.create()]
    ```
###  Update Schedule Event 
Updates an existing schedule event in place.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the event to update | Yes  
`start_time` | `datetime.datetime` | New start time | No  
`duration_minutes` | `int` | New duration in minutes | No  
`description` | `str` or `None` | Updated description | No  
`practice_location_id` | `UUID` or `str` | New practice location | No  
`provider_id` | `str` | New provider | No  
`status` | `AppointmentProgressStatus` or `None` | Updated status | No  
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note import AppointmentIdentifier
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.effects.note.base import AppointmentIdentifier
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(instance_id="existing-event-uuid")
            schedule_event_effect.start_time = datetime.datetime.now() + datetime.timedelta(days=1)
            schedule_event_effect.duration_minutes = 60
            schedule_event_effect.description = "Rescheduled team meeting"
            schedule_event_effect.external_identifiers = [
                AppointmentIdentifier(system="test_system", value="123TEST")
            ]
            return [schedule_event_effect.update()]
    ```
###  Reschedule Schedule Event 
Reschedules an existing schedule event by creating a new event and cancelling the original. This maintains the event history and ensures proper tracking of rescheduled events.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of the event to reschedule | Yes  
`start_time` | `datetime.datetime` | New start time | No  
`duration_minutes` | `int` | New duration in minutes | No  
`description` | `str` or `None` | Updated description | No  
`practice_location_id` | `UUID` or `str` | New practice location | No  
`provider_id` | `str` | New provider | No  
`status` | `AppointmentProgressStatus` or `None` | Updated status | No  
`external_identifiers` | `list[AppointmentIdentifier]` or `None` | Updated external identifiers | No  
**Note** : At least one field (besides `instance_id`) must be modified.
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(instance_id="existing-event-uuid")
            schedule_event_effect.start_time = datetime.datetime.now() + datetime.timedelta(hours=3)
            schedule_event_effect.duration_minutes = 45
            return [schedule_event_effect.reschedule()]
    ```
###  Delete Schedule Event 
Marks a schedule event as cancelled.
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.appointment import ScheduleEvent
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            schedule_event_effect = ScheduleEvent(instance_id="existing-event-uuid")
            return [schedule_event_effect.delete()]
    ```
* * *
##  Appointment Effect 
The `Appointment` effect facilitates creating, updating, and cancelling patient appointments with providers.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`appointment_note_type_id` | `UUID` or `str` | Identifier for the appointment note type (must be of category `ENCOUNTER` and scheduleable) | Yes  
`patient_id` | `str` | Identifier for the patient | Yes  
`meeting_link` | `str` or `None` | Link for virtual appointments | No  
`start_time` | `datetime.datetime` | Start time of the appointment | Yes  
`duration_minutes` | `int` | Duration of the appointment in minutes | Yes  
`practice_location_id` | `UUID` or `str` | Identifier for the practice location | Yes  
`provider_id` | `str` | Identifier for the provider | Yes  
`status` | `AppointmentProgressStatus` or `None` | Status of the appointment | No  
`external_identifiers` | `list[AppointmentIdentifier]` or `None` | External system identifiers | No  
###  Implementation Details 
  - Validates that the appointment note type exists, is of category `ENCOUNTER`, and is scheduleable
  - Ensures the patient exists in the system
  - Verifies that the practice location and provider exist
###  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(
                appointment_note_type_id="appointment-note-type-uuid",
                patient_id="patient-uuid",
                meeting_link="https://zoom.us/example-link",  # Optional
                start_time=datetime.datetime.now(),
                duration_minutes=60,
                practice_location_id="practice-location-uuid",
                provider_id="provider-uuid"
            )
            return appointment_effect.create()
    ```
###  Update Appointment 
Updates an existing appointment in place.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of appointment to update | Yes  
`start_time` | `datetime.datetime` | New start time | No  
`duration_minutes` | `int` | New duration in minutes | No  
`meeting_link` | `str` or `None` | Updated meeting link | No  
`practice_location_id` | `UUID` or `str` | New practice location | No  
`provider_id` | `str` | New provider | No  
`status` | `AppointmentProgressStatus` or `None` | Updated status | No  
`external_identifiers` | `list[AppointmentIdentifier]` or `None` | Updated external identifiers | No  
**Note** : `patient_id` cannot be updated after creation.
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(instance_id="existing-appointment-uuid")
            appointment_effect.start_time = datetime.datetime.now() + datetime.timedelta(hours=2)
            appointment_effect.duration_minutes = 45
            appointment_effect.meeting_link = "https://new-meeting-link.com"
            return appointment_effect.update()
    ```
###  Reschedule Appointment 
Reschedules an existing appointment by creating a new appointment and cancelling the original. This maintains the appointment history and ensures proper tracking of rescheduled appointments.
####  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`instance_id` | `UUID` or `str` | Identifier of appointment to reschedule | Yes  
`start_time` | `datetime.datetime` | New start time | No  
`duration_minutes` | `int` | New duration in minutes | No  
`meeting_link` | `str` or `None` | Updated meeting link | No  
`practice_location_id` | `UUID` or `str` | New practice location | No  
`provider_id` | `str` | New provider | No  
`status` | `AppointmentProgressStatus` or `None` | Updated status | No  
`external_identifiers` | `list[AppointmentIdentifier]` or `None` | Updated external identifiers | No  
**Note** : At least one field (besides `instance_id`) must be modified. `patient_id` cannot be updated after creation.
####  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(instance_id="existing-appointment-uuid")
            appointment_effect.start_time = datetime.datetime.now() + datetime.timedelta(days=1)
            appointment_effect.duration_minutes = 60
            return appointment_effect.reschedule()
    ```
###  Cancel Appointment 
Cancels an existing appointment and updates its status.
####  Example Usage 
    ```python
    from canvas_sdk.effects.note.appointment import Appointment
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            appointment_effect = Appointment(instance_id="existing-appointment-uuid")
            return appointment_effect.cancel()
    ```
##  Managing Appointment Labels 
Canvas supports adding up to 3 labels per appointment for categorization and workflow automation. Labels can be managed programmatically using the appointment label effects.
For detailed documentation on appointment label management, see [Appointment Label Effects](/sdk/effect-appointment-labels/).
###  Quick Example 
    ```python
    from canvas_sdk.effects.note.appointment import AddAppointmentLabel, RemoveAppointmentLabel
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class MyHandler(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.APPOINTMENT_LABEL_ADDED), EventType.Name(EventType.APPOINTMENT_LABEL_REMOVED)]
        def compute(self):
            # Add labels to an appointment
            add_effect = AddAppointmentLabel(
                appointment_id="appointment-uuid",
                labels={"URGENT", "FOLLOW_UP"}
            )
            # Remove labels from an appointment
            remove_effect = RemoveAppointmentLabel(
                appointment_id="appointment-uuid",
                labels={"CANCELLED"}
            )
            return [add_effect.apply(), remove_effect.apply()]
    ```
* * *
##  Validation 
All effects perform comprehensive validation before execution:
  1. **Entity Existence** : Validates that referenced entities (patients, providers, practice locations, note types) exist in the system
  2. **Type Compatibility** : Ensures note types are appropriate for the intended operation: 
     - Visit notes cannot use `APPOINTMENT`, `SCHEDULE_EVENT`, `MESSAGE`, or `LETTER` note types
     - Schedule events must use `SCHEDULE_EVENT` note types
     - Appointments must use `ENCOUNTER` note types that are scheduleable
  3. **Field Requirement Enforcement** : The system validates conditional field requirements based on note type configurations: 
     - **Patient Association Requirements** : For note types with `is_patient_required=True`, the system enforces that a valid patient ID is provided. This is particularly important for schedule events that may or may not be associated with specific patients.
     - **Custom Description Validation** : When a note type has `allow_custom_title=False`, the system prevents custom descriptions from being added. This ensures adherence to standardized naming conventions for certain types of appointments and events.
     - **Required Field Validation** : All required fields are checked for proper values and formats before the effect is executed.
  4. **Update Restrictions** : Certain fields cannot be modified after creation: 
     - **Notes** : `patient_id` and `note_type_id` are immutable
     - **Appointments** : `patient_id` is immutable
     - **All Effects** : At least one field must be modified for an update operation to succeed
----- END PAGE https://docs.canvasmedical.com/sdk/effect-notes/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-observation/
The `Observation` effect provides a unified way to create and update clinical observations within the Canvas platform. Observations can include vitals (blood pressure, temperature, etc.), lab results, and other clinical measurements. The effect supports structured coding using standard terminologies (LOINC, SNOMED), components for multi-part measurements, and value codings for interpretation.
##  Attributes 
Name | Type | Description  
---|---|---  
`observation_id` | `str` or `UUID` or `None` | Unique identifier of an existing observation. Must be unset when creating; required when updating.  
`patient_id` | `str` or `None` | ID of the patient for this observation. Required when creating.  
`is_member_of_id` | `str` or `UUID` or `None` | Reference to a parent observation (for grouping related observations).  
`category` | `str` or `list[str]` or `None` | Category of observation (e.g., "vital-signs", "laboratory", "imaging"). Can be a single category or a list of categories.  
`units` | `str` or `None` | Unit of measure for the observation value (e.g., "mmHg", "mg/dL").  
`value` | `str` or `None` | The observation value as a string.  
`note_id` | `int` or `None` | ID of the note associated with this observation.  
`name` | `str` or `None` | Human-readable name for the observation. Required when creating.  
`effective_datetime` | `datetime` or `None` | Date and time when the observation was taken. Required when creating.  
`codings` | `list[CodingData]` or `None` | List of standardized codes identifying this observation (e.g., LOINC codes).  
`components` | `list[ObservationComponentData]` or `None` | List of components for multi-part observations (e.g., systolic and diastolic BP).  
`value_codings` | `list[CodingData]` or `None` | List of coded values for interpretation (e.g., "normal", "abnormal").  
##  Helper Classes 
###  `CodingData`
Represents a standardized code from a terminology system (LOINC, SNOMED, etc.).
Name | Type | Description  
---|---|---  
`code` | `str` | The code value from the terminology system.  
`display` | `str` | Human-readable display text for the code.  
`system` | `str` | URI identifying the terminology system (e.g., "http://loinc.org").  
`version` | `str` | Version of the terminology system. Defaults to empty string.  
`user_selected` | `bool` | Whether this code was explicitly selected by the user. Defaults to False.  
###  `ObservationComponentData`
Represents a component of a multi-part observation (e.g., systolic and diastolic blood pressure).
Name | Type | Description  
---|---|---  
`value_quantity` | `str` | The numeric value of this component.  
`value_quantity_unit` | `str` | Unit of measure for this component value.  
`name` | `str` | Name of this component.  
`codings` | `list[CodingData]` or `None` | Standardized codes identifying this component.  
##  Validation & Errors 
Before any effect is emitted, the model runs these checks:
###  Create Validation 
  - **observation_id** must **not** be set (will be generated by the system)
  - **patient_id** is **required**
  - **name** is **required**
  - **effective_datetime** is **required**
  - If **is_member_of_id** is provided, the parent observation must exist
###  Update Validation 
  - **observation_id** is **required** and must reference an existing observation
  - All other fields are optional; only dirty (modified) fields are updated
  - If **is_member_of_id** is provided, the parent observation must exist
##  Effect Methods 
###  `create()`
Create a new observation record.
  - **Effect Type:** `CREATE_OBSERVATION`
  - **Payload:** `{ "data": { patient_id, name, effective_datetime, ... } }`
###  `update()`
Update an existing observation.
  - **Effect Type:** `UPDATE_OBSERVATION`
  - **Payload:** `{ "data": { observation_id, <dirty_fields> } }`
  - Only fields marked dirty (modified on the model) are included in the update.
##  Example Usage 
    ```python
    import datetime
    from canvas_sdk.effects.observation import Observation, CodingData, ObservationComponentData
    from canvas_sdk.v1.data.observation import Observation as ObservationModel
    from canvas_sdk.v1.data.patient import Patient
    patient = Patient.objects.first()
    ```
###  Create a Blood Pressure Observation 
    ```python
    # Create a blood pressure observation with components and codings
    bp_observation = Observation(
        patient_id=patient.id,
        name="Blood Pressure",
        category="vital-signs",
        value="120/80",
        units="mmHg",
        effective_datetime=datetime.datetime.now(),
        codings=[
            CodingData(
                code="85354-9",
                display="Blood pressure panel with all children optional",
                system="http://loinc.org",
                version="2.73",
                user_selected=True,
            )
        ],
        components=[
            ObservationComponentData(
                value_quantity="120",
                value_quantity_unit="mmHg",
                name="Systolic Blood Pressure",
                codings=[
                    CodingData(
                        code="8480-6",
                        display="Systolic blood pressure",
                        system="http://loinc.org",
                    )
                ],
            ),
            ObservationComponentData(
                value_quantity="80",
                value_quantity_unit="mmHg",
                name="Diastolic Blood Pressure",
                codings=[
                    CodingData(
                        code="8462-4",
                        display="Diastolic blood pressure",
                        system="http://loinc.org",
                    )
                ],
            ),
        ],
        value_codings=[
            CodingData(
                code="normal",
                display="Normal",
                system="http://terminology.hl7.org/CodeSystem/v3-ObservationInterpretation",
            )
        ],
    )
    effect_create = bp_observation.create()
    ```
###  Update an Existing Observation 
    ```python
    # Find an existing observation
    existing_obs = ObservationModel.objects.filter(patient_id=patient.id).first()
    # Update the blood pressure values
    updated_bp = Observation(
        observation_id=existing_obs.id,
        value="130/85",
        units="mmHg",
        components=[
            ObservationComponentData(
                value_quantity="130",
                value_quantity_unit="mmHg",
                name="Systolic Blood Pressure",
                codings=[
                    CodingData(
                        code="8480-6",
                        display="Systolic blood pressure",
                        system="http://loinc.org",
                    )
                ],
            ),
            ObservationComponentData(
                value_quantity="85",
                value_quantity_unit="mmHg",
                name="Diastolic Blood Pressure",
                codings=[
                    CodingData(
                        code="8462-4",
                        display="Diastolic blood pressure",
                        system="http://loinc.org",
                    )
                ],
            ),
        ],
    )
    effect_update = updated_bp.update()
    ```
###  Create a Simple Lab Result 
    ```python
    # Create a simple lab observation
    glucose = Observation(
        patient_id=patient.id,
        name="Glucose",
        category="laboratory",
        value="95",
        units="mg/dL",
        effective_datetime=datetime.datetime.now(),
        codings=[
            CodingData(
                code="2339-0",
                display="Glucose [Mass/volume] in Blood",
                system="http://loinc.org",
            )
        ],
    )
    effect_create_lab = glucose.create()
    ```
###  Create an Observation with Multiple Categories 
    ```python
    # Create an observation that belongs to multiple categories
    comprehensive_assessment = Observation(
        patient_id=patient.id,
        name="Comprehensive Physical Assessment",
        category=["vital-signs", "exam"],  # Multiple categories
        value="Normal",
        effective_datetime=datetime.datetime.now(),
        codings=[
            CodingData(
                code="29545-1",
                display="Physical examination",
                system="http://loinc.org",
            )
        ],
    )
    effect_create_multi = comprehensive_assessment.create()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/effect-observation/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-patient-facility-address/
The `PatientFacilityAddress` effect enables the creation, updating, and deletion of patient facility address records within Canvas. Patient facility addresses link patients to healthcare facilities, with optional room number information. The address details are automatically populated from the linked facility.
You can either reference an existing facility by ID, or create a new facility inline by providing the facility details.
##  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`id` | `str` or `UUID` | ID of the patient facility address (for update/delete) | Yes (update/delete)  
`patient_id` | `str` or `UUID` | ID of the patient | Yes (create)  
`facility_id` | `str` or `UUID` | ID of an existing facility to link | Yes (if not creating new)  
`facility_name` | `str` | Name of new facility to create | Yes (if creating new facility)  
`facility_npi_number` | `str` | NPI number for new facility | No  
`facility_phone_number` | `str` | Phone number for new facility | No  
`facility_fax_number` | `str` | Fax number for new facility | No  
`facility_active` | `bool` | Whether the new facility is active | No  
`facility_line1` | `str` | Street address line 1 for new facility | No  
`facility_line2` | `str` | Street address line 2 for new facility | No  
`facility_city` | `str` | City for new facility | Yes (if creating new facility)  
`facility_district` | `str` | District for new facility | No  
`facility_state_code` | `str` | State code for new facility (e.g., "CA", "NY") | Yes (if creating new facility)  
`facility_postal_code` | `str` | Postal code for new facility | Yes (if creating new facility)  
`room_number` | `str` | Room number at the facility | No  
`address_type` | `AddressType` or `str` | Type of address: "physical" or "both" | No (defaults to "physical")  
##  Facility Reference Options 
When creating a patient facility address, you must either:
  1. **Reference an existing facility** by providing `facility_id`
  2. **Create a new facility inline** by providing facility creation fields (`facility_name`, `facility_city`, `facility_state_code`, `facility_postal_code`)
> **Warning:** You cannot specify both `facility_id` and facility creation fields. Use one approach or the other. 
###  Required Fields for Inline Facility Creation 
When creating a new facility inline, the following fields are required:
  - `facility_name`
  - `facility_city`
  - `facility_state_code`
  - `facility_postal_code`
##  Address Type 
The `address_type` field accepts the following values:
Value | Description  
---|---  
`physical` | Physical/street address (default)  
`both` | Both physical and mailing address  
##  Effect Methods 
###  `.create()`
Creates a new patient facility address. Requires `patient_id` and either `facility_id` or facility creation fields.
**Effect Type:** `CREATE_PATIENT_FACILITY_ADDRESS`
###  `.update()`
Updates an existing patient facility address. Requires `id` of the address to update.
**Effect Type:** `UPDATE_PATIENT_FACILITY_ADDRESS`
###  `.delete()`
Deletes an existing patient facility address. Requires `id` of the address to delete.
**Effect Type:** `DELETE_PATIENT_FACILITY_ADDRESS`
##  Validation 
The effect validates:
  - **Create** : `patient_id` is required and must reference an existing patient
  - **Create** : Either `facility_id` or facility creation fields must be provided (not both)
  - **Create** : If `facility_id` is provided, it must reference an existing facility
  - **Create** : If creating a new facility, all required facility fields must be provided
  - **Update/Delete** : `id` is required and must reference an existing patient facility address
  - **Update** : If updating facility, same rules apply as create (facility_id OR creation fields)
  - `address_type` must be "physical" or "both" if provided
##  Example Usage 
###  Creating with Existing Facility 
    ```python
    from canvas_sdk.effects.patient_facility_address import PatientFacilityAddress, AddressType
    from canvas_sdk.handlers.base import BaseHandler
    class MyProtocol(BaseHandler):
        def compute(self):
            effect = PatientFacilityAddress(
                patient_id="patient-uuid-here",
                facility_id="facility-uuid-here",
                room_number="101A",
                address_type=AddressType.PHYSICAL,
            )
            return [effect.create()]
    ```
###  Creating with New Facility 
    ```python
    from canvas_sdk.effects.patient_facility_address import PatientFacilityAddress, AddressType
    from canvas_sdk.handlers.base import BaseHandler
    class MyProtocol(BaseHandler):
        def compute(self):
            effect = PatientFacilityAddress(
                patient_id="patient-uuid-here",
                facility_name="Downtown Medical Center",
                facility_line1="123 Main Street",
                facility_line2="Suite 400",
                facility_city="Boston",
                facility_state_code="MA",
                facility_postal_code="02101",
                facility_phone_number="617-555-1234",
                facility_npi_number="1234567890",
                room_number="Room 205",
                address_type=AddressType.PHYSICAL,
            )
            return [effect.create()]
    ```
###  Updating an Existing Address 
    ```python
    from canvas_sdk.effects.patient_facility_address import PatientFacilityAddress
    from canvas_sdk.handlers.base import BaseHandler
    class MyProtocol(BaseHandler):
        def compute(self):
            # Update to use a different existing facility
            effect = PatientFacilityAddress(
                id="existing-address-uuid",
                facility_id="new-facility-uuid",
                room_number="202B",
            )
            return [effect.update()]
    ```
###  Deleting an Address 
    ```python
    from canvas_sdk.effects.patient_facility_address import PatientFacilityAddress
    from canvas_sdk.handlers.base import BaseHandler
    class MyProtocol(BaseHandler):
        def compute(self):
            effect = PatientFacilityAddress(
                id="existing-address-uuid",
            )
            return [effect.delete()]
    ```
##  Notes 
  - The address details (line1, line2, city, state, country, postal_code) displayed for a patient facility address are automatically populated from the linked facility's address information.
  - When creating a new facility inline, the facility is created first, then linked to the patient facility address.
  - Room number is optional and can be used to specify the patient's specific room within the facility.
----- END PAGE https://docs.canvasmedical.com/sdk/effect-patient-facility-address/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-patient-metadata/
The `PatientMetadata` effect provides a flexible key-value storage system for patient-specific data within the Canvas system. This effect enables the creation and updating of custom metadata entries associated with patient records, allowing for extensible patient information storage beyond standard demographic fields.
##  Overview 
Patient metadata serves as a powerful extension mechanism for storing custom patient-related information that doesn't fit within the standard patient data model. It uses the `.upsert(value)` method to apply a value to the key attributed with the Metadata effect object.
##  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`patient_id` | `str` | Id of the [Patient(/sdk/data-patient/)] record to associate metadata with | Yes  
`key` | `str` | Unique identifier for the metadata entry within the patient context | Yes  
##  Methods 
###  upsert(value: str) → Effect 
Creates or updates a metadata entry for the specified patient and key combination.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`value` | `str` | The metadata value to store | Yes  
####  Returns 
An `Effect` object configured for upserting patient metadata.
####  Behavior 
  - If a metadata entry with the specified key already exists for the patient, it will be updated with the new value
  - If no entry exists, a new metadata entry will be created
  - The operation is idempotent - repeated calls with the same key and value will not create duplicate entries
##  Implementation Details 
###  Validation 
The effect performs comprehensive validation before execution:
  1. **Patient Existence Validation** : Verifies that the referenced patient exists in the system
  - Queries the patient database to confirm the `patient_id` corresponds to an existing patient record
  - Returns a descriptive error if the patient is not found
  1. **Field Validation** : Ensures all required fields are provided and properly formatted
  - Both `patient_id` and `key` must be non-empty strings
  - The `value` parameter in the `upsert` method must be provided
###  Data Structure 
The effect payload is structured as JSON with the following schema:
    ```json
    {
      "data": {
        "patient_id": "patient-id",
        "key": "metadata-key",
        "value": "metadata-value"
      }
    }
    ```
##  Example Usage 
###  Basic Usage 
    ```python
    from canvas_sdk.effects.patient_metadata import PatientMetadata
    # Create a metadata entry for patient preferences
    metadata = PatientMetadata(
        patient_id="550e8400e29b41d4a716446655440000",
        key="preferred_contact_time"
    )
    # Upsert the metadata value
    effect = metadata.upsert("morning")
    ```
###  Metadata Parsing Example 
    ```python
    import json
    import re
    from canvas_sdk.effects.patient_metadata import PatientMetadata
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.events import EventType
    class NarrativeMetadataExtractor(BaseHandler):
      """
      Extracts structured metadata from clinical narratives.
      """
      RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__POST_UPDATE)
      def compute(self):
        patient_id = self.context["patient"]["id"]
        narrative = self.context.get("fields", {}).get("narrative", "")
        # Extract key-value pairs from narrative text
        # Pattern: key=somekey*value=somevalue
        key_match = re.search(r'key=([^*#_\s]+)', narrative)
        value_match = re.search(r'value=([^*#_\s]+)', narrative)
        if not (key_match and value_match):
          return []
        key = key_match.group(1)
        value = value_match.group(1)
        # Create metadata effect
        metadata = PatientMetadata(
          patient_id=patient_id,
          key=key
        )
        return [metadata.upsert(value)]
    ```
##  Best Practices 
###  Key Naming Conventions 
  1. **Use Descriptive Names** : Choose keys that clearly indicate the purpose of the metadata
  - Good: `external_mrn`, `preferred_pharmacy_id`, `risk_score_diabetes`
  - Avoid: `data1`, `temp`, `misc`
  1. **Namespace Your Keys** : When building integrations or modules, prefix keys to avoid collisions
  - Example: `integration_patient_id`, `module_diabetes_last_a1c_date`
###  Value Storage 
  1. **String Serialization** : All values are stored as strings. For complex data types: 
         ```python
         # Storing JSON data
         import json
         from canvas_sdk.effects.patient_metadata import PatientMetadata
         metadata = PatientMetadata(
             patient_id="550e8400e29b41d4a716446655440000",
             key="result"
         )
         complex_data = {"scores": [85, 92, 78], "average": 85.0}
         metadata.upsert(json.dumps(complex_data))
         ```
  2. **Boolean Values** : Store as "true" or "false" strings for consistency 
         ```python
         from canvas_sdk.effects.patient_metadata import PatientMetadata
         patient_consented = False
         metadata = PatientMetadata(
             patient_id="550e8400e29b41d4a716446655440000",
             key="boolean_value"
         )
         metadata.upsert("true" if patient_consented else "false")
         ```
##  Notes 
  - Metadata entries are patient-specific and isolated - the same key can have different values for different patients
  - There is no built-in versioning; updating a key overwrites the previous value
  - The system does not enforce any schema on metadata values - validation is the responsibility of the implementing code
----- END PAGE https://docs.canvasmedical.com/sdk/effect-patient-metadata/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-patient/
The `Patient` effect enables the creation and updating of patient records within the Canvas system. This effect captures demographic information, contact details, and clinical associations necessary for patient registration and updates.
##  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`first_name` | `str` | Patient's first name | Yes  
`last_name` | `str` | Patient's last name | Yes  
`middle_name` | `str` or `None` | Patient's middle name | No  
`birthdate` | `datetime.date` or `None` | Patient's date of birth | No  
`prefix` | `str` or `None` | Name prefix (e.g., "Dr.", "Mr.") | No  
`suffix` | `str` or `None` | Name suffix (e.g., "Jr.", "III") | No  
`sex_at_birth` | `PersonSex` or `None` | Patient's sex assigned at birth | No  
`nickname` | `str` or `None` | Patient's preferred name or nickname | No  
`social_security_number` | `str` or `None` | Patient's SSN | No  
`administrative_note` | `str` or `None` | Administrative notes about the patient | No  
`clinical_note` | `str` or `None` | Clinical notes about the patient | No  
`default_location_id` | `str` or `None` | ID of patient's default practice location | No  
`default_provider_id` | `str` or `None` | ID of patient's default healthcare provider | No  
`previous_names` | `list[str]` or `None` | List of patient's previous names | No  
`contact_points` | `list[PatientContactPoint]` or `None` | Patient's contact information | No  
`external_identifiers` | `list[PatientExternalIdentifier]` or `None` | Patient's external identifiers | No  
`patient_id` | `str` or `None` | Patient ID (required for updates only) | No  
`addresses` | `list[PatientAddress]` or `None` | Patient's addresses | No  
`preferred_pharmacies` | `list[PatientPreferredPharmacy]` or `None` | Patient's preferred pharmacies | No  
`preferred_pharmacies` | `list[PatientMetadata]` or `None` | Patient metadata | No  
##  PatientContactPoint 
The `PatientContactPoint` dataclass represents various methods of contacting the patient.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`system` | `ContactPointSystem` | Type of contact (e.g., phone, email) | Yes  
`value` | `str` | The contact information value (e.g., phone number, email address) | Yes  
`use` | `ContactPointUse` | Purpose of the contact point (e.g., home, work) | Yes  
`rank` | `int` | Priority order of contact methods | Yes  
`has_consent` | `bool` or `None` | Whether consent has been given to use this contact method | No  
##  PatientExternalIdentifier 
The `PatientExternalIdentifier` dataclass represents an external identifier (ID) associated with the patient. An example would be the unique patient ID for a third party system integrated with Canvas EMR.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`system` | `str` | URL of the system of origin for the external ID (e.g., `http://hl7.org/fhir/sid/us-ssn`) | Yes  
`value` | `str` | The external ID or membership number/value | Yes  
##  PatientAddress 
The `PatientAddress` dataclass represents a patient's address information.
###  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`line1` | `str` | Street address line 1 | Yes  
`line2` | `str` or `None` | Street address line 2 | No  
`city` | `str` | City name | Yes  
`state_code` | `str` | State code (e.g., "CA", "NY") | Yes  
`postal_code` | `str` | Postal/ZIP code | Yes  
`country` | `str` | Country code | Yes  
`use` | `AddressUse` | Address type (e.g., home, work) | Yes  
> **Warning:** Address updates are **replace-based**. When updating a patient's addresses, the provided address list will completely replace all existing addresses. If you provide an empty list, all existing addresses will be deleted. 
##  PatientPreferredPharmacy 
The `PatientPreferredPharmacy` dataclass represents a patient's preferred pharmacy, and if it's their default pharmacy.
Attribute | Type | Description | Required  
---|---|---|---  
`ncpdp_id` | `str` | The ncpdp ID of the pharmacy | Yes  
`default` | `bool` | True if it's the default pharmacy | Yes  
##  PatientMetadata 
The `PatientMetadata` dataclass represents a custom key-value pair for a patient.
Attribute | Type | Description | Required  
---|---|---|---  
`key` | `str` | The key of the metadata | Yes  
`value` | `str` | The value of the metadata | Yes  
##  Implementation Details 
  - **Creation** : Creates new patient records when `patient_id` is not provided
  - **Updates** : Updates existing patient records when `patient_id` is provided
  - Validates that referenced practice locations exist in the system
  - Verifies that referenced healthcare providers exist in the system
  - Structures contact information through the `PatientContactPoint` dataclass
  - Structures external identifier through the `PatientExternalIdentifier` dataclass
  - Structures address information through the `PatientAddress` dataclass
  - Structures metadata through the `PatientMetadata` dataclass
##  Example Usage 
    ```python
    from canvas_sdk.effects.patient import Patient, PatientContactPoint, PatientExternalIdentifier, PatientMetadata
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.common import ContactPointSystem, ContactPointUse, PersonSex
    import datetime
    class Protocol(BaseHandler):
        def compute(self):
            patient = Patient(
                first_name="Jane",
                last_name="Doe",
                middle_name="Marie",
                birthdate=datetime.date(1980, 1, 15),
                sex_at_birth=PersonSex.SEX_FEMALE,
                nickname="Janie",
                default_location_id="location-uuid",
                default_provider_id="provider-uuid",
                contact_points=[
                    PatientContactPoint(
                        system=ContactPointSystem.PHONE,
                        value="555-123-4567",
                        use=ContactPointUse.MOBILE,
                        rank=1,
                        has_consent=True
                    ),
                    PatientContactPoint(
                        system=ContactPointSystem.EMAIL,
                        value="jane.doe@example.com",
                        use=ContactPointUse.WORK,
                        rank=2,
                        has_consent=True
                    )
                ],
                external_identifiers=[
                    PatientExternalIdentifier(
                        system="http://www.aaa.com",
                        value="pat_id_123456"
                    )
                ],
                metadata = [
                    PatientMetadata(key="source", value="plugin"),
                    PatientMetadata(key="created_on", value=datetime.datetime.now().isoformat())
                ]
            )
            return [patient.create()]
    ```
#  Patient Update Example 
    ```python
    from canvas_sdk.effects.patient import Patient, PatientAddress, PatientExternalIdentifier
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.common import AddressUse
    class Protocol(BaseHandler):
        def compute(self):
            # Update an existing patient
            updated_patient = Patient(
                patient_id="existing-patient-uuid",
                first_name="Jane",
                last_name="Smith",  # Changed last name
                addresses=[
                    PatientAddress(
                        line1="456 Updated Street",
                        line2="Suite 200",
                        city="Updated City",
                        state_code="CA",
                        postal_code="90210",
                        country="US",
                        use=AddressUse.HOME
                    )
                ],
                external_identifiers=[
                    PatientExternalIdentifier(
                        system="http://www.updated-system.com",
                        value="new_patient_id_789"
                    )
                ]
            )
            return [updated_patient.update()]
    ```
##  Validation 
The effect performs validation before execution to ensure data integrity:
  1. **Required Fields** : 
     - For creation: Validates that mandatory fields like `first_name` and `last_name` are provided
     - For updates: Requires `patient_id` to be provided and verifies the patient exists in the database
  2. **Referenced Entity Validation** : Confirms that any referenced entities exist in the system: 
     - Verifies that the specified default practice location exists
     - Ensures that the specified default provider exists
  3. **Data Format Validation** : Ensures that provided values conform to expected formats: 
     - Date fields must be valid dates
     - Enumerated types like `PersonSex`, `ContactPointSystem`, and `ContactPointUse` must contain valid values
  4. **Update-Specific Validation** : 
     - Ensures `patient_id` is not provided during patient creation
     - Validates that the patient exists before attempting updates
----- END PAGE https://docs.canvasmedical.com/sdk/effect-patient/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-protocol-cards/
Protocol cards appear on the right-hand-side of a patient's chart, and can be accessed by clicking on the Protocols filter button in the filter menu.
![protocol card](/assets/images/protocol-card.png)
A Protocol card consists of three main parts:
  - A title, which appears at the top in bold
  - A narrative, which appears just below the title to add any additional clarifying information
  - A list of recommendations, which each have a title and optionally a button that can either: 
    - open a new tab and navigate to another site
    - insert a command into a note
Name | Type | Required | Description  
---|---|---|---  
`patient_id` | _string_ | `true` (if `patient_filter` is not included) | The id of the [patient](/sdk/data-patient/)  
`patient_filter` | _dict_ | `true` (if `patient_id` is not included) | Patient queryset filters to apply the effect to multiple patients. For example, `{"active": True}` will apply to the effect to all active patients  
`key` | _string_ | `true` | A unique identifier for the protocol card  
`title` | _string_ | `true` | The title for the protocol card, which appears at the top in bold  
`narrative` | _string_ | `false` | The narrative for the protocol card, which appears just below the title  
`can_be_snoozed` | _boolean_ | `false` | Whether the protocol card can be snoozed, defaults to `false`  
`status` | Status | `false` | The status of the protocol card, defaults to `Status.DUE`  
`recommendations` | list[Recommendation] | `false` | The recommendations to appear in the protocol card  
`feedback_enabled` | _boolean_ | `false` | Whether users can provide feedback for the protocol card in Settings, defaults to `false`  
`due_in` | _integer_ | `false` | The number of days until the protocol card will be considered due for the patient, defaults to `-1` for already due  
|  |  |   
###  Recommendation 
Attribute | Type | Required | Description  
---|---|---|---  
`title` | _string_ | `true` | The description of the recommendation  
`button` | _string_ | `false` | The text to appear on the button  
`href` | _string_ | `false` | The url for the button to navigate to  
|  |  |   
###  Status 
Enum | Value  
---|---  
`DUE` | due  
`SATISFIED` | satisfied  
`NOT_APPLICABLE` | not_applicable  
`PENDING` | pending  
`NOT_RELEVANT` | not_relevant  
|   
To include a command recommendation, we recommend you import the command from the [commands module](/sdk/commands/), instantiate the command with all the values you wish to populate, and then call `.recommend(title: str = "", button: str | None)` on the command to generate the recommendation that you can append to the protocol card's recommendations. Keep in mind that, at the moment, not all commands are supported for command insertion. See below for the list of supported commands.
</br> </br>
For non-command recommendations, you can either use the `Recommendation` class, or the `.add_recommendation(title: str = "", button: str = "", href: str | None)` method on the protocol card.
**Example** :
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from datetime import date
    from canvas_sdk.effects.protocol_card import ProtocolCard, Recommendation
    from canvas_sdk.commands import DiagnoseCommand
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_UPDATED)
        def compute(self):
            p = ProtocolCard(
                patient_id=self.target,
                key="testing-protocol-cards",
                title="This is a ProtocolCard title",
                narrative="this is the narrative",
                status=ProtocolCard.Status.DUE,
                recommendations=[Recommendation(title="this recommendation has no action, just words!")]
            )
            p.add_recommendation(
                title="this is a recommendation", button="go here", href="https://canvasmedical.com/"
            )
            diagnose = DiagnoseCommand(
                icd10_code="I10",
                background="feeling bad for many years",
                approximate_date_of_onset=date(2020, 1, 1),
                today_assessment="still not great",
            )
            p.recommendations.append(diagnose.recommend(title="this inserts a diagnose command"))
            return [p.apply()]
    ```
To apply the effect to all active patients on plugin create and plugin update, you would include the plugin create and update events in `RESPONDS_TO`. And when responding to one of the plugin events you would use `patient_filter` instead of `patient_id` for the ProtocolCard.
    ```python
    from canvas_sdk.effects.protocol_card import ProtocolCard, Recommendation
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from datetime import date
    from canvas_sdk.effects.protocol_card import ProtocolCard, Recommendation
    from canvas_sdk.commands import DiagnoseCommand
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.PATIENT_UPDATED),
            EventType.Name(EventType.PLUGIN_CREATED),
            EventType.Name(EventType.PLUGIN_UPDATED),
        ]
        def compute(self):
            p = ProtocolCard(
                key="testing-protocol-cards",
                title="This is a ProtocolCard title",
                narrative="this is the narrative",
                can_be_snoozed=True,
                recommendations=[
                    Recommendation(title="this recommendation has no action, just words!")
                ],
            )
            p.add_recommendation(
                title="this is a recommendation", button="go here", href="https://canvasmedical.com/"
            )
            diagnose = DiagnoseCommand(
                icd10_code="I10",
                background="feeling bad for many years",
                approximate_date_of_onset=date(2020, 1, 1),
                today_assessment="still not great",
            )
            p.recommendations.append(diagnose.recommend(title="this inserts a diagnose command"))
            if self.event.type in [EventType.PLUGIN_CREATED, EventType.PLUGIN_UPDATED]:
                p.patient_filter = {"active": True}
            else:
                p.patient_id = self.target
            return [p.apply()]
    ```
###  Supported Commands 
The following commands from the [commands module](/sdk/commands/) are currently supported for insertion from Protocol Cards:
  - Allergy
  - Assess
  - Diagnose
  - FollowUp
  - Goal
  - HistoryOfPresentIllness
  - Image
  - Immunize
  - Instruct
  - LabOrder
  - MedicationStatement
  - Perform
  - Plan
  - Prescribe
  - Questionnaire
  - ReasonForVisit
  - Refer
  - StructuredAssessment
  - Task
  - ValidateCodingGap
  - Vitals
----- END PAGE https://docs.canvasmedical.com/sdk/effect-protocol-cards/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-questionnaires/
The Canvas SDK includes functionality for handling questionnaire-related events.
##  Creating a Questionnaire 
Creating a questionnaire via the SDK requires current requires defining a YAML template and referencing it in your `CANVAS_MANIFEST.json` file. Read more [here](/sdk/questionnaires/).
##  Creating a Questionnaire Result 
The `CreateQuestionnaireResult` effect causes a new entry to appear in the Social Determinants section of the left side of the chart.
This effect enables custom scoring of questionnaires in Canvas.
###  Example 
**Note:** This example assumes that an M-CHAT questionnaire created and loaded into the Canvas instance.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.questionnaire_result import CreateQuestionnaireResult
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.command import Command
    class MChatQuestionnaireResult(BaseProtocol):
        """
        Return a CreateQuestionnaireResult effect in response to a committed Questionnaire Command that
        contains questions coded for the M-CHAT questionnaire.
        """
        RESPONDS_TO = [EventType.Name(EventType.QUESTIONNAIRE_COMMAND__POST_COMMIT)]
        MCHAT_CODE_SYSTEM = "INTERNAL"
        MCHAT_CODE = "mchat"
        def compute(self) -> list[Effect]:
            # Get the interview object, which will be the anchor object on the Questionnaire command.
            command = Command.objects.get(id=self.event.target.id)
            interview = command.anchor_object
            if not interview.committer:
                return []
            # Return no effects if the interview has no questions that are coded as M-CHAT questions
            if not any(
                q.code == self.MCHAT_CODE and q.code_system == self.MCHAT_CODE_SYSTEM
                for q in interview.questionnaires.all()
            ):
                return []
            # sum up the numerical value of each answered questionnaire
            score = 0
            for response in interview.interview_responses.all():
                score = score + int(response.response_option.value)
            # Determine the narrative and whether the result is abnormal
            if score >= 0 and score <= 2:
                abnormal = False
                narrative = (
                    "The score is LOW risk. Child has screened negative. No immediate follow-up is "
                    "needed. However, the child should be rescreened at 24 months or after 3 months "
                    "have passed if they are younger than 2 years. Monitoring the child's "
                    "development remains important."
                )
            elif score >= 3 and score <= 7:
                abnormal = True
                narrative = (
                    "The score is MODERATE risk. Administer the M-CHAT-R Follow-Up items that "
                    "correspond to the at-risk responses. Only those items which were scored at risk "
                    "need to be completed. If 2 or more items continue to be at-risk, refer the "
                    "child immediately for (a) early intervention and (b) diagnostic evaluation."
                )
            elif score >= 8 and score <= 20:
                abnormal = True
                narrative = (
                    "The score is HIGH risk. It is not necessary to complete the M-CHAT-R Follow-Up "
                    "at this time. Bypass Follow-Up, and refer immediately for (a) early "
                    "intervention and (b) diagnostic evaluation."
                )
            else:
                abnormal = True
                narrative = "Error occurred trying to score questionnaire."
            # Create and return the effect
            effect = CreateQuestionnaireResult(
                interview_id=str(interview.id),
                score=score,
                abnormal=abnormal,
                narrative=narrative,
                code_system=self.MCHAT_CODE_SYSTEM,
                code=self.MCHAT_CODE,
            )
            return [effect.apply()]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/effect-questionnaires/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-task-metadata/
The `TaskMetadata` effect provides a flexible key-value storage system for task-specific data within the Canvas system. This effect enables the creation and updating of custom metadata entries associated with task records, allowing for extensible task information storage beyond standard task fields.
##  Overview 
Task metadata serves as a powerful extension mechanism for storing custom task-related information that doesn't fit within the standard task data model.
##  Attributes 
Attribute | Type | Description | Required  
---|---|---|---  
`task_id` | `str` | Id of the task record to associate metadata with | Yes  
`key` | `str` | Unique identifier for the metadata entry within the task context | Yes  
##  Methods 
###  upsert(value: str) → Effect 
Creates or updates a metadata entry for the specified task and key combination.
####  Parameters 
Parameter | Type | Description | Required  
---|---|---|---  
`value` | `str` | The metadata value to store | Yes  
####  Returns 
An `Effect` object configured for upserting task metadata.
####  Behavior 
  - If a metadata entry with the specified key already exists for the task, it will be updated with the new value
  - If no entry exists, a new metadata entry will be created
  - The operation is idempotent - repeated calls with the same key and value will not create duplicate entries
##  Implementation Details 
###  Validation 
The effect performs comprehensive validation before execution:
  1. **Task Existence Validation** : Verifies that the referenced task exists in the system
  - Queries the task database to confirm the `task_id` corresponds to an existing task record
  - Returns a descriptive error if the task is not found
  1. **Field Validation** : Ensures all required fields are provided and properly formatted
  - Both `task_id` and `key` must be non-empty strings
  - The `value` parameter in the `upsert` method must be provided
###  Data Structure 
The effect payload is structured as JSON with the following schema:
    ```json
    {
      "data": {
        "task_id": "task-id",
        "key": "metadata-key",
        "value": "metadata-value"
      }
    }
    ```
##  Example Usage 
###  Basic Usage 
    ```python
    from canvas_sdk.effects.task import TaskMetadata
    # Create a metadata entry for task tracking
    metadata = TaskMetadata(
        task_id="550e8400e29b41d4a716446655440000",
        key="external_system_id"
    )
    # Upsert the metadata value
    effect = metadata.upsert("EXT-12345")
    ```
###  Task Integration Example 
    ```python
    import json
    from canvas_sdk.effects.task import TaskMetadata
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.events import EventType
    class TaskMetadataHandler(BaseHandler):
      """
      Adds metadata to tasks based on task properties.
      """
      RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
      def compute(self):
        task_id = self.context["task"]["id"]
        task_labels = self.context.get("task", {}).get("labels", [])
        effects = []
        # Store task creation source
        metadata = TaskMetadata(
          task_id=task_id,
          key="creation_source"
        )
        effects.append(metadata.upsert("protocol"))
        # Store label information as JSON
        if task_labels:
          labels_metadata = TaskMetadata(
            task_id=task_id,
            key="original_labels"
          )
          effects.append(labels_metadata.upsert(json.dumps(task_labels)))
        return effects
    ```
##  Best Practices 
###  Key Naming Conventions 
  1. **Use Descriptive Names** : Choose keys that clearly indicate the purpose of the metadata
  - Good: `external_system_id`, `workflow_stage`, `integration_source`
  - Avoid: `data1`, `temp`, `misc`
  1. **Namespace Your Keys** : When building integrations or modules, prefix keys to avoid collisions
  - Example: `integration_task_id`, `workflow_current_stage`, `automation_trigger_id`
###  Value Storage 
  1. **String Serialization** : All values are stored as strings. For complex data types: 
         ```python
         # Storing JSON data
         import json
         from canvas_sdk.effects.task import TaskMetadata
         metadata = TaskMetadata(
             task_id="550e8400e29b41d4a716446655440000",
             key="workflow_state"
         )
         complex_data = {"stage": "review", "approvers": ["user1", "user2"], "timestamp": "2025-01-15T10:30:00Z"}
         metadata.upsert(json.dumps(complex_data))
         ```
  2. **Boolean Values** : Store as "true" or "false" strings for consistency 
         ```python
         from canvas_sdk.effects.task import TaskMetadata
         needs_followup = True
         metadata = TaskMetadata(
             task_id="550e8400e29b41d4a716446655440000",
             key="requires_followup"
         )
         metadata.upsert("true" if needs_followup else "false")
         ```
##  Notes 
  - Metadata entries are task-specific and isolated - the same key can have different values for different tasks
  - There is no built-in versioning; updating a key overwrites the previous value
  - The system does not enforce any schema on metadata values - validation is the responsibility of the implementing code
----- END PAGE https://docs.canvasmedical.com/sdk/effect-task-metadata/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effect-tasks/
The Canvas SDK includes functionality to create, update and add comments to tasks in Canvas.
##  Adding a Task 
To add a task, import the `AddTask` class and create an instance of it.
Attribute |  | Type | Description  
---|---|---|---  
id | optional | string or UUID | Task unique UUID. If none one will be generated automatically.  
assignee_id | optional | string | The id of the [staff](/sdk/data-staff/) the task should be assigned to.  
team_id | optional | string | The id of the [team](/sdk/data-team/) the task should be assigned to.  
patient_id | optional | string | The id of the [patient](/sdk/data-patient/) the task is associated with.  
title | required | string | The title of the task. This is displayed at the top of a task card in the Canvas UI.  
due | optional | datetime | A date/time when the task is due.  
status | optional | TaskStatus | A status of OPEN, CLOSED or COMPLETED. Defaults to OPEN if not supplied.  
labels | optional | list[string] | A list of labels that will be added at the bottom of a task card in the Canvas UI.  
author_id | optional | string or UUID | Author's id to set task creator, defaults to CanvasBot.  
linked_object_id | optional | string or UUID | Linked object id of linked object.  
linked_object_type | optional | LinkableObjectType | Type of the LinkedObject  
###  Enumeration Type 
####  Linked Object Type 
Value | Description  
---|---  
REFERRAL | REFERRAL  
IMAGING | IMAGING  
An example of adding a task:
    ```python
    import arrow
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.task import AddTask, AddTaskComment, UpdateTask, TaskStatus
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.lab import LabReport
    from canvas_sdk.v1.data.staff import Staff
    from canvas_sdk.v1.data.team import Team
    from canvas_sdk.v1.data.referral import Referral
    class Protocol(BaseProtocol):
        RESPONDS_TO = [
            EventType.Name(EventType.LAB_REPORT_CREATED),
        ]
        def compute(self) -> list[Effect]:
            lab_report = LabReport.objects.get(id=self.target)
            staff_assignee = Staff.objects.get(last_name="Weed")
            team = Team.objects.get(name="Labs")
            linked_task_type = AddTask.LinkableObjectType.REFERRAL
            referral = Referral.objects.get(id="d2194110-5c9a-4842-8733-ef09ea5ead11")
            if lab_report.patient:
                add_task = AddTask(
                    assignee_id=staff_assignee.id,
                    author_id=staff_assignee.id,
                    team_id = team.id,
                    patient_id=lab_report.patient.id,
                    title="Please call the patient with their test results.",
                    due=arrow.utcnow().shift(days=5).datetime,
                    status=TaskStatus.OPEN,
                    labels=["call"],
                    linked_object_id=referral.id,
                    linked_object_type=linked_task_type,
                )
                return [add_task.apply()]
            return []
    ```
##  Updating a Task 
To update an existing task, import the `UpdateTask` class and create an instance of it.
Attribute |  | Type | Description  
---|---|---|---  
id | required | string | The id of the task being updated.  
assignee_id | optional | string | The id of the [staff](/sdk/data-staff/) the task should be assigned to.  
team_id | optional | string | The id of the [team](/sdk/data-team/) the task should be assigned to.  
patient_id | optional | string | The id of the [patient](/sdk/data-patient/) the task is associated with.  
title | optional | string | The title of the task. This is displayed at the top of a task card in the Canvas UI.  
due | optional | datetime | A date/time when the task is due.  
status | optional | TaskStatus | A status of `OPEN`, `CLOSED` or `COMPLETED`. Defaults to `OPEN` if not supplied.  
labels | optional | list[string] | A list of labels that will be added at the bottom of a task card in the Canvas UI.  
An example of updating a task to a status of `COMPLETED`:
    ```python
    from canvas_sdk.effects.task import UpdateTask, TaskStatus
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        def compute(self):
            update_task = UpdateTask(
                id="d06276ba-85c5-471b-87c0-9c9805f4ca6f",
                status=TaskStatus.COMPLETED,
            )
            return [update_task.apply()]
    ```
##  Adding a comment to a task 
To add a comment to a task, import the `AddTaskComment` class and create an instance of it.
Attribute |  | Type | Description  
---|---|---|---  
task_id | required | string | The id of the task being updated.  
body | required | string | The comment body.  
author_id | optional | string or UUID | Author's id to set task comment creator, defaults to CanvasBot.  
    ```python
    from canvas_sdk.effects.task import AddTaskComment
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.v1.data.staff import Staff
    class Protocol(BaseHandler):
        def compute(self):
            author = Staff.objects.get(last_name="Weed")
            add_task_comment = AddTaskComment(
                task_id="d06276ba-85c5-471b-87c0-9c9805f4ca6f",
                body="I tried to call the patient but did not get an answer.",
                author_id=author.id
            )
            return [add_task_comment.apply()]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/effect-tasks/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/effects/
Effects are instructions that plugins can return in order to perform an action in the Canvas EMR. This makes it possible to define workflows that create commands, show notifications, modify search results, etc.
Effects have a `type` and a `payload`. The `type` determines the action that will be performed with the data provided in the `payload`.
##  Using Effects 
###  Basic Usage 
Effects are returned as a list from the `compute` method of a plugin that inherits from `BaseHandler`. For example:
    ```python
    import json
    from canvas_sdk.events import EventType
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.handlers.base import BaseHandler
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.MEDICATION_STATEMENT__MEDICATION__POST_SEARCH)
        def compute(self):
            results = self.context.get("results")
            post_processed_results = []
            ## custom results-modifying code here
            ...
            return [
                Effect(
                    type=EffectType.AUTOCOMPLETE_SEARCH_RESULTS,
                    payload=json.dumps(post_processed_results),
                )
            ]
    ```
In the above example, the `Effect` object is constructed manually, with the `type` and `payload` set directly.
Some effects have helper classes that assist you by providing payload validation and constructing the effect object for you. The example below shows the [`PatientChartSummaryConfiguration`](/sdk/layout-effect/#patient-summary) class in use:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.effects.patient_chart_summary_configuration import PatientChartSummaryConfiguration
    class CustomChartLayout(BaseHandler):
        """
        This event handler rearranges the patient summary section and hides those
        not used by the installation's organization.
        """
        # This event fires when a patient's chart summary section is loading.
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            layout = PatientChartSummaryConfiguration(sections=[
              PatientChartSummaryConfiguration.Section.SOCIAL_DETERMINANTS,
              PatientChartSummaryConfiguration.Section.ALLERGIES,
              PatientChartSummaryConfiguration.Section.VITALS,
              PatientChartSummaryConfiguration.Section.MEDICATIONS,
              PatientChartSummaryConfiguration.Section.CONDITIONS,
              PatientChartSummaryConfiguration.Section.IMMUNIZATIONS,
            ])
            return [layout.apply()]
    ```
###  Disallowed Effect/Event Combinations 
Canvas prevents certain combinations of events and effects to avoid infinite loops that could occur when an effect triggers the same event that generated it. The following combinations are specifically disallowed:
Event Type | Disallowed Effect Types  
---|---  
`PATIENT_CHART__CONDITIONS` | `ADD_BANNER_ALERT`  
`ADD_OR_UPDATE_PROTOCOL_CARD`  
`PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` | `ADD_BANNER_ALERT`  
`ADD_OR_UPDATE_PROTOCOL_CARD`  
For example, if you have a plugin that responds to `PATIENT_CHART__CONDITIONS` events, you cannot return `ADD_BANNER_ALERT` or `ADD_OR_UPDATE_PROTOCOL_CARD` effects from that plugin, as this could create an infinite loop where the effect triggers another conditions event.
##  Effect Classes 
[ Appointments Create, update, and cancel patient appointments. ](/sdk/effect-notes/#appointment-effect) [ Appointment Metadata Interact with appointment metadata. ](/sdk/effect-appointment-metadata/) [ Appointment Metadata Create Form Effect for dynamically displaying forms when scheduling an appointment. ](/sdk/appointment-metadata-create-form-effect/) [ Banner Alerts Contextual information in a patient's chart. ](/sdk/effect-banner-alerts/) [ Billing Line Items Add, modify, or remove billing codes on a note. ](/sdk/effect-billing-line-items/) [ Claims Manage labels, update line items, move to a queue, or post a payment. ](/sdk/effect-claims/) [ Compound Medications Create or update compound medications. ](/sdk/effect-compound-medication/) [ External Events Create or update external clinical events from ADT feeds. ](/sdk/effect-external-event/) [ Command Validation Validate commands and return structured error messages to users. ](/sdk/effect-command-validation/) [ Custom HTML and Django Templates Render custom HTML using Django templates. ](/sdk/layout-effect/#custom-html-and-django-templates/) [ Create Calendar Create a calendar for a provider. ](/sdk/calendar-create-effect/) [ Event Validation Error Effect for blocking event creation with a validation error message. ](/sdk/effect-event-validation-error/) [ Manage Calendar Events Manage calendar events. ](/sdk/calendar-event-management-effects/) [ Form Result Effect for dynamically displaying forms in the Patient Portal. ](/sdk/form-result-effect/) [ Layout Effects Modify or interact with the layout in Canvas. ](/sdk/layout-effect/) [ Messages Interact with messages in Canvas. ](/sdk/effect-messages/) [ Notes Interact with notes in Canvas. ](/sdk/effect-notes/) [ Observations Create or update clinical observations. ](/sdk/effect-observation/) [ Patient Interact with patient data. ](/sdk/effect-patient/) [ Patient Facility Address Create, update, or delete patient facility address associations. ](/sdk/effect-patient-facility-address/) [ Patient Chart Group Effect for grouping items on a patient chart section. ](/sdk/patient-chart-group-effect/) [ Patient External ID Create a new external identifier for a patient. ](/sdk/effect-create-patient-external-identifier/) [ Patient Metadata Interact with patient metadata. ](/sdk/effect-patient-metadata/) [ Patient Metadata Create Form Effect for dynamically displaying forms in the Patient profile. ](/sdk/patient-metadata-create-form-effect/) [ Patient Portal Customize your Patient Portal. ](/sdk/patient-portal/) [ Protocol Cards Calls to action in a patient's chart, commonly used for decision support intervention. ](/sdk/effect-protocol-cards/) [ Questionnaires Interact with questionnaires and interviews. ](/sdk/effect-questionnaires/) [ Tasks Create or update tasks. ](/sdk/effect-tasks/) [ Task Metadata Interact with Task metadata. ](/sdk/effect-task-metadata/) [ Commands The building blocks of many end-user workflows in Canvas, including nearly all clinical workflows for documentation. ](/sdk/commands/)
##  Effect Types 
The following effects are available to be applied in Canvas.
Effect | Description  
---|---  
ADD_BANNER_ALERT | Can be used to [add a banner alert](/sdk/effect-banner-alerts/#adding-a-banner-alert) to a patient's chart.  
REMOVE_BANNER_ALERT | Can be used to [remove a banner alert](/sdk/effect-banner-alerts/#removing-a-banner-alert) from a patient's chart.  
SHOW_PATIENT_CHART_SUMMARY_SECTIONS | Can be used to reorder or hide the summary sections in a patient chart. Check out [this effect class](/sdk/layout-effect/#patient-summary/).  
PATIENT_CHART__GROUP_ITEMS | Can be used to group items within a specific patient chart section.  
SHOW_ACTION_BUTTON | Can be used to show an action button. Check out [Action Buttons](/sdk/handlers-action-buttons/).  
LAUNCH_MODAL | Can be used to launch a modal window. Check out [Modals](/sdk/layout-effect/#modals).  
PORTAL_WIDGET | Can be used to add widgets to patient portal landing page. Check out [Portal Landing Page Widgets](/sdk/layout-effect/#portal-landing-page-widgets)  
ADD_OR_UPDATE_PROTOCOL_CARD | Can be used to generate a ProtocolCard in the Canvas UI. Use the [ProtocolCard](/sdk/effect-protocol-cards/) class in the effects module.  
ADD_BILLING_LINE_ITEM | Can be used to generate a Billing Line Item in a note footer. Use the [AddBillingLineItem](/sdk/effect-billing-line-items/) class in the effects module.  
UPDATE_BILLING_LINE_ITEM | Can be used to update an existing Billing Line Item in a note footer. Use the [UpdateBillingLineItem](/sdk/effect-billing-line-items/) class in the effects module.  
REMOVE_BILLING_LINE_ITEM | Can be used to remove a Billing Line Item in a note footer. Use the [RemoveBillingLineItem](/sdk/effect-billing-line-items/) class in the effects module.  
ANNOTATE_CLAIM_CONDITION_RESULTS | Can be used to add annotations to the conditions appearing in a claim's detail view.  
ANNOTATE_PATIENT_CHART_CONDITION_RESULTS | Add an annotation to a condition within the patient summary.  
ANNOTATE_PATIENT_CHART_DETECTED_ISSUE_RESULTS | Add an annotation to a detected issue within the patient summary.  
AUTOCOMPLETE_SEARCH_RESULTS | Can be used to modify search results by re-ordering or adding text annotations to individual result records. To see how you can put this to use, check out [this guide](/guides/customize-search-results/).  
PATIENT_PROFILE__ADD_PHARMACY__POST_SEARCH_RESULTS | Can be used to modify pharmacy results when adding pharmacies in the patient profile.  
CREATE_TASK | Cause a task you define in a plugin to be created.  
UPDATE_TASK | Cause a task to be updated.  
CREATE_TASK_COMMENT | Add a comment to an existing task.  
COMMAND_AVAILABLE_ACTIONS_RESULTS | Can be used to sort or filter command available actions. Checkout command available [actions](sdk/commands/#command-actions)  
COMMAND_VALIDATION_ERRORS | Can be used to return validation errors for commands. Check out [Command Validation](/sdk/effect-command-validation/).  
ORIGINATE_ALLERGY_COMMAND | Can be used to originate an allergy command in a note.  
EDIT_ALLERGY_COMMAND | Can be used to edit an allergy command in a note.  
COMMIT_ALLERGY_COMMAND | Can be used to commit an allergy command in a note.  
ORIGINATE_REMOVE_ALLERGY_COMMAND | Can be used to originate a remove allergy command in a note.  
EDIT_REMOVE_ALLERGY_COMMAND | Can be used to edit a remove allergy command in a note.  
COMMIT_REMOVE_ALLERGY_COMMAND | Can be used to commit a remove allergy command in a note.  
ORIGINATE_GOAL_COMMAND | Can be used to originate a goal command in a note.  
EDIT_GOAL_COMMAND | Can be used to edit a goal command in a note.  
COMMIT_GOAL_COMMAND | Can be used to commit a goal command in a note.  
ORIGINATE_UPDATE_GOAL_COMMAND | Can be used to originate an update goal command in a note.  
EDIT_UPDATE_GOAL_COMMAND | Can be used to edit an update goal command in a note.  
COMMIT_UPDATE_GOAL_COMMAND | Can be used to commit an update goal command in a note.  
ORIGINATE_CLOSE_GOAL_COMMAND | Can be used to originate a close goal command in a note.  
EDIT_CLOSE_GOAL_COMMAND | Can be used to edit a close goal command in a note.  
COMMIT_CLOSE_GOAL_COMMAND | Can be used to commit a close goal command in a note.  
ORIGINATE_DIAGNOSE_COMMAND | Can be used to originate a diagnose command in a note.  
EDIT_DIAGNOSE_COMMAND | Can be used to edit a diagnose command in a note.  
COMMIT_DIAGNOSE_COMMAND | Can be used to commit a diagnose command in a note.  
ORIGINATE_UPDATE_DIAGNOSIS_COMMAND | Can be used to originate an update diagnosis command in a note.  
EDIT_UPDATE_DIAGNOSIS_COMMAND | Can be used to edit an update diagnosis command in a note.  
COMMIT_UPDATE_DIAGNOSIS_COMMAND | Can be used to commit an update diagnosis command in a note.  
ORIGINATE_CHANGE_MEDICATION_COMMAND | Can be used to originate a change medication command in a note.  
EDIT_CHANGE_MEDICATION_COMMAND | Can be used to edit a change medication command in a note.  
COMMIT_CHANGE_MEDICATION_COMMAND | Can be used to commit a change medication command in a note.  
ORIGINATE_ASSESS_COMMAND | Can be used to originate an assess command in a note.  
EDIT_ASSESS_COMMAND | Can be used to edit an assess command in a note.  
COMMIT_ASSESS_COMMAND | Can be used to commit an assess command in a note.  
ORIGINATE_PRESCRIBE_COMMAND | Can be used to originate a prescribe command in a note.  
EDIT_PRESCRIBE_COMMAND | Can be used to edit a prescribe command in a note.  
SEND_PRESCRIBE_COMMAND | Can be used to send a committed prescribe command in a note.  
REVIEW_PRESCRIBE_COMMAND | Can be used to set a prescribe command in review.  
ORIGINATE_REFILL_COMMAND | Can be used to originate a refill command in a note.  
EDIT_REFILL_COMMAND | Can be used to edit a refill command in a note.  
SEND_REFILL_COMMAND | Can be used to send a committed refill command in a note.  
REVIEW_REFILL_COMMAND | Can be used to set a refill command in review.  
ORIGINATE_MEDICATION_STATEMENT_COMMAND | Can be used to originate a medication statement command in a note.  
EDIT_MEDICATION_STATEMENT_COMMAND | Can be used to edit a medication statement command in a note.  
COMMIT_MEDICATION_STATEMENT_COMMAND | Can be used to commit a medication statement command in a note.  
ORIGINATE_STOP_MEDICATION_COMMAND | Can be used to originate a stop medication command in a note.  
EDIT_STOP_MEDICATION_COMMAND | Can be used to edit a stop medication command in a note.  
COMMIT_STOP_MEDICATION_COMMAND | Can be used to commit a stop medication command in a note.  
ORIGINATE_PLAN_COMMAND | Can be used to originate a plan command in a note.  
EDIT_PLAN_COMMAND | Can be used to edit a plan command in a note.  
COMMIT_PLAN_COMMAND | Can be used to commit a plan command in a note.  
ORIGINATE_HPI_COMMAND | Can be used to originate a history of present illness command in a note.  
EDIT_HPI_COMMAND | Can be used to edit a history of present illness command in a note.  
COMMIT_HPI_COMMAND | Can be used to commit a history of present illness command in a note.  
ORIGINATE_FAMILY_HISTORY_COMMAND | Can be used to originate a family history command in a note.  
EDIT_FAMILY_HISTORY_COMMAND | Can be used to edit a family history command in a note.  
COMMIT_FAMILY_HISTORY_COMMAND | Can be used to commit a family history command in a note.  
ORIGINATE_MEDICAL_HISTORY_COMMAND | Can be used to originate a medical history command in a note.  
EDIT_MEDICAL_HISTORY_COMMAND | Can be used to edit a medical history command in a note.  
COMMIT_MEDICAL_HISTORY_COMMAND | Can be used to commit a medical history command in a note.  
ORIGINATE_SURGICAL_HISTORY_COMMAND | Can be used to originate a surgical history command in a note.  
EDIT_SURGICAL_HISTORY_COMMAND | Can be used to edit a surgical history command in a note.  
COMMIT_SURGICAL_HISTORY_COMMAND | Can be used to commit a surgical history command in a note.  
ORIGINATE_INSTRUCT_COMMAND | Can be used to originate an instruct command in a note.  
EDIT_INSTRUCT_COMMAND | Can be used to edit an instruct command in a note.  
COMMIT_INSTRUCT_COMMAND | Can be used to commit an instruct command in a note.  
ORIGINATE_LAB_ORDER_COMMAND | Can be used to originate a lab order command in a note.  
EDIT_LAB_ORDER_COMMAND | Can be used to edit a lab order command in a note.  
COMMIT_LAB_ORDER_COMMAND | Can be used to commit a lab order command in a note.  
SEND_LAB_ORDER_COMMAND | Can be used to send a committed lab order command in a note.  
ORIGINATE_PERFORM_COMMAND | Can be used to originate a perform command in a note.  
EDIT_PERFORM_COMMAND | Can be used to edit a perform command in a note.  
COMMIT_PERFORM_COMMAND | Can be used to commit a perform command in a note.  
ORIGINATE_QUESTIONNAIRE_COMMAND | Can be used to originate a questionnaire command in a note.  
EDIT_QUESTIONNAIRE_COMMAND | Can be used to edit a questionnaire command in a note.  
COMMIT_QUESTIONNAIRE_COMMAND | Can be used to commit a questionnaire command in a note.  
ORIGINATE_REASON_FOR_VISIT_COMMAND | Can be used to originate a reason for visit command in a note.  
EDIT_REASON_FOR_VISIT_COMMAND | Can be used to edit a reason for visit command in a note.  
COMMIT_REASON_FOR_VISIT_COMMAND | Can be used to commit a reason for visit command in a note.  
ORIGINATE_TASK_COMMAND | Can be used to originate a task command in a note.  
EDIT_TASK_COMMAND | Can be used to edit a task command in a note.  
COMMIT_TASK_COMMAND | Can be used to commit a task command in a note.  
ORIGINATE_VITALS_COMMAND | Can be used to originate a vitals command in a note.  
EDIT_VITALS_COMMAND | Can be used to edit a vitals command in a note.  
COMMIT_VITALS_COMMAND | Can be used to commit a vitals command in a note.  
ORIGINATE_FOLLOW_UP_COMMAND | Can be used to originate a follow up command in a note.  
EDIT_FOLLOW_UP_COMMAND | Can be used to edit a follow up command in a note.  
COMMIT_FOLLOW_UP_COMMAND | Can be used to commit a follow up command in a note.  
ORIGINATE_IMAGING_ORDER_COMMAND | Can be used to originate a imaging order command in a note.  
EDIT_IMAGING_ORDER_COMMAND | Can be used to edit a imaging order command in a note.  
COMMIT_IMAGING_ORDER_COMMAND | Can be used to commit a imaging order command in a note.  
ORIGINATE_REFER_COMMAND | Can be used to originate a refer command in a note.  
EDIT_REFER_COMMAND | Can be used to edit a refer command in a note.  
COMMIT_REFER_COMMAND | Can be used to commit a refer command in a note.  
ORIGINATE_ADJUST_PRESCRIPTION_COMMAND | Can be used to originate an adjust prescription command in a note.  
EDIT_ADJUST_PRESCRIPTION_COMMAND | Can be used to edit an adjust prescription command in a note.  
SEND_ADJUST_PRESCRIPTION_COMMAND | Can be used to send a adjust prescription command in a note.  
REVIEW_ADJUST_PRESCRIPTION_COMMAND | Can be used to set an adjust prescription command in review.  
ORIGINATE_RESOLVE_CONDITION_COMMAND | Can be used to originate a resolve condition command in a note.  
EDIT_RESOLVE_CONDITION_COMMAND | Can be used to edit a resolve condition command in a note.  
COMMIT_RESOLVE_CONDITION_COMMAND | Can be used to commit a resolve condition command in a note.  
PATIENT_PORTAL__APPOINTMENT_SHOW_MEETING_LINK | Can be used to show the 'join' button on the telehealth appointment card, allowing patients to easily join their appointments.  
PATIENT_PORTAL__APPOINTMENT_IS_CANCELABLE | Can be used to show the 'cancel' button on the appointment card, allowing patients to easily cancel their appointments  
PATIENT_PORTAL__APPOINTMENT_IS_RESCHEDULABLE | Can be used to show the 'reschedule' button on the appointment card, allowing patients to easily reschedule their appointments  
UPDATE_USER | Can be used to update a user  
PATIENT_PORTAL__SEND_INVITE | Can be used to trigger a portal invitation for a user  
PATIENT_METADATA__CREATE_ADDITIONAL_FIELDS | Can be used to show additional fields on the patient profile section  
APPOINTMENT__FORM__PROVIDERS__PRE_SEARCH_RESULTS | Can be used to modify the list of providers shown in the appointment scheduling form before a search is performed  
APPOINTMENT__FORM__LOCATIONS__PRE_SEARCH_RESULTS | Can be used to modify the list of locations shown in the appointment scheduling form before a search is performed  
APPOINTMENT__FORM__VISIT_TYPES__PRE_SEARCH_RESULTS | Can be used to modify the list of visit types shown in the appointment scheduling form before a search is performed  
APPOINTMENT__FORM__DURATIONS__PRE_SEARCH_RESULTS | Can be used to modify the list of durations shown in the appointment scheduling form before a search is performed  
APPOINTMENT__FORM__REASON_FOR_VISIT__PRE_SEARCH_RESULTS | Can be used to modify the reason for visit field in the appointment scheduling form before a search is performed  
APPOINTMENT__FORM__PROVIDERS__POST_SEARCH_RESULTS | Can be used to modify the list of providers shown in the appointment scheduling form after a search is performed  
APPOINTMENT__FORM__LOCATIONS__POST_SEARCH_RESULTS | Can be used to modify the list of locations shown in the appointment scheduling form after a search is performed  
APPOINTMENT__FORM__VISIT_TYPES__POST_SEARCH_RESULTS | Can be used to modify the list of visit types shown in the appointment scheduling form after a search is performed  
APPOINTMENT__FORM__DURATIONS__POST_SEARCH_RESULTS | Can be used to modify the list of durations shown in the appointment scheduling form after a search is performed  
APPOINTMENT__FORM__REASON_FOR_VISIT__POST_SEARCH_RESULTS | Can be used to modify the reason for visit field in the appointment scheduling form after a search is performed  
APPOINTMENT__FORM__CREATE_ADDITIONAL_FIELDS | Can be used to show additional fields on the appointment scheduling form  
UPSERT_APPOINTMENT_METADATA | Can be used to add additional metadata when creating or updating an appointment  
RESCHEDULE_APPOINTMENT | Can be used to reschedule an appointment. Check out [Appointment Effects](/sdk/effect-notes/#reschedule-appointment).  
RESCHEDULE_SCHEDULE_EVENT | Can be used to reschedule a schedule event. Check out [Schedule Event Effects](/sdk/effect-notes/#reschedule-schedule-event).  
APPOINTMENT_LABEL_ADDED | Add one or more labels to an appointment (max 3 total). Check out [Appointment Label Effects](/sdk/effect-appointment-labels/).  
APPOINTMENT_LABEL_REMOVED | Remove one or more labels from an appointment. Check out [Appointment Label Effects](/sdk/effect-appointment-labels/).  
APPOINTMENT__SLOTS__POST_SEARCH_RESULTS | Can be used to modify slot availability when scheduling an appointment  
----- END PAGE https://docs.canvasmedical.com/sdk/effects/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/events/
**What is an Event?**
An event is an occurrence of an action that happens within Canvas. For example, a patient being prescribed a medication, a user searching for a condition or an appointment being created are all examples of events.
**Why should I use them?**
By writing plugins that respond to events, plugin code is notified and can react to events that occur in Canvas. This enables plugin authors to create custom workflows whenever a relevant event takes place, such as making a POST request to a webhook.
**How do I use them?**
To make plugin code react to an event, you can add the event types listed below into the `RESPONDS_TO` list of a plugin that inherits from `BaseProtocol`. For example:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = [EventType.Name(EventType.ALLERGY_INTOLERANCE_CREATED)]
        def compute(self):
            ...
    ```
The plugin author can enter custom workflow code into the `compute` method that will execute every time an Allergy Intolerance is created in Canvas.
For more information on writing plugins, see the guide [here](/guides/your-first-plugin/).
##  Event Actor 
The actor is the user that initiated the event. It can be accessed within the compute method of the plugin by `self.event.actor`. It should be available for events that are directly initiated or triggered by a user — for example, SimpleAPI events, command pre- and post-search events, action button events. For side-effect events or automated events where the action cannot be attributed to a specific user, the actor may be absent.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers import BaseHandler
    from logger import log
    class CustomHandler(BaseHandler):
        RESPONDS_TO = []
        def compute(self) -> list[Effect]:
            actor = self.event.actor
            log.info(actor.dbid)        # The database ID of the actor, if available
            log.info(actor.instance)  # The corresponding CanvasUser instance
            log.info(actor.instance.person_subclass) # The corresponding Staff or Patient instance
            return []
    ```
##  Event Types and Context 
The event `target` object can be accessed within the compute method of the plugin by `self.event.target`. If `self.event.target.type` exists, it provides the same type that would be imported from the Data module. For example, a type of `Condition` would be the same as what you can import from `canvas_sdk.v1.data.condition`.
The event `context` object can be accessed via `self.event.context`. The content present in each event's context depends on the event type. The table below shows what you can expect for each event type, or you could take a look yourself by logging it out.
###  Common Context Patterns 
Many events include common contextual information to help you understand the scope and origin of the event:
  - **Patient context** : Most patient-related events include `"patient": {"id": pt_id}` in the context, allowing you to identify which patient the event relates to.
  - **Note context** : Command lifecycle events (PRE_COMMIT, POST_COMMIT, etc.) include `"note": {"uuid": note_id}` in the context, indicating the note where the command was executed.
  - **User context** : All command-related PRE_SEARCH and POST_SEARCH events include `"user": {"staff": staff_key}` in the context, containing the staff key of the user performing the search. This allows you to customize search results based on user-specific preferences, roles, or permissions.
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        RESPONDS_TO = [EventType.Name(EventType.ALLERGY_INTOLERANCE_CREATED)]
        def compute(self):
            log.info(self.event.context)
            return []
    ```
###  Record lifecycle events 
These events fire as a result of records being created, updated, or deleted.
####  Patients 
PATIENT_CREATED  
---  
Occurs when a patient is created.  
Target object | Context object  
    "id": pt_id
    "type": [Patient](/sdk/data-patient/)
| 
    empty  
PATIENT_UPDATED  
---  
Occurs when a patient's data is updated.  
Target object | Context object  
    "id": pt_id
    "type": [Patient](/sdk/data-patient/)
| 
    empty  
PATIENT_PREFERRED_PHARMACY_UPDATED  
---  
Occurs when a patient's preferred pharmacy is created or updated.  
Target object | Context object  
    "id": pt_id
    "type": [Patient](/sdk/data-patient/)
| 
    "patient":
        "id": pt_id  
CARE_TEAM_MEMBERSHIP_CREATED  
---  
Occurs when a new care team member is added for a patient.  
Target object | Context object  
    "id": care_team_membership_id
    "type": [CareTeamMembership](/sdk/data-care-team/#careteammembership)
| 
    "patient":
        "id": pt_id  
CARE_TEAM_MEMBERSHIP_UPDATED  
---  
Occurs when a care team member is adjusted for a patient.  
Target object | Context object  
    "id": care_team_membership_id
    "type": [CareTeamMembership](/sdk/data-care-team/#careteammembership)
| 
    "patient":
        "id": pt_id  
CARE_TEAM_MEMBERSHIP_DELETED  
---  
Occurs when a care team member is removed for a patient.  
Target object | Context object  
    "id": care_team_membership_id
    "type": [CareTeamMembership](/sdk/data-care-team/#careteammembership)
| 
    "patient":
        "id": pt_id  
PATIENT_ADDRESS_CREATED  
---  
Occurs when an address is added for a patient.  
Target object | Context object  
    "id": address_id
    "type": [PatientAddress](/sdk/data-patient/#patientaddress)
| 
    "patient":
        "id": pt_id  
PATIENT_ADDRESS_UPDATED  
---  
Occurs when one of a patient's addresses is updated.  
Target object | Context object  
    "id": address_id
    "type": [PatientAddress](/sdk/data-patient/#patientaddress)
| 
    "patient":
        "id": pt_id  
PATIENT_ADDRESS_DELETED  
---  
Occurs when one of a patient's addresses is removed.  
Target object | Context object  
    "id": address_id
    "type": [PatientAddress](/sdk/data-patient/#patientaddress)
| 
    "patient":
        "id": pt_id  
PATIENT_CONTACT_PERSON_CREATED  
---  
Occurs when a contact is added for a patient.  
Target object | Context object  
    "id": contact_person_id
    "type": None
| 
    "patient":
        "id": pt_id  
PATIENT_CONTACT_PERSON_UPDATED  
---  
Occurs when one of a patient's contacts is updated.  
Target object | Context object  
    "id": contact_person_id
    "type": None
| 
    "patient":
        "id": pt_id  
PATIENT_CONTACT_PERSON_DELETED  
---  
Occurs when one of a patient's contacts is removed.  
Target object | Context object  
    "id": contact_person_id
    "type": None
| 
    "patient":
        "id": pt_id  
PATIENT_CONTACT_POINT_CREATED  
---  
Occurs when a contact method for a patient is added.  
Target object | Context object  
    "id": contact_point_id
    "type": [PatientContactPoint](/sdk/data-patient/#patientcontactpoint)
| 
    "patient":
        "id": pt_id  
PATIENT_CONTACT_POINT_UPDATED  
---  
Occurs when a contact method for a patient is updated.  
Target object | Context object  
    "id": contact_point_id
    "type": [PatientContactPoint](/sdk/data-patient/#patientcontactpoint)
| 
    "patient":
        "id": pt_id  
PATIENT_CONTACT_POINT_DELETED  
---  
Occurs when a contact method for a patient is removed.  
Target object | Context object  
    "id": contact_point_id
    "type": [PatientContactPoint](/sdk/data-patient/#patientcontactpoint)
| 
    "patient":
        "id": pt_id  
PATIENT_EXTERNAL_IDENTIFIER_CREATED  
---  
Occurs when an external identifier is created for a patient.  
Target object | Context object  
    "id": patientexternalidentifier_id
    "type": [PatientExternalIdentifier](/sdk/data-patient/#patientexternalidentifier)
| 
    "patient":
        "id": pt_id  
PATIENT_EXTERNAL_IDENTIFIER_UPDATED  
---  
Occurs when an external identifier for a patient is updated.  
Target object | Context object  
    "id": patientexternalidentifier_id
    "type": [PatientExternalIdentifier](/sdk/data-patient/#patientexternalidentifier)
| 
    "patient":
        "id": pt_id  
PATIENT_EXTERNAL_IDENTIFIER_DELETED  
---  
Occurs when an external identifier for a patient is deleted.  
Target object | Context object  
    "id": patientexternalidentifier_id
    "type": [PatientExternalIdentifier](/sdk/data-patient/#patientexternalidentifier)
| 
    "patient":
        "id": pt_id  
####  Patient Facility Address 
PATIENT_FACILITY_ADDRESS_CREATED  
---  
Occurs when a patient facility address is created.  
Target object | Context object  
    "id": patientfacilityaddress_id
    "type": [PatientFacilityAddress](/sdk/data-patient/#patientfacilityaddress)
| 
    "patient":
        "id": pt_id  
PATIENT_FACILITY_ADDRESS_UPDATED  
---  
Occurs when a patient facility address is updated.  
Target object | Context object  
    "id": patientfacilityaddress_id
    "type": [PatientFacilityAddress](/sdk/data-patient/#patientfacilityaddress)
| 
    "patient":
        "id": pt_id  
PATIENT_FACILITY_ADDRESS_DELETED  
---  
Occurs when a patient facility address is deleted.  
Target object | Context object  
    "id": patientfacilityaddress_id
    "type": [PatientFacilityAddress](/sdk/data-patient/#patientfacilityaddress)
| 
    "patient":
        "id": pt_id  
####  Patient Metadata 
PATIENT_METADATA_CREATED  
---  
Occurs when a patient's metadata is created.  
Target object | Context object  
    "id": patientmetadata_id
    "type": [PatientMetadata](/sdk/data-patient/#patientmetadata)
| 
    "patient":
        "id": pt_id  
PATIENT_METADATA_UPDATED  
---  
Occurs when a patient's metadata is updated.  
Target object | Context object  
    "id": patientmetadata_id
    "type": [PatientMetadata](/sdk/data-patient/#patientmetadata)
| 
    "patient":
        "id": pt_id  
####  Allergy Intolerances 
ALLERGY_INTOLERANCE_CREATED  
---  
Occurs when an allergy is created for a patient. Additional details for the allergy may become available with subsequent ALLERGY_INTOLERANCE_UPDATED events.  
Target object | Context object  
    "id": allergy_id
    "type": [AllergyIntolerance](/sdk/data-allergy-intolerance/#allergyintolerance)
| 
    "patient":
        "id": pt_id  
ALLERGY_INTOLERANCE_UPDATED  
---  
Occurs when an allergy is updated for a patient.  
Target object | Context object  
    "id": allergy_id
    "type": [AllergyIntolerance](/sdk/data-allergy-intolerance/#allergyintolerance)
| 
    "patient":
        "id": pt_id  
####  Appointments 
APPOINTMENT_CREATED  
---  
Occurs when an appointment is first created/booked.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "patient":
        "id": pt_id  
APPOINTMENT_UPDATED  
---  
Occurs when details of an appointment are updated.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "patient":
        "id": pt_id  
APPOINTMENT_CHECKED_IN  
---  
Occurs when a patient has arrived and been checked in for their appointment.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "patient":
        "id": pt_id  
APPOINTMENT_RESTORED  
---  
Occurs when a cancelled appointment is restored to a non-cancelled status.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "patient":
        "id": pt_id  
APPOINTMENT_CANCELED  
---  
Occurs when an appointment is cancelled.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "patient":
        "id": pt_id  
APPOINTMENT_NO_SHOWED  
---  
Occurs when an appointment is marked as a no-show.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "patient":
        "id": pt_id  
APPOINTMENT_LABEL_ADDED  
---  
Occurs when one or more labels are added to an appointment.  
Target object | Context object  
    "id": appointment_id
    "type": None
| 
    "patient":
        "id": pt_id
    "label": label_name  
APPOINTMENT_LABEL_REMOVED  
---  
Occurs when one or more labels are removed from an appointment.  
Target object | Context object  
    "id": appointment_id
    "type": None
| 
    "patient":
        "id": pt_id
    "label": label_name  
APPOINTMENT__SLOTS__POST_SEARCH  
---  
Occurs when requesting slot availability when scheduling an appointment.  
Target object | Context object  
| 
    "slots_by_provider": list[dict]
    "selected_values": dict  
APPOINTMENT__FORM__PROVIDERS__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__PROVIDERS__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "providers": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__LOCATIONS__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__LOCATIONS__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "locations": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__VISIT_TYPES__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__VISIT_TYPES__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "visit_types": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__DURATIONS__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__DURATIONS__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "durations": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__REASON_FOR_VISIT__PRE_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__REASON_FOR_VISIT__POST_SEARCH  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "reason_for_visit": list[dict]
    "selected_values": dict
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
APPOINTMENT__FORM__GET_ADDITIONAL_FIELDS  
---  
Occurs when a schedule appointment form is loaded.  
Target object | Context object  
    "id": appointment_id
    "type": [Appointment](/sdk/data-appointment/#appointment/)
| 
    "category": [NoteTypeCategories](/sdk/data-note/#notetypecategories)  
####  Appointment Metadata 
APPOINTMENT_METADATA_CREATED  
---  
Occurs when an appointment's metadata is created.  
Target object | Context object  
    "id": appointmentmetadata_id
    "type": [AppointmentMetadata](/sdk/data-appointment/#appointmentmetadata)
| 
    empty  
APPOINTMENT_METADATA_UPDATED  
---  
Occurs when an appointment's metadata is updated.  
Target object | Context object  
    "id": appointmentmetadata_id
    "type": [AppointmentMetadata](/sdk/data-appointment/#appointmentmetadata)
| 
    empty  
####  Claims 
CLAIM_CREATED  
---  
Occurs when a claim is created.  
Target object | Context object  
    "id": claim_id
    "type": [Claim](/sdk/data-claim/#claim)
| 
    "patient":
      "id": pt_id
    "note":
      "uuid": note_id  
CLAIM_UPDATED  
---  
Occurs when a claim is updated.  
Target object | Context object  
    "id": claim_id
    "type": [Claim](/sdk/data-claim/#claim)
| 
    "patient":
      "id": pt_id
    "note":
      "uuid": note_id  
####  Billing Line Items 
BILLING_LINE_ITEM_CREATED  
---  
Occurs when a billing line item is created from adding a CPT code to a note.  
Target object | Context object  
    "id": billing_line_item_id
    "type": [BillingLineItem](/sdk/data-billing-line-item/#billinglineitem)
| 
    "patient":
        "id": pt_id  
BILLING_LINE_ITEM_UPDATED  
---  
Occurs when a billing line item is modified.  
Target object | Context object  
    "id": billing_line_item_id
    "type": [BillingLineItem](/sdk/data-billing-line-item/#billinglineitem)
| 
    "patient":
        "id": pt_id  
####  Conditions 
CONDITION_ASSESSED  
---  
Occurs when a condition is assessed through the Assess Condition command.  
Target object | Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
| 
    "patient":
        "id": pt_id  
CONDITION_CREATED  
---  
Occurs when a condition is diagnosed for a patient. Additional details for the condition may become available with subsequent CONDITION_UPDATED events.  
Target object | Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
| 
    "patient":
        "id": pt_id  
CONDITION_RESOLVED  
---  
Occurs when a condition is resolved through the Resolve Condition command.  
Target object | Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
| 
    "patient":
        "id": pt_id  
CONDITION_UPDATED  
---  
Occurs when a condition is updated for a patient.  
Target object | Context object  
    "id": condition_id
    "type": [Condition](/sdk/data-condition/#condition)
| 
    "patient":
        "id": pt_id  
####  Consents 
CONSENT_CREATED  
---  
Occurs when a patient consent is created.  
Target object | Context object  
    "id": consent_id
    "type": None
| 
    "patient":
       "id": pt_id  
CONSENT_DELETED  
---  
Occurs when a patient consent is removed/deleted.  
Target object | Context object  
    "id": consent_id
    "type": None
| 
    "patient":
       "id": pt_id  
CONSENT_UPDATED  
---  
Occurs when a patient consent is updated.  
Target object | Context object  
    "id": consent_id
    "type": None
| 
    "patient":
       "id": pt_id  
####  Coverages 
COVERAGE_CREATED  
---  
Occurs when a coverage for a patient is created.  
Target object | Context object  
    "id": coverage_id
    "type": [Coverage](/sdk/data-coverage/#coverage)
| 
    "patient":
       "id": pt_id  
COVERAGE_UPDATED  
---  
Occurs when a coverage for a patient is updated.  
Target object | Context object  
    "id": coverage_id
    "type": [Coverage](/sdk/data-coverage/#coverage)
| 
    "patient":
       "id": pt_id  
####  Detected Issues 
DETECTED_ISSUE_CREATED  
---  
Occurs when a detected issue is created.  
Target object | Context object  
    "id": detected_issue_id
    "type": [DetectedIssue](/sdk/data-detected-issue/#detectedissue)
| 
    "patient":
       "id": pt_id  
DETECTED_ISSUE_UPDATED  
---  
Occurs when a detected issue is updated.  
Target object | Context object  
    "id": detected_issue_id
    "type": [DetectedIssue](/sdk/data-detected-issue/#detectedissue)
| 
    "patient":
       "id": pt_id  
DETECTED_ISSUE_EVIDENCE_CREATED  
---  
Occurs when detected issue evidence is created.  
Target object | Context object  
    "id": detected_issue_evidence_id
    "type": [DetectedIssueEvidence](/sdk/data-detected-issue/#detectedissueevidence)
| 
    empty  
DETECTED_ISSUE_EVIDENCE_UPDATED  
---  
Occurs when a detected issue evidence is updated.  
Target object | Context object  
    "id": detected_issue_evidence_id
    "type": [DetectedIssueEvidence](/sdk/data-detected-issue/#detectedissueevidence)
| 
    empty  
####  Devices 
DEVICE_CREATED  
---  
Occurs when a device is created.  
Target object | Context object  
    "id": device_id
    "type": [Device](/sdk/data-device/#device)
| 
    "patient":
       "id": pt_id  
DEVICE_UPDATED  
---  
Occurs when a device is updated.  
Target object | Context object  
    "id": device_id
    "type": [Device](/sdk/data-device/#device)
| 
    "patient":
       "id": pt_id  
####  Document References 
DOCUMENT_REFERENCE_CREATED  
---  
Occurs when a document reference is created.  
Target object | Context object  
    "id": document_reference_id
    "type": None
| 
    "patient":
       "id": pt_id  
DOCUMENT_REFERENCE_UPDATED  
---  
Occurs when a document reference is updated.  
Target object | Context object  
    "id": document_reference_id
    "type": None
| 
    "patient":
       "id": pt_id  
DOCUMENT_REFERENCE_DELETED  
---  
Occurs when a document reference is deleted.  
Target object | Context object  
    "id": document_reference_id
    "type": None
| 
    "patient":
       "id": pt_id  
####  Encounters 
ENCOUNTER_CREATED  
---  
Occurs when an encounter is created.  
Target object | Context object  
    "id": encounter_id
    "type": [Encounter](/sdk/data-encounter/#encounter)
| 
    empty  
ENCOUNTER_UPDATED  
---  
Occurs when an encounter is updated.  
Target object | Context object  
    "id": encounter_id
    "type": [Encounter](/sdk/data-encounter/#encounter)
| 
    empty  
####  Imaging Reports 
IMAGING_REPORT_CREATED  
---  
Occurs when an imaging report is entered into the data integration section of canvas.  
Target object | Context object  
    "id": report_id
    "type": [ImagingReport](/sdk/data-imaging/#imagingreport)
| 
    "patient":
       "id": pt_id  
IMAGING_REPORT_UPDATED  
---  
Occurs when an imaging report is updated.  
Target object | Context object  
    "id": report_id
    "type": [ImagingReport](/sdk/data-imaging/#imagingreport)
| 
    "patient":
       "id": pt_id  
####  Immunizations 
IMMUNIZATION_CREATED  
---  
Occurs when an immunization is created. Additional details for the immunization may become available with subsequent IMMUNIZATION_STATEMENT_UPDATED events.  
Target object | Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
| 
    "patient":
       "id": pt_id  
IMMUNIZATION_UPDATED  
---  
Occurs when an immunization is updated.  
Target object | Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
| 
    "patient":
       "id": pt_id  
IMMUNIZATION_STATEMENT_CREATED  
---  
Occurs when an immunization statement is created. Additional details for the immunization statement may become available with subsequent IMMUNIZATION_STATEMENT_UPDATED events.  
Target object | Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
| 
    "patient":
       "id": pt_id  
IMMUNIZATION_STATEMENT_UPDATED  
---  
Occurs when an immunization statement is updated.  
Target object | Context object  
    "id": immunization_id
    "type": [Immunization](/sdk/data-immunization/#immunization)
| 
    "patient":
       "id": pt_id  
####  Instructions 
INSTRUCTION_CREATED  
---  
Occurs when an instruction is created using the Instruct command. Additional details for the instruction may become available with subsequent INSTRUCTION_UPDATED events.  
Target object | Context object  
    "id": instruction_id
    "type": None
| 
    "patient":
       "id": pt_id  
INSTRUCTION_UPDATED  
---  
Occurs when an instruction is updated.  
Target object | Context object  
    "id": instruction_id
    "type": None
| 
    "patient":
       "id": pt_id  
####  Interviews 
INTERVIEW_CREATED  
---  
Occurs when an interview is created using the Questionnaire command or through the Questionnaire endpoint in the FHIR API. Additional details for the interview may become available with subsequent INTERVIEW_UPDATED events.  
Target object | Context object  
    "id": interview_id
    "type": [Interview](/sdk/data-questionnaire/#interview)
| 
    "patient":
       "id": pt_id  
INTERVIEW_UPDATED  
---  
Occurs when an interview is updated.  
Target object | Context object  
    "id": interview_id
    "type": [Interview](/sdk/data-questionnaire/#interview)
| 
    "patient":
       "id": pt_id  
####  Labs 
LAB_ORDER_CREATED  
---  
Occurs when a lab order is created via the Lab Order command. Additional details for the lab order may become available with subsequent LAB_ORDER_UPDATED events.  
Target object | Context object  
    "id": laborder_id
    "type": [LabOrder](/sdk/data-labs/#laborder)
| 
    "patient":
       "id": pt_id  
LAB_ORDER_UPDATED  
---  
Occurs when a lab order is updated.  
Target object | Context object  
    "id": laborder_id
    "type": [LabOrder](/sdk/data-labs/#laborder)
| 
    "patient":
       "id": pt_id  
LAB_REPORT_CREATED  
---  
Occurs when a lab report is created either through Data Integration, electronic ingestion or the FHIR API.  
Target object | Context object  
    "id": labreport_id
    "type": [LabReport](/sdk/data-labs/#labreport)
| 
    "patient":
       "id": pt_id  
LAB_REPORT_UPDATED  
---  
Occurs when a lab report is updated.  
Target object | Context object  
    "id": labreport_id
    "type": [LabReport](/sdk/data-labs/#labreport)
| 
    "patient":
       "id": pt_id  
####  Medications 
MEDICATION_LIST_ITEM_CREATED  
---  
Occurs when a medication is added for a patient.  
Target object | Context object  
    "id": medication_id
    "type": [Medication](/sdk/data-medication/#medication)
| 
    "patient":
       "id": pt_id  
MEDICATION_LIST_ITEM_UPDATED  
---  
Occurs when a medication is updated for a patient.  
Target object | Context object  
    "id": medication_id
    "type": [Medication](/sdk/data-medication/#medication)
| 
    "patient":
       "id": pt_id  
PRESCRIPTION_UPDATED  
---  
Occurs when a prescription is updated.  
Target object | Context object  
    "id": prescription_id
    "type": [Medication](/sdk/data-medication/#medication)
| 
    "patient":
       "id": pt_id  
PRESCRIPTION_CREATED  
---  
Occurs when a prescription is created for a patient using the Prescribe command. Additional details for the prescription become available with subsequent PRESCRIPTION_UPDATED events.  
Target object | Context object  
    "id": prescription_id
    "type": [Medication](/sdk/data-medication/#medication)
| 
    "patient":
       "id": pt_id  
####  Messaging 
MESSAGE_CREATED  
---  
Occurs when a message (patient/practitioner communication) is created.  
Target object | Context object  
    "id": message_id
    "type": [Message](/sdk/data-message/#message)
| 
    "patient":
       "id": pt_id  
MESSAGE_TRANSMISSION_CREATED  
---  
Occurs when a message transmission record is created. Message transmissions track delivery attempts and status for messages sent through various channels (SMS, email, etc.).  
Target object | Context object  
    "id": message_transmission_id
    "type": [MessageTransmission](/sdk/data-message/#messagetransmission)
| 
    empty  
MESSAGE_TRANSMISSION_UPDATED  
---  
Occurs when a message transmission record is updated (e.g., when delivery status changes).  
Target object | Context object  
    "id": message_transmission_id
    "type": [MessageTransmission](/sdk/data-message/#messagetransmission)
| 
    empty  
####  Notes 
NOTE_STATE_CHANGE_EVENT_CREATED  
---  
Occurs as a note traverses through its state machine. This event can be used when looking at any changes to the [note state](/sdk/data-note/#notestates), including locking and unlocking.  
Target object | Context object  
    "id": nsce_id
    "type": NoteStateChangeEvent
| 
    "note_id": note_id,
    "patient_id": pt_id,
    "state": [str](/sdk/data-note/#notestates)  
NOTE_STATE_CHANGE_EVENT_PRE_CREATE  
---  
Occurs **before** a note state change event is created. This event allows protocols to perform validation and block the note state change if needed. If an [`EventValidationError`](/sdk/effect-event-validation-error) effect is returned, the note state change event is aborted and the error message is surfaced to the user.  
Target object | Context object  
    "id": nsce_id
    "type": NoteStateChangeEvent
| 
    "note_id": note_id,
    "patient_id": pt_id,
    "state": [str](/sdk/data-note/#notestates)  
NOTE_STATE_CHANGE_EVENT_UPDATED  
---  
Occurs if a note state change event is updated. Locking and unlocking both trigger an update event, and there is an *additional* update event when an archived PDF copy of the note finishes generating; this is done asynchronously.  
Target object | Context object  
    "id": nsce_id
    "type": NoteStateChangeEvent
| 
    "note_id": note_id,
    "patient_id": pt_id,
    "state": [str](/sdk/data-note/#notestates)  
####  Letters 
LETTER_CREATED  
---  
Occurs when a letter is created.  
Target object | Context object  
    "id": letter_id
    "type": [Letter](/sdk/data-letter/)
| 
    "patient":
       "id": pt_id  
LETTER_UPDATED  
---  
Occurs when a letter is updated.  
Target object | Context object  
    "id": letter_id
    "type": [Letter](/sdk/data-letter/)
| 
    "patient":
       "id": pt_id  
####  Observations 
OBSERVATION_CREATED  
---  
Occurs when an observation is created.  
Target object | Context object  
    "id": observation_id
    "type": [Observation](/sdk/data-observation/#observation)
| 
    "patient":
       "id": pt_id  
OBSERVATION_UPDATED  
---  
Occurs when an observation is updated.  
Target object | Context object  
    "id": observation_id
    "type": [Observation](/sdk/data-observation/#observation)
| 
    "patient":
       "id": pt_id  
####  Protocol Overrides 
PROTOCOL_OVERRIDE_CREATED  
---  
Target object | Context object  
    "id": protocoloverride_id
    "type": [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)
| 
    "patient":
       "id": pt_id  
PROTOCOL_OVERRIDE_UPDATED  
---  
Target object | Context object  
    "id": protocoloverride_id
    "type": [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)
| 
    "patient":
       "id": pt_id  
PROTOCOL_OVERRIDE_DELETED  
---  
Target object | Context object  
    "id": protocoloverride_id
    "type": [ProtocolOverride](/sdk/data-protocol-override/#protocoloverride)
| 
    "patient":
       "id": pt_id  
####  Referral Reports 
REFERRAL_REPORT_CREATED  
---  
Occurs when a specialist consult report is created in Data Integration.  
Target object | Context object  
    "id": referralreport_id
    "type": [ReferralReport](/sdk/data-referral/#referralreport)
| 
    "patient":
       "id": pt_id  
REFERRAL_REPORT_UPDATED  
---  
Occurs when a specialist consult report is updated.  
Target object | Context object  
    "id": referralreport_id
    "type": [ReferralReport](/sdk/data-referral/#referralreport)
| 
    "patient":
       "id": pt_id  
####  Tasks 
TASK_CREATED  
---  
Occurs when a task is created.  
Target object | Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
| 
    "patient":
       "id": pt_id  
TASK_UPDATED  
---  
Occurs when a task is updated.  
Target object | Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
| 
    "patient":
       "id": pt_id  
TASK_COMMENT_CREATED  
---  
Occurs when a comment is added to a task.  
Target object | Context object  
    "id": taskcomment_id
    "type": [TaskComment](/sdk/data-task/#taskcomment)
| 
    empty  
TASK_COMMENT_UPDATED  
---  
Occurs when a comment for a task is updated.  
Target object | Context object  
    "id": taskcomment_id
    "type": [TaskComment](/sdk/data-task/#taskcomment)
| 
    empty  
TASK_COMMENT_DELETED  
---  
Occurs when a comment for a task is removed.  
Target object | Context object  
    "id": taskcomment_id
    "type": [TaskComment](/sdk/data-task/#taskcomment)
| 
    empty  
TASK_LABELS_ADJUSTED  
---  
Occurs when a task's labels are changed.  
Target object | Context object  
    "id": task_label_id
    "type": [TaskLabel](/sdk/data-task/#tasklabel)
| 
    "patient":
       "id": pt_id
    "task":
        "id": task_id
    "action": literal["add", "remove"]  
TASK_COMPLETED  
---  
Occurs when a task is set to completed.  
Target object | Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
| 
    "patient":
       "id": pt_id  
TASK_CLOSED  
---  
Occurs when a task is set to closed.  
Target object | Context object  
    "id": task_id
    "type": [Task](/sdk/data-task/#task)
| 
    "patient":
       "id": pt_id  
####  Staff 
STAFF_CREATED  
---  
Occurs when a staff is created.  
Target object | Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
| 
    empty  
STAFF_UPDATED  
---  
Occurs when a staff is updated.  
Target object | Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
| 
    empty  
STAFF_ACTIVATED  
---  
Occurs when a staff record is created with active=True, or a staff record's active field is updated from False to True.  
Target object | Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
| 
    empty  
STAFF_DEACTIVATED  
---  
Occurs when a staff record's active field is updated from True to False.  
Target object | Context object  
    "id": staff_id
    "type": [Staff](/sdk/data-staff/#staff)
| 
    empty  
####  Vital Signs 
VITAL_SIGN_CREATED  
---  
Occurs when a vitals entry is created for a patient using the vitals command. Additional details for the vitals become available with subsequent VITAL_SIGN_UPDATED events.  
Target object | Context object  
    "id": vitalsign_id
    "type": None
| 
    empty  
VITAL_SIGN_UPDATED  
---  
Occurs when a vitals entry is updated for a patient.  
Target object | Context object  
    "id": vitalsign_id
    "type": None
| 
    empty  
###  Command lifecycle events 
These events fire during the command lifecycle.
####  Generic events 
Event | Occurs when | PRE_COMMAND_ORIGINATE | Before any command is entered into a note.  
---|---  
POST_COMMAND_ORIGINATE | After any command is entered into a note.  
PRE_COMMAND_UPDATE | Before the data in any command is updated.  
POST_COMMAND_UPDATE | After the data in any command is updated.  
PRE_COMMAND_COMMIT | Before any command is committed.  
POST_COMMAND_COMMIT | After any command is committed.  
PRE_COMMAND_DELETE | Before any command is deleted.  
POST_COMMAND_DELETE | After any command is deleted.  
PRE_COMMAND_ENTER_IN_ERROR | Before any command is marked as entered in error.  
POST_COMMAND_ENTER_IN_ERROR | After any command is marked as entered in error.  
PRE_COMMAND_EXECUTE_ACTION | Before an action is executed on any command.  
POST_COMMAND_EXECUTE_ACTION | After an action is executed on any command.  
POST_COMMAND_INSERTED_INTO_NOTE | After a command is added to a note in the UI.  
AVAILABLE_ACTIONS | When a command is rendered in the UI, after any update to data, state, or other changes  
#####  Context Overview 
Each command lifecycle event provides specific context to the handler, depending on the stage of the command lifecycle.
**Base Context (All Events Except`PRE_COMMAND_ORIGINATE`)**:
    ```json
    {
      "note": { "uuid": "note-123" },
      "patient": { "id": "patient-123" },
      "fields": { "key": "value" }
    }
    ```
  - `note.uuid`: The unique identifier of the note associated with the command.
  - `patient.id`: The unique identifier of the patient associated with the note.
  - `fields`: A dictionary containing command-specific details. See examples for each command.
**`PRE_COMMAND_ORIGINATE` Context**: Since the command is not yet connected to a note, the `PRE_COMMAND_ORIGINATE` event context only includes:
    ```json
    {
      "fields": { "key": "value" }
    }
    ```
  - `fields`: Contains details specific to the command being originated.
* * *
####  Adjust Prescription Command 
ADJUST_PRESCRIPTION_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
ADJUST_PRESCRIPTION_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "change_medication_to": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ADJUST_PRESCRIPTION__INDICATIONS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__INDICATIONS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PHARMACY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PHARMACY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PRESCRIBE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
ADJUST_PRESCRIPTION__PRESCRIBE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__CHANGE_MEDICATION_TO__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
ADJUST_PRESCRIPTION__CHANGE_MEDICATION_TO__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__SUPERVISING_PROVIDER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__SUPERVISING_PROVIDER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PRESCRIBER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ADJUST_PRESCRIPTION__PRESCRIBER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Allergy Command 
ALLERGY_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
ALLERGY_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "severity": str
      "narrative": str
      "approximate_date":
        "input": str
        "date": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ALLERGY__ALLERGY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[AllergySearchResult]  
ALLERGY__ALLERGY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Assess Command 
ASSESS_COMMAND__CONDITION_SELECTED  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
ASSESS_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "background": str
      "status": str
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ASSESS__CONDITION__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
ASSESS__CONDITION__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
####  Cancel Prescription Command 
Event | Description | CANCEL_PRESCRIPTION_COMMAND__PRE_ORIGINATE |   
---|---  
CANCEL_PRESCRIPTION_COMMAND__POST_ORIGINATE |   
CANCEL_PRESCRIPTION_COMMAND__PRE_UPDATE |   
CANCEL_PRESCRIPTION_COMMAND__POST_UPDATE |   
CANCEL_PRESCRIPTION_COMMAND__PRE_COMMIT |   
CANCEL_PRESCRIPTION_COMMAND__POST_COMMIT |   
CANCEL_PRESCRIPTION_COMMAND__PRE_DELETE |   
CANCEL_PRESCRIPTION_COMMAND__POST_DELETE |   
CANCEL_PRESCRIPTION_COMMAND__PRE_ENTER_IN_ERROR |   
CANCEL_PRESCRIPTION_COMMAND__POST_ENTER_IN_ERROR |   
CANCEL_PRESCRIPTION_COMMAND__AVAILABLE_ACTIONS |   
CANCEL_PRESCRIPTION_COMMAND__POST_VALIDATION |   
CANCEL_PRESCRIPTION_COMMAND__PRE_EXECUTE_ACTION |   
CANCEL_PRESCRIPTION_COMMAND__POST_EXECUTE_ACTION |   
CANCEL_PRESCRIPTION__SELECTED_PRESCRIPTION__PRE_SEARCH |   
CANCEL_PRESCRIPTION__SELECTED_PRESCRIPTION__POST_SEARCH |   
####  Change Medication Command 
CHANGE_MEDICATION_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
CHANGE_MEDICATION_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CHANGE_MEDICATION__MEDICATION__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
CHANGE_MEDICATION__MEDICATION__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Clipboard Command 
CLIPBOARD_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
CLIPBOARD_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLIPBOARD_COMMAND__POST_INSERTED_INTO_NOTE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "text": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
#####  Clipboard Fields Context 
The Clipboard Command provides the following fields in its context:
Field | Type | Description  
---|---|---  
`text` | _string_ | The raw text content copied to the clipboard.  
Refer to the base context documentation for additional details about the full context structure.
    ```json
    {
      "note": { "uuid": "note-123" },
      "patient": { "id": "patient-123" },
      "fields": {
        "text": "Patient complains of persistent headaches for the past two weeks."
      }
    }
    ```
* * *
####  Close Goal Command 
CLOSE_GOAL_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
CLOSE_GOAL_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_id": dict
      "achievement_status": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
CLOSE_GOAL__GOAL_ID__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
CLOSE_GOAL__GOAL_ID__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Diagnose Command 
DIAGNOSE_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
DIAGNOSE_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "diagnose": dict
      "background": str
      "approximate_date_of_onset":
        "input": str
        "date": str
      "today_assessment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
DIAGNOSE__DIAGNOSE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
DIAGNOSE__DIAGNOSE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Educational Material Command 
EDUCATIONAL_MATERIAL_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
EDUCATIONAL_MATERIAL_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
EDUCATIONAL_MATERIAL__LANGUAGE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
EDUCATIONAL_MATERIAL__LANGUAGE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
EDUCATIONAL_MATERIAL__TITLE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
EDUCATIONAL_MATERIAL__TITLE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Family History Command 
FAMILY_HISTORY_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
FAMILY_HISTORY_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "family_history": dict
      "relative": dict
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FAMILY_HISTORY__FAMILY_HISTORY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FAMILY_HISTORY__FAMILY_HISTORY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FAMILY_HISTORY__RELATIVE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FAMILY_HISTORY__RELATIVE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Follow Up Command 
FOLLOW_UP_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
FOLLOW_UP_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "requested_date": dict
      "note_type": dict
      "coding": dict
      "reason_for_visit": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
FOLLOW_UP__CODING__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FOLLOW_UP__CODING__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FOLLOW_UP__NOTE_TYPE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
FOLLOW_UP__NOTE_TYPE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Goal Command 
GOAL_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
GOAL_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
GOAL_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": str
      "start_date": str
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
####  History of Present Illness Command 
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
HISTORY_OF_PRESENT_ILLNESS_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
####  Imaging Order Command 
IMAGING_ORDER_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
IMAGING_ORDER_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "image": dict
      "indications": list[dict]
      "priority": str
      "additional_details": str
      "imaging_center": dict
      "comment": str
      "ordering_provider": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_ORDER__IMAGE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__IMAGE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__IMAGING_CENTER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__IMAGING_CENTER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__INDICATIONS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__INDICATIONS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__ORDERING_PROVIDER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_ORDER__ORDERING_PROVIDER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Imaging Review Command 
IMAGING_REVIEW_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMAGING_REVIEW__REPORT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_REVIEW__REPORT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_REVIEW__COMMUNICATION_METHOD__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMAGING_REVIEW__COMMUNICATION_METHOD__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Immunization Statement Command 
IMMUNIZATION_STATEMENT_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
IMMUNIZATION_STATEMENT_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "statement": dict
      "date":
        "date": str
        "input": str
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZATION_STATEMENT__STATEMENT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZATION_STATEMENT__STATEMENT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Immunize Command 
IMMUNIZE_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
IMMUNIZE_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "lot_number": dict
      "manufacturer": str
      "exp_date_original": str
      "sig_original": str
      "consent_given": bool
      "given_by": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
IMMUNIZE__CODING__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__CODING__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__GIVEN_BY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__GIVEN_BY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__LOT_NUMBER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
IMMUNIZE__LOT_NUMBER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Instruct Command 
INSTRUCT_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
INSTRUCT_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "instruct": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
INSTRUCT__INSTRUCT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
INSTRUCT__INSTRUCT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Lab Order Command 
LAB_ORDER_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
LAB_ORDER_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "lab_partner": dict
      "tests": list[dict]
      "ordering_provider": dict
      "diagnosis": list[dict]
      "fasting_status": bool
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_ORDER__DIAGNOSIS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__DIAGNOSIS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__LAB_PARTNER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__LAB_PARTNER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__ORDERING_PROVIDER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__ORDERING_PROVIDER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__TESTS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_ORDER__TESTS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Lab Review Command 
LAB_REVIEW_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
LAB_REVIEW__REPORT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_REVIEW__REPORT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_REVIEW__COMMUNICATION_METHOD__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
LAB_REVIEW__COMMUNICATION_METHOD__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Medical History Command 
MEDICAL_HISTORY_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
MEDICAL_HISTORY_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_medical_history": dict
      "approximate_start_date":
        "date": str
        "input": str
      "approximate_end_date":
        "date": str
        "input": str
      "show_on_condition_list": bool
      "comments": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICAL_HISTORY__APPROXIMATE_END_DATE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__APPROXIMATE_END_DATE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__APPROXIMATE_START_DATE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__APPROXIMATE_START_DATE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Medication Statement Command 
MEDICATION_STATEMENT_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
MEDICATION_STATEMENT_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "sig": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
MEDICATION_STATEMENT__MEDICATION__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
MEDICATION_STATEMENT__MEDICATION__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
####  Perform Command 
PERFORM_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
PERFORM_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "perform": dict
      "notes": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PERFORM__PERFORM__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PERFORM__PERFORM__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Physical Exam Command 
PHYSICAL_EXAM_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
PHYSICAL_EXAM_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PHYSICAL_EXAM__QUESTIONNAIRE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PHYSICAL_EXAM__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Plan Command 
PLAN_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
PLAN_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PLAN_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
####  Prescribe Command 
PRESCRIBE_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
PRESCRIBE_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
PRESCRIBE__INDICATIONS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__INDICATIONS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PHARMACY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PHARMACY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
PRESCRIBE__SUPERVISING_PROVIDER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__SUPERVISING_PROVIDER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
PRESCRIBE__PRESCRIBER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Questionnaire Command 
QUESTIONNAIRE_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
QUESTIONNAIRE_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
      "result": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
QUESTIONNAIRE__QUESTIONNAIRE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
QUESTIONNAIRE__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Reason for Visit Command 
REASON_FOR_VISIT_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
REASON_FOR_VISIT_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__POST_INSERTED_INTO_NOTE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "coding": dict
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REASON_FOR_VISIT__CODING__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REASON_FOR_VISIT__CODING__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Refer Command 
REFER_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
REFER_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "refer_to": dict
      "indications": list[dict]
      "clinical_question": str
      "priority": str
      "notes_to_specialist": str
      "include_visit_note": bool
      "internal_comment": str
      "documents_to_include": dict
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFER_COMMAND__REFER_TO__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__REFER_TO__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__INDICATIONS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__INDICATIONS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__DOCUMENTS_TO_INCLUDE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__DOCUMENTS_TO_INCLUDE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__LINKED_ITEMS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFER_COMMAND__LINKED_ITEMS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Referral Review Command 
REFERRAL_REVIEW_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFERRAL_REVIEW__REPORT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFERRAL_REVIEW__REPORT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFERRAL_REVIEW__COMMUNICATION_METHOD__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFERRAL_REVIEW__COMMUNICATION_METHOD__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Refill Prescription Command 
REFILL_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
REFILL_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "prescribe": dict
      "indications": list[dict]
      "sig": str
      "days_supply": int
      "quantity_to_dispense": int
      "type_to_dispense": dict
      "refills": int
      "substitutions": str
      "pharmacy": dict
      "prescriber": dict
      "note_to_pharmacist": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REFILL__INDICATIONS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__INDICATIONS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PHARMACY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PHARMACY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PRESCRIBE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
REFILL__PRESCRIBE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__SUPERVISING_PROVIDER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__SUPERVISING_PROVIDER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PRESCRIBER__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REFILL__PRESCRIBER__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Remove Allergy Command 
REMOVE_ALLERGY_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
REMOVE_ALLERGY_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "allergy": dict
      "narrative": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
REMOVE_ALLERGY__ALLERGY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
REMOVE_ALLERGY__ALLERGY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Resolve Condition Command 
RESOLVE_CONDITION_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
RESOLVE_CONDITION_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "condition": dict
      "show_in_condition_list": bool
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
RESOLVE_CONDITION__CONDITION__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
RESOLVE_CONDITION__CONDITION__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[ConditionSearchResult]  
####  Review of Systems Command 
ROS_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
ROS_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
ROS__QUESTIONNAIRE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
ROS__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Snooze Protocol Command 
Event | Description | SNOOZE_PROTOCOL_COMMAND__PRE_ORIGINATE |   
---|---  
SNOOZE_PROTOCOL_COMMAND__POST_ORIGINATE |   
SNOOZE_PROTOCOL_COMMAND__PRE_UPDATE |   
SNOOZE_PROTOCOL_COMMAND__POST_UPDATE |   
SNOOZE_PROTOCOL_COMMAND__PRE_COMMIT |   
SNOOZE_PROTOCOL_COMMAND__POST_COMMIT |   
SNOOZE_PROTOCOL_COMMAND__PRE_DELETE |   
SNOOZE_PROTOCOL_COMMAND__POST_DELETE |   
SNOOZE_PROTOCOL_COMMAND__PRE_ENTER_IN_ERROR |   
SNOOZE_PROTOCOL_COMMAND__POST_ENTER_IN_ERROR |   
SNOOZE_PROTOCOL_COMMAND__AVAILABLE_ACTIONS |   
SNOOZE_PROTOCOL_COMMAND__POST_VALIDATION |   
SNOOZE_PROTOCOL_COMMAND__PRE_EXECUTE_ACTION |   
SNOOZE_PROTOCOL_COMMAND__POST_EXECUTE_ACTION |   
SNOOZE_PROTOCOL__PROTOCOL__PRE_SEARCH |   
SNOOZE_PROTOCOL__PROTOCOL__POST_SEARCH |   
####  Stop Medication Command 
STOP_MEDICATION_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
STOP_MEDICATION_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "medication": dict
      "rationale": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STOP_MEDICATION__MEDICATION__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[MedicationSearchResult]  
STOP_MEDICATION__MEDICATION__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Structured Assessment Command 
STRUCTURED_ASSESSMENT_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
STRUCTURED_ASSESSMENT_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "questionnaire": dict
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
STRUCTURED_ASSESSMENT__QUESTIONNAIRE__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
STRUCTURED_ASSESSMENT__QUESTIONNAIRE__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Surgical History Command 
SURGICAL_HISTORY_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
SURGICAL_HISTORY_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "past_surgical_history": dict
      "approximate_date":
        "input": str
        "date": str
      "comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
SURGICAL_HISTORY__PAST_SURGICAL_HISTORY__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
SURGICAL_HISTORY__PAST_SURGICAL_HISTORY__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Task Command 
TASK_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
TASK_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "title": str
      "assign_to": dict
      "due_date": str
      "comment": str
      "labels": list[dict]
      "linked_items": list[dict]
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
TASK__ASSIGN_TO__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
TASK__ASSIGN_TO__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
TASK__LABELS__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
TASK__LABELS__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Update Diagnosis Command 
Event | Description | UPDATE_DIAGNOSIS_COMMAND__PRE_ORIGINATE |   
---|---  
UPDATE_DIAGNOSIS_COMMAND__POST_ORIGINATE |   
UPDATE_DIAGNOSIS_COMMAND__PRE_UPDATE |   
UPDATE_DIAGNOSIS_COMMAND__POST_UPDATE |   
UPDATE_DIAGNOSIS_COMMAND__PRE_COMMIT |   
UPDATE_DIAGNOSIS_COMMAND__POST_COMMIT |   
UPDATE_DIAGNOSIS_COMMAND__PRE_DELETE |   
UPDATE_DIAGNOSIS_COMMAND__POST_DELETE |   
UPDATE_DIAGNOSIS_COMMAND__PRE_ENTER_IN_ERROR |   
UPDATE_DIAGNOSIS_COMMAND__POST_ENTER_IN_ERROR |   
UPDATE_DIAGNOSIS_COMMAND__AVAILABLE_ACTIONS |   
UPDATE_DIAGNOSIS_COMMAND__POST_VALIDATION |   
UPDATE_DIAGNOSIS_COMMAND__PRE_EXECUTE_ACTION |   
UPDATE_DIAGNOSIS_COMMAND__POST_EXECUTE_ACTION |   
UPDATE_DIAGNOSIS__CONDITION__PRE_SEARCH |   
UPDATE_DIAGNOSIS__CONDITION__POST_SEARCH |   
UPDATE_DIAGNOSIS__NEW_CONDITION__PRE_SEARCH |   
UPDATE_DIAGNOSIS__NEW_CONDITION__POST_SEARCH |   
####  Update Goal Command 
UPDATE_GOAL_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
UPDATE_GOAL_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "goal_statement": dict
      "due_date": str
      "achievement_status": str
      "priority": str
      "progress": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UPDATE_GOAL__GOAL_STATEMENT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
UPDATE_GOAL__GOAL_STATEMENT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Uncategorized Document Review Command 
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "report": str
      "message_to_patient": str
      "communication_method": str
      "internal_comment": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__REPORT__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__REPORT__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__COMMUNICATION_METHOD__PRE_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
UNCATEGORIZED_DOCUMENT_REVIEW_COMMAND__COMMUNICATION_METHOD__POST_SEARCH  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "search_term": str
    "user": {
      "staff": staff_key
    }
    "results": list[dict]  
####  Vitals Command 
VITALS_COMMAND__POST_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__AVAILABLE_ACTIONS  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "actions":
      "name": string
    "user":
      "staff": staff_id
VITALS_COMMAND__POST_VALIDATION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__POST_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_COMMIT  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_DELETE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_ENTER_IN_ERROR  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_EXECUTE_ACTION  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_ORIGINATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
VITALS_COMMAND__PRE_UPDATE  
---  
Target object | Context object  
    "id": command_uuid
    "type": [Command](/sdk/data-command/)
| 
    "fields":
      "height": str
      "weight_lbs": str
      "weight_oz": str
      "waist_circumference": str
      "body_temperature": str
      "body_temperature_site": str
      "blood_pressure_systole": int
      "blood_pressure_diastole": str
      "blood_pressure_position_and_site": str
      "pulse": str
      "pulse_rhythm": str
      "respiration_rate": int
      "oxygen saturation": str
      "note": str
    "note":
      "uuid": note_id
    "patient":
      "id": pt_id  
###  Patient Portal lifecycle events 
The following events are emitted during the lifecycle of a patient portal session.
PATIENT_PORTAL__APPOINTMENT_CANCELED  
---  
Occurs after an appointment is canceled  
Target | Target type | Context object  
    appt_id
| 
    [Appointment](/sdk/data-appointment/)
| 
    None  
PATIENT_PORTAL__APPOINTMENT_RESCHEDULED  
---  
Occurs after an appointment is rescheduled  
Target | Target type | Context object  
    appt_id
| 
    [Appointment](/sdk/data-appointment/)
| 
    None  
PATIENT_PORTAL__APPOINTMENT_CAN_BE_CANCELED  
---  
Occurs when checking if an appointment can be canceled  
Target | Target type | Context object  
    appt_id
| 
    [Appointment](/sdk/data-appointment/)
| 
    None  
PATIENT_PORTAL__APPOINTMENT_CAN_BE_RESCHEDULED  
---  
Occurs when checking if an appointment can be rescheduled  
Target | Target type | Context object  
    appt_id
| 
    [Appointment](/sdk/data-appointment/)
| 
    None  
PATIENT_PORTAL__APPOINTMENTS__SLOTS__POST_SEARCH  
---  
Occurs after the appointment slots search has been done, allowing the values to be modified  
Target | Target type | Context object  
    None
| 
    None
| 
    "slots_by_provider": dict  
PATIENT_PORTAL__APPOINTMENTS__FORM_APPOINTMENT_TYPES__PRE_SEARCH  
---  
Occurs before appointment types are resolved, allowing the internal values to be bypassed  
Target | Target type | Context object  
    None
| 
    None
| 
    None  
PATIENT_PORTAL__APPOINTMENTS__FORM_APPOINTMENT_TYPES__POST_SEARCH  
---  
Occurs after appointment types are resolved, allowing the internal values to be modified  
Target | Target type | Context object  
    None
| 
    None
| 
    "appointment_types": list[dict]  
PATIENT_PORTAL__APPOINTMENTS__FORM_LOCATIONS__PRE_SEARCH  
---  
Occurs before appointment locations are resolved, allowing the internal values to be bypassed  
Target | Target type | Context object  
    None
| 
    None
| 
    None  
PATIENT_PORTAL__APPOINTMENTS__FORM_LOCATIONS__POST_SEARCH  
---  
Occurs after appointment locations are resolved, allowing the internal values to be modified  
Target | Target type | Context object  
    None
| 
    None
| 
    "locations": list[dict]  
PATIENT_PORTAL__APPOINTMENTS__FORM_PROVIDERS__PRE_SEARCH  
---  
Occurs before appointment providers are resolved, allowing the internal values to be bypassed  
Target | Target type | Context object  
    None
| 
    None
| 
    None  
PATIENT_PORTAL__APPOINTMENTS__FORM_PROVIDERS__POST_SEARCH  
---  
Occurs after appointment providers are resolved, allowing the internal values to be modified  
Target | Target type | Context object  
    None
| 
    None
| 
    "providers": list[dict]  
###  Action Buttons Events 
For more information on handling these events, see [Action Buttons](/sdk/handlers-action-buttons).
SHOW_NOTE_HEADER_BUTTON  
---  
Occurs when patient notes are being loaded  
Target | Context object  
    patient_id
| 
      "note_id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_NOTE_FOOTER_BUTTON  
---  
Occurs when patient notes are being loaded  
Target | Context object  
    patient_id
| 
      "note_id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_NOTE_BODY_BUTTON  
---  
Occurs when patient notes are being loaded  
Target | Context object  
    patient_id
| 
      "note_id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_SOCIAL_DETERMINANTS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for social determinants section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_GOALS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for goals section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_CONDITIONS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for conditions section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_MEDICATIONS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for medications section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_ALLERGIES_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for allergies section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_CARE_TEAMS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for care teams section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_VITALS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for vitals section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_IMMUNIZATIONS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for immunizations section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_SURGICAL_HISTORY_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for surgical history section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_FAMILY_HISTORY_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for family history section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
SHOW_CHART_SUMMARY_CODING_GAPS_SECTION_BUTTON  
---  
Occurs when patient chart summary is being loaded, specifically for coding gaps section  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
ACTION_BUTTON_CLICKED  
---  
Occurs when an action button is clicked  
Target | Context object  
    patient_id
| 
      "key": action_button_key
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
###  Application Events 
For more information on these events, see [Applications](/sdk/handlers-applications).
APPLICATION__ON_OPEN  
---  
Occurs when a user clicks on an application icon to open it  
Target | Context object  
    application_id
| 
      "patient":
        "id": str
      "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
###  Patient Portal Events 
PATIENT_PORTAL__GET_FORMS  
---  
Occurs on every page load of the Patient Portal; It only accepts the `PATIENT_PORTAL__FORM_RESULT` effect as a return value  
Target | Target type | Context object  
    patient_id
| 
    [Patient](/sdk/data-patient/)
| 
    "requested_from": str["appointment" |
                          "labs" |
                          "login" |
                          "messaging" |
                          "my-health" |
                          "payment" |
                          "search-appointment"]  
###  Patient Chart Configuration 
PATIENT_CHART__CONDITIONS  
---  
Occurs when the conditions are loaded on the patient chart.  
Target object | Context object  
    "id": patient_id
    "type": [Patient](/sdk/patient/)
| 
    "conditions":
        "id": condition id
        "codings":
          "code": str
          "system": str
          "display": str  
PATIENT_CHART__MEDICATIONS  
---  
Occurs when the medications are loaded on the patient chart.  
Target object | Context object  
    "id": patient_id
    "type": [Patient](/sdk/patient/)
| 
    "medications":
        "id": medication id
        "codings":
          "code": str
          "system": str
          "display": str  
###  Other Events 
Event | Occurs when | UNKNOWN | Default event type unlikely to ever be emitted.  
---|---  
CRON | This event fires regularly and can be used for scheduled tasks. See [CronTask](/sdk/handlers-crontask/).  
CLAIM__CONDITIONS | The conditions are loaded within the claim summary.  
PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION | A patient chart's summary section is loading.  
PANEL_SECTIONS_CONFIGURATION | The panel section is loading.  
PLUGIN_CREATED | A plugin is uploaded for the first time. See [ProtocolCards](/sdk/effect-protocol-cards/) and [BannerAlerts](/sdk/effect-banner-alerts/) for examples of how to use this event.  
PLUGIN_UPDATED | A plugin is enabled or when the plugin code has changed. See [ProtocolCards](/sdk/effect-protocol-cards/) and [BannerAlerts](/sdk/effect-banner-alerts/) for examples of how to use this event.  
PATIENT_PROFILE__ADD_PHARMACY__POST_SEARCH_RESULTS | Adding a pharmacy for a patient in their profile.  
PATIENT_PORTAL__WIDGET_CONFIGURATION | Patient Portal landing page is loading. See [Tailoring Portal Landing Page](/guides/custom-landing-page/) for examples of how to use this event.  
PATIENT_METADATA__GET_ADDITIONAL_FIELDS | Patient Profile is loading. See [How to add patient profile additional fields](/guides/profile-additional-fields/) for examples of how to use this event.   
Context object: 
    "patient":
        "id": str
    "user":
        "id": str
        "type": [Staff](/sdk/data-staff/) | [Patient](/sdk/data-patient/)  
GET_HOMEPAGE_CONFIGURATION | Homepage is loading. See [Set default homepage](/guides/set-default-homepage/) for examples of how to use this event.  
###  Search Result Data Structures 
Many event payloads include search results. This section documents the common structures within them.
####  MedicationSearchResult 
Medication search events (such as `MEDICATION_STATEMENT__MEDICATION__POST_SEARCH`, `PRESCRIBE__PRESCRIBE__POST_SEARCH`, etc.) return results that follow this structure:
    ```json
    {
      "text": "acetaminophen 500 mg tablet",
      "disabled": false,
      "description": null,
      "annotations": null,
      "extra": {
        "coding": [
          {
            "code": 206813,
            "display": "acetaminophen 500 mg tablet",
            "system": "http://www.fdbhealth.com/"
          },
          {
            "code": "198440",
            "display": "acetaminophen 500 mg tablet",
            "system": "http://www.nlm.nih.gov/research/umls/rxnorm"
          }
        ],
        "clinical_quantities": [
          {
            "erx_quantity": "1.0000000",
            "representative_ndc": "57896021910",
            "clinical_quantity_description": "tablet",
            "erx_ncpdp_script_quantity_qualifier_code": "C48542",
            "erx_ncpdp_script_quantity_qualifier_description": "Tablet"
          }
        ]
      },
      "value": 206813
    }
    ```
For detailed information about medication data structures, see [Medication](/sdk/data-medication/).
For examples of working with medication search results, see the [Customize Search Results](/guides/customize-search-results/) guide.
####  ConditionSearchResult 
Condition/diagnosis search events (such as `DIAGNOSE__DIAGNOSE__POST_SEARCH`, `MEDICAL_HISTORY__PAST_MEDICAL_HISTORY__POST_SEARCH`, etc.) return results that follow this structure:
    ```json
    {
      "text": "Broken internal left hip prosthesis, subsequent encounter",
      "disabled": false,
      "description": null,
      "annotations": ["T84.011D"],
      "extra": {
        "coding": [
          {
            "code": "T84011D",
            "display": "Broken internal left hip prosthesis, subsequent encounter",
            "system": "ICD-10"
          },
          {
            "code": 404684003,
            "display": "Broken internal left hip prosthesis, subsequent encounter",
            "system": "http://snomed.info/sct"
          }
        ]
      },
      "value": "T84011D"
    }
    ```
For detailed information about condition data structures, see [Condition](/sdk/data-condition/).
####  AllergySearchResult 
Allergy search events (such as `ALLERGY__ALLERGY__POST_SEARCH`, `REMOVE_ALLERGY__ALLERGY__POST_SEARCH`, etc.) return results that follow this structure:
    ```json
    {
      "text": "Penicillins (allergy group)",
      "disabled": false,
      "description": null,
      "annotations": null,
      "extra": {
        "coding": [
          {
            "code": 476,
            "display": "Penicillins",
            "system": "http://www.fdbhealth.com/"
          }
        ],
        "category_id": 1,
        "category": "allergy group"
      },
      "value": 476
    }
    ```
For detailed information about allergy data structures, see [Allergy Intolerance](/sdk/data-allergy-intolerance/).
----- END PAGE https://docs.canvasmedical.com/sdk/events/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-abnormal_lab_task_notification/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/abnormal_lab_task_notification) for this plugin on GitHub. 
This Canvas EMR plugin automatically creates task notifications whenever lab results with abnormal values are received, ensuring critical lab findings are flagged for prompt clinical review.
##  SDK Features 
  - Responds to `LAB_REPORT_CREATED` [event](/sdk/events/#labs)
  - Loads and parses the [Lab Report data model](/sdk/data-labs/#labreport) to identify [lab values](/sdk/data-labs/#labvalue) flagged as abnormal
  - Returns a [task effect](/sdk/effect-tasks/#adding-a-task)
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.1.0",
        "name": "abnormal_lab_task_notification",
        "description": "A plugin that creates task notifications for abnormal lab values",
        "components": {
            "protocols": [
                {
                    "class": "abnormal_lab_task_notification.protocols.abnormal_lab_protocol:AbnormalLabProtocol",
                    "description": "Monitors lab reports and creates tasks for abnormal values",
                    "data_access": {
                        "event": "LAB_REPORT_CREATED",
                        "read": [
                            "lab_reports",
                            "lab_values"
                        ],
                        "write": [
                            "tasks"
                        ]
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "tags": ["lab", "notifications", "tasks"],
        "secrets": [],
        "license": "NONE",
        "readme": "This plugin monitors incoming lab reports and creates task notifications for any abnormal lab values, ensuring they are flagged for prompt review."
    }
    ```
##  protocols/ 
###  abnormal_lab_protocol.py 
**Purpose and Functionality**
This file defines a protocol called AbnormalLabProtocol for use with the Canvas Medical SDK. Its primary function is to monitor for the creation of new laboratory reports (`LAB_REPORT_CREATED` events). When such an event occurs, the protocol inspects the report to determine if it contains any abnormal lab values. If abnormal results are found, it automatically creates a task for prompt clinical review.
**Event Handling**
  - The protocol listens for the LAB_REPORT_CREATED event.
  - When triggered, it examines the relevant [lab report(/sdk/data-labs/#labreport)] for any values marked as abnormal.
**Core Logic**
  - It fetches the full LabReport instance specified by the event.
  - It filters out any reports that are for test purposes, junked, or do not belong to a patient.
  - It iterates through all values within the lab report.
  - For each value, it checks if there is a non-empty abnormal_flag.
  - If one or more abnormal values are found, it creates a task for the associated patient.
**Effects Produced**
  - Adds a new open task titled "Review Abnormal Lab Values ({count} abnormal)", labeled as "abnormal-lab" and "urgent-review" to the patient's workflow.
  - Logs the creation of the task and any errors encountered in the process.
**Error Handling**
  - If anything goes wrong (e.g., the report is missing, or there's a processing error), it logs the error and does not produce any task.
**Summary**
This protocol automates the process of flagging abnormal laboratory results for clinical review within Canvas Medical, enhancing the safety net for critical lab findings by ensuring they are not overlooked.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.task import AddTask, TaskStatus
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.v1.data.lab import LabReport
    from logger import log
    class AbnormalLabProtocol(BaseProtocol):
        """
        A protocol that monitors lab reports and creates task notifications
        for abnormal lab values to ensure prompt review.
        Triggers on: LAB_REPORT_CREATED events
        Effects: Creates tasks for abnormal lab values
        """
        RESPONDS_TO = EventType.Name(EventType.LAB_REPORT_CREATED)
        def compute(self) -> list[Effect]:
            """
            This method gets called when a LAB_REPORT_CREATED event is fired.
            It checks for abnormal lab values and creates tasks for them.
            """
            # Get the lab report ID from the event target
            lab_report_id = self.event.target.id
            try:
                # Get the lab report instance with filters applied
                lab_report = LabReport.objects.filter(
                    id=lab_report_id,
                    for_test_only=False,
                    junked=False,
                    patient__isnull=False
                ).first()
                if not lab_report:
                    return []
                patient_id = lab_report.patient.id
                # Check all lab values for abnormal flags
                abnormal_values = []
                for lab_value in lab_report.values.all():
                    # Check if the lab value has an abnormal flag (handle None case)
                    abnormal_flag = getattr(lab_value, 'abnormal_flag', None) or ""
                    if abnormal_flag.strip():
                        abnormal_values.append(lab_value)
                if not abnormal_values:
                    return []
                # Create a task for the abnormal lab values
                abnormal_count = len(abnormal_values)
                task_title = f"Review Abnormal Lab Values ({abnormal_count} abnormal)"
                # Create the task
                task = AddTask(
                    patient_id=patient_id,
                    title=task_title,
                    status=TaskStatus.OPEN,
                    labels=["abnormal-lab", "urgent-review"]
                )
                applied_task = task.apply()
                log.info(f"Created task for {abnormal_count} abnormal lab value(s) in report {lab_report_id}")
                return [applied_task]
            except Exception as e:
                log.error(f"Error processing lab report {lab_report_id}: {str(e)}")
                return []
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-abnormal_lab_task_notification/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-ai_note_titles/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/ai_note_titles) for this plugin on GitHub. 
##  Description 
Plugin that renames Notes when locked using OpenAI and the contents of the Note.
##  Configuration 
This example plugin defines the following "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "OPENAI_API_KEY"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  OPENAI_API_KEY 
[OpenAI API Key](https://platform.openai.com/docs/api-reference/authentication)
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "ai_note_titles",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "components": {
            "protocols": [
                {
                    "class": "ai_note_titles.handlers.rename_note:Handler",
                    "description": "Renames Notes when locked using OpenAI and the contents of the Note"
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": ["OPENAI_API_KEY"],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  handlers/ 
###  rename_note.py 
**Purpose**
This code defines a handler in a Canvas SDK plugin that automatically renames clinical notes when they are locked, using the OpenAI API to generate new titles based on the note content.
**Class Overview**
  - The main class, `Handler`, extends `BaseHandler`.
  - The handler listens for `NOTE_STATE_CHANGE_EVENT_CREATED` events—specifically, when a note's state changes (e.g., gets locked).
**Main Workflow**
  - When a relevant event fires, the `compute` method is triggered.
  - It extracts the note ID from the context.
  - If the note event corresponds to a locking action, it proceeds.
  - It collects the note content and sends it (along with instructions) to OpenAI's API, requesting a concise, descriptive title.
  - If a valid title is returned, it generates an `update` effect to rename the note in Canvas.
**OpenAI Integration**
  - The `get_note_title` function prepares headers and a request payload from the note's structured content and specific instructions.
  - It POSTS this data to OpenAI's API (note: the endpoint used, `/v1/responses`, is likely a placeholder).
  - It parses the response to extract the generated title.
**Supporting Functions**
  - `get_model`: Returns the OpenAI model name (`gpt-4.1`).
  - `get_input`: Serializes note commands (actions or entries inside the note) to JSON for use as the prompt to the language model.
  - `get_instructions`: Supplies explicit instructions and examples to OpenAI, guiding it to create short, clinically meaningful titles.
  - `is_locked_note_event`: Checks if the event is specifically a note being locked (not other state transitions).
**Error Handling**
  - Logs issues if the note ID is missing, the OpenAI call fails, or expected fields are missing in the response.
**Effect on Canvas**
  - If a new title is obtained, issues a `NoteEffect.update()` call to rename the note instance.
**Summary**
This file defines a Canvas plugin handler that listens for notes being locked, then uses OpenAI to generate and set a concise, relevant note title based on its clinical contents.
    ```python
    import json
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.note import Note as NoteEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.utils.http import Http
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.v1.data.note import CurrentNoteStateEvent, NoteStates
    from logger import log
    class Handler(BaseHandler):
        """Renames Notes when locked using OpenAI and the contents of the Note."""
        RESPONDS_TO: list[str] = [
            EventType.Name(EventType.NOTE_STATE_CHANGE_EVENT_CREATED),
        ]
        def compute(self) -> list[Effect]:
            """This method gets called when an event of the type RESPONDS_TO is fired."""
            note_id: str | None = self.context.get("note_id")
            if not note_id:
                log.error("No note ID found in context")
                return []
            if not self.is_locked_note_event():
                return []
            new_title = self.get_note_title(note_id)
            if not new_title:
                return []
            return [NoteEffect(instance_id=note_id, title=new_title).update()]
        def get_note_title(self, note_id: str) -> str | None:
            """Get the new note title from the note."""
            headers = {
                "Authorization": f"Bearer {self.secrets.get('OPENAI_API_KEY')}",
                "Content-Type": "application/json",
            }
            payload = {
                "input": self.get_input(note_id),
                "instructions": self.get_instructions(),
                "model": self.get_model(),
                "temperature": 0,
            }
            response = Http().post(
                "https://api.openai.com/v1/responses", headers=headers, data=json.dumps(payload)
            )
            if not response.ok:
                log.error(
                    f"Generate note title request failed: {response.status_code} - {response.text}"
                )
                return None
            response_json = response.json()
            new_title: str | None = None
            try:
                new_title = response_json.get("output")[0].get("content")[0].get("text")
            except Exception as e:
                log.error(f"Failed to get note title from response: {response.text} {e}")
            return new_title
        def get_model(self) -> str:
            """Get the OpenAI model to use."""
            return "gpt-4.1"
        def get_input(self, note_id: str) -> str:
            """Stringified commands within note to be used as input for OpenAI."""
            commands = Command.objects.filter(
                note__id=note_id, entered_in_error__isnull=True, committer__isnull=False
            )
            return json.dumps(list(commands.values("schema_key", "data")))
        def get_instructions(self) -> str:
            """Instructions for OpenAI to use to rename the note."""
            return """
            You are a clinical documentation specialist that generates a clinical note title using 10 words or less.
            This will read by a clinician looking to get a quick overview of the note.
            Return the exact title ONLY and nothing else.
            Examples:
            Ankle edema and amlodipine intolerance, medication change discussion
            Refilled metoprolol succinate ER and rosuvastatin 10 mg tablets
            Follow up call regarding elevated heart rate to 120
            Fall with back pain, unsteady gait, declined ER and HHA
            """
        def is_locked_note_event(self) -> bool:
            """Check if the note is locked."""
            return (
                CurrentNoteStateEvent.objects.values_list("state", flat=True).get(
                    id=self.event.target.id
                )
                == NoteStates.LOCKED
            )
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-ai_note_titles/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-api_samples/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/api_samples) for this plugin on GitHub. 
Showcases the usage of the SimpleAPI handler
##  Configuration 
Once installed, see the plugin configuration page to set credentials to make authenticated requests.
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "api_samples",
        "description": "Example usages of the SimpleAPI handler",
        "components": {
            "protocols": [
                {
                    "class": "api_samples.routes.hello_world:HelloWorldAPI",
                    "description": "Returns a json message"
                },
                {
                    "class": "api_samples.routes.email_bounce:EmailBounceAPI",
                    "description": "Creates a task to confirm patient contact info"
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": ["my-api-key"],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  routes/ 
###  email_bounce.py 
The code defines an endpoint for handling bounced email events.
**Endpoint**
  - **Path:** `/crm-webhooks/email-bounce`
  - **Method:** POST
  - **Expected Body:** JSON containing `{"mrn": "valid patient MRN"}`
  - **Authorization:** Requires an API key in the `Authorization` header that matches the plugin secret `'my-api-key'`.
**Core Functionality**
  - When a POST request is received: 
    - It authenticates the request by verifying the provided API key against a stored secret.
    - It retrieves the `Patient` object from the database with the given MRN (Medical Record Number) from the request body.
    - It schedules a new open task for that patient: 
      - **Title:** `"Please confirm contact information."`
      - **Due Date:** 5 days from the current UTC date
      - **Label:** `"CRM"`
  - Returns a response indicating both the creation of the task and a confirmation JSON message.
**Intended Use**
This endpoint provides an automated workflow to prompt staff to confirm and update patient contact information in response to an email bounce event, improving contact data quality in clinical operations.
    ```python
    import arrow
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.effects.task import AddTask, TaskStatus
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    from canvas_sdk.v1.data import Patient
    #
    # POST /plugin-io/api/api_samples/crm-webhooks/email-bounce
    # Body: { "mrn": "valid patient MRN" }
    # Headers: "Authorization <your value for 'my-api-key'>"
    #
    class EmailBounceAPI(SimpleAPIRoute):
        PATH = "/crm-webhooks/email-bounce"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            return credentials.key == self.secrets["my-api-key"]
        def post(self) -> list[Response]:
            patient = Patient.objects.get(mrn=self.request.json()["mrn"])
            five_days_from_now = arrow.utcnow().shift(days=5).datetime
            task_effect = AddTask(
                patient_id=patient.id,
                title="Please confirm contact information.",
                due=five_days_from_now,
                status=TaskStatus.OPEN,
                labels=["CRM"],
            )
            return [task_effect.apply(), JSONResponse({"message": "Task Created"})]
    ```
###  hello_world.py 
This code defines a simple API endpoint which handles requests to the path `/hello-world`. When a GET request is made to this endpoint, the API responds with a JSON message that says "Hello world!".
**Authentication**
The endpoint requires an API key for authentication. The client must provide an API key (as a header called `Authorization`). The provided key is compared to a value stored in `self.secrets["my-api-key"]`. If the keys match, authentication is successful and the request is allowed; otherwise, it will be denied.
**Response**
A GET request to `/plugin-io/api/api_samples/hello-world` (when authenticated) returns a JSON response in the following format:
    ```json
    {
      "message": "Hello world!"
    }
    ```
    ```python
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    #
    # GET /plugin-io/api/api_samples/hello-world
    # Headers: "Authorization <your value for 'my-api-key'>"
    #
    class HelloWorldAPI(SimpleAPIRoute):
        PATH = "/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            return credentials.key == self.secrets["my-api-key"]
        def get(self) -> list[Response]:
            return [JSONResponse({"message": "Hello world!"})]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-api_samples/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-aws_s3/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/aws_s3) for this plugin on GitHub. 
##  Description 
Plugin that provides a SimpleAPI for managing AWS S3 objects, including listing, uploading, downloading, deleting files, and generating presigned URLs. It also includes a chart application that renders a form interface for interacting with S3 directly from the chart.
##  Configuration 
This example plugin defines the following "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "S3Key",
            "S3Secret",
            "S3Region",
            "S3Bucket"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  S3Key 
Your AWS Access Key ID.
###  S3Secret 
Your AWS Secret Access Key.
###  S3Region 
The AWS region where your S3 bucket is located (e.g., `us-east-1`).
###  S3Bucket 
The name of your S3 bucket.
##  CANVAS_MANIFEST.json 
    ```json
    {
      "sdk_version": "0.81.0",
      "plugin_version": "0.0.1",
      "name": "aws_manip",
      "description": "use AWS S3 to store, retrieve and delete documents",
      "components": {
        "protocols": [
          {
            "class": "aws_manip.handlers.aws_manip:AwsManip",
            "description": "AWS extractor based on AWS S3"
          }
        ],
        "applications": [
          {
            "class": "aws_manip.handlers.aws_form_app:AwsFormApp",
            "name": "AWS S3 Document Management",
            "description": "AWS S3 manip",
            "icon": "static/aws_manip.png",
            "scope": "patient_specific",
            "show_in_panel": false
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [
        "S3Key",
        "S3Secret",
        "S3Region",
        "S3Bucket"
      ],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
    ```
##  handlers/ 
###  aws_manip.py 
**Purpose**
This code defines a SimpleAPI handler that exposes REST endpoints for managing objects in an Amazon S3 bucket using the Canvas SDK's AWS S3 client.
**Class Overview**
  - The main class, `AwsManip`, extends `SimpleAPI`.
  - It creates an S3 client using credentials stored in plugin secrets.
**Main Workflow**
  - `GET /list_items` — Lists all objects in the configured S3 bucket.
  - `GET /get_item/<item_key>` — Retrieves an object's content by its key.
  - `GET /presigned_url/<item_key>` — Generates a presigned URL for temporary (1-hour) access to an object.
  - `POST /upload_item/<item_key>` — Uploads content to S3, handling both text and binary content types.
  - `DELETE /delete_item/<item_key>` — Deletes an object from S3 by key.
**S3 Client Integration**
  - The `_s3_client` method creates an `S3` client instance from `canvas_sdk.clients.aws.libraries`, configured with `S3Credentials` from plugin secrets.
  - Each endpoint checks `client.is_ready()` before performing operations.
    ```python
    from http import HTTPStatus
    from aws_manip.constants.secrets import Secrets
    from canvas_sdk.clients.aws.libraries import S3
    from canvas_sdk.clients.aws.structures import Credentials as S3Credentials
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, PlainTextResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPI, api
    class AwsManip(SimpleAPI):
        """Simple API handler for AWS S3 object management operations."""
        PREFIX = None
        USER_TYPE_STAFF = "Staff"
        def authenticate(self, credentials: Credentials) -> bool:
            """Authenticate API requests.
            Args:
                credentials: The credentials provided with the request.
            Returns:
                True to allow all requests (authentication bypassed).
            """
            return True
        def _s3_client(self) -> S3:
            """Create and configure an S3 client with credentials from secrets.
            Returns:
                Configured S3 client instance.
            """
            return S3(
                S3Credentials(
                    key=self.secrets[Secrets.s3_key],
                    secret=self.secrets[Secrets.s3_secret],
                    region=self.secrets[Secrets.s3_region],
                    bucket=self.secrets[Secrets.s3_bucket],
                )
            )
        @api.get("/list_items")
        def list_items(self) -> list[Response | Effect]:
            """List all objects in the S3 bucket."""
            client = self._s3_client()
            if client.is_ready():
                content = [p.key for p in client.list_s3_objects("")]
                status_code = HTTPStatus(HTTPStatus.OK)
                return [JSONResponse(content, status_code=status_code)]
            return []
        @api.get("/get_item/<item_key>")
        def get_item(self) -> list[Response | Effect]:
            """Retrieve an object's content from S3 by key."""
            item_key = self.request.path_params["item_key"]
            client = self._s3_client()
            if client.is_ready() and item_key:
                content = client.access_s3_object(item_key).content
                status_code = HTTPStatus(HTTPStatus.OK)
                return [Response(content, status_code=status_code)]
            return []
        @api.get("/presigned_url/<item_key>")
        def presigned_url(self) -> list[Response | Effect]:
            """Generate a presigned URL for temporary access to an S3 object."""
            item_key = self.request.path_params["item_key"]
            client = self._s3_client()
            if client.is_ready() and item_key:
                content = client.generate_presigned_url(item_key, 3600)
                status_code = HTTPStatus(HTTPStatus.OK)
                return [PlainTextResponse(content, status_code=status_code)]
            return []
        @api.post("/upload_item/<item_key>")
        def upload_item(self) -> list[Response | Effect]:
            """Upload content to S3 with the specified key."""
            item_key = self.request.path_params["item_key"]
            client = self._s3_client()
            content = self.request.body
            content_type = self.request.content_type
            if client.is_ready() and item_key:
                if content_type == "text/plain":
                    response = client.upload_text_to_s3(item_key, content.decode("utf-8"))
                else:
                    response = client.upload_binary_to_s3(item_key, content, content_type)
                return [Response(response.content, status_code=response.status_code)]
            return []
        @api.delete("/delete_item/<item_key>")
        def delete_item(self) -> list[Response | Effect]:
            """Delete an object from S3 by key."""
            item_key = self.request.path_params["item_key"]
            client = self._s3_client()
            if client.is_ready() and item_key:
                content = client.delete_object(item_key).content
                status_code = HTTPStatus(HTTPStatus.OK)
                return [Response(content, status_code=status_code)]
            return []
    ```
###  aws_form_app.py 
**Purpose**
This code defines an Application handler that launches a modal form in the right chart pane for interacting with the S3 management API endpoints.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    from canvas_sdk.templates import render_to_string
    class AwsFormApp(Application):
        """Application handler for launching the AWS S3 management form interface."""
        PLUGIN_API_BASE_ROUTE = "/plugin-io/api/aws_manip"
        def on_open(self) -> Effect:
            """Render and launch the AWS S3 management modal form."""
            content = render_to_string(
                "templates/aws_form.html",
                {
                    "listItemsURL": f"{self.PLUGIN_API_BASE_ROUTE}/list_items",
                    "getItemURL": f"{self.PLUGIN_API_BASE_ROUTE}/get_item",
                    "presignedUrlURL": f"{self.PLUGIN_API_BASE_ROUTE}/presigned_url",
                    "uploadItemURL": f"{self.PLUGIN_API_BASE_ROUTE}/upload_item",
                    "deleteItemURL": f"{self.PLUGIN_API_BASE_ROUTE}/delete_item",
                },
            )
            return LaunchModalEffect(
                content=content,
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-aws_s3/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-charting_api_examples/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/charting_api_examples) for this plugin on GitHub. 
This example plugin provides several examples of APIs you might define when automating charting in Canvas.
  - Notes 
    - Creating a note
    - Getting information about a note
    - Searching for notes by patient, type, and date of service
    - Adding billing line items to a note
  - Commands 
    - Creating a command
    - Creating multiple commands from a single request
    - Creating a command and committing it in a single request
##  Configuration 
All of the example endpoints in this plugin are protected with [API key authentication](https://docs.canvasmedical.com/sdk/handlers-simple-api-http/#api-key-1). Once installed, you'll need to set the `simpleapi-api-key` value on the plugin's configuration page in your EHR.
##  Endpoint Documentation 
###  Search Notes 
`GET /plugin-io/api/charting_api_examples/notes/`
This endpoint allows the retrieval of an optionally filtered set of notes. The results are paginated, and the client can exert some control over the page size. The response body will include an attribute, `next_page`, which will either contain a URL to the next page of the same filtered set or be `null`, indicating there are no more records to fetch.
####  Optional query parameters: 
#####  limit 
_int_
Determines the number of results to return per page.
  - If unspecified, the default is 10.
  - If a number less than 1 is specified, 1 will be used.
  - If a number greate than 100 is specified, 100 will be used.
#####  offset 
_int_
Number of records to skip with returning results. When used with **limit** , this enables the pagination of results.
  - If unspecified, the default is 0.
  - If a number less than 0 is specified, 0 will be used.
#####  patient_id 
_str_
Filters the notes returned to just those associated with the given patient.
#####  note_type 
_coding_
You can search by just the code value or you can search by the system and code in the format "system|code" (e.g. `http://snomed.info/sct|308335008`).
#####  datetime_of_service 
_iso8601 formatted datetime string_
Exact match for notes with the given datetime.
#####  datetime_of_service__gt 
_iso8601 formatted datetime string_
Filter to notes occurring after the given datetime.
#####  datetime_of_service__gte 
_iso8601 formatted datetime string_
Filter to notes occurring at or after the given datetime.
#####  datetime_of_service__lt 
_iso8601 formatted datetime string_
Filter to notes occurring before the given datetime.
#####  datetime_of_service__lte 
_iso8601 formatted datetime string_
Filter to notes occurring at or before the given datetime.
####  Example Request 
    ```bash
    curl --request GET \
      --url 'https://training.canvasmedical.com/plugin-io/api/charting_api_examples/notes/?limit=2&offset=4' \
      --header 'Authorization: <your-api-key-goes-here>'
    ```
####  Example Response 
    ```json
    {
      "next_page": "https://training.canvasmedical.com/plugin-io/api/charting_api_examples/notes/?limit=2&offset=6",
      "count": 2,
      "notes": [
        {
          "id": "10ff2047-6301-4ab4-81cd-b500e7df8ef7",
          "patient_id": "5350cd20de8a470aa570a852859ac87e",
          "provider_id": "5843991a8c934118ab4f424c839b340f",
          "datetime_of_service": "2025-02-21 23:31:45.627894+00:00",
          "note_type": {
            "id": "c5df4f03-58e4-442b-ad6c-0d3dadc6b726",
            "name": "Office visit",
            "coding": {
              "display": "Office Visit",
              "code": "308335008",
              "system": "http://snomed.info/sct"
            }
          }
        },
        {
          "id": "4dba128f-96cc-4dd0-814b-a064bfdcde7e",
          "patient_id": "5350cd20de8a470aa570a852859ac87e",
          "provider_id": "336159560091471cb6b0e149d9054697",
          "datetime_of_service": "2025-02-21 23:31:45.928071+00:00",
          "note_type": {
            "id": "c5df4f03-58e4-442b-ad6c-0d3dadc6b726",
            "name": "Office visit",
            "coding": {
              "display": "Office Visit",
              "code": "308335008",
              "system": "http://snomed.info/sct"
            }
          }
        }
      ]
    }
    ```
###  Read a Note 
`GET /plugin-io/api/charting_api_examples/notes/<note-id>/`
####  Example Response 
    ```json
    {
      "note": {
        "id": "1490b8db-00a9-47d9-9170-ec142460b586",
        "patient_id": "5350cd20de8a470aa570a852859ac87e",
        "provider_id": "6b33e69474234f299a56d480b03476d3",
        "datetime_of_service": "2025-10-02 23:30:00+00:00",
        "state": "NEW",
        "note_type": {
          "id": "c5df4f03-58e4-442b-ad6c-0d3dadc6b726",
          "name": "Office visit",
          "coding": {
            "display": "Office Visit",
            "code": "308335008",
            "system": "http://snomed.info/sct"
          }
        }
      }
    }
    ```
###  Create a Note 
`POST /plugin-io/api/charting_api_examples/notes/`
####  Example Request Body 
    ```json
    {
      "practice_location_id": "306b19f0-231a-4cd4-ad2d-a55c885fd9f8",
      "note_type_id": "c5df4f03-58e4-442b-ad6c-0d3dadc6b726",
      "patient_id": "5350cd20de8a470aa570a852859ac87e",
      "provider_id": "6b33e69474234f299a56d480b03476d3",
      "datetime_of_service": "2025-10-04 23:30:00",
      "title": "My cool note"
    }
    ```
###  Add Billing Line Item to a Note 
`POST /plugin-io/api/charting_api_examples/notes/<note-id>/billing_line_items/`
####  Example Request Body 
    ```json
    {
      "cpt_code": "98008"
    }
    ```
###  Add a Diagnose Command to a Note 
`POST /plugin-io/api/charting_api_examples/notes/<note-id>/diagnose/`
`icd10_code` is required, but `committed` may be true, false, or omitted entirely.
####  Example Request Body 
    ```json
    {
      "icd10_code": "E119",
      "committed": true
    }
    ```
###  Add Multiple Commands to a Note 
`POST /plugin-io/api/charting_api_examples/notes/<note-id>/prechart/`
####  Example Request Body 
    ```json
    null
    ```
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "charting_api_examples",
        "description": "A series of custom API routes that showcase SDK charting functionality",
        "components": {
            "protocols": [
                {
                    "class": "charting_api_examples.routes.notes:NoteAPI",
                    "description": "Endpoints that showcase interactions with notes."
                },
                {
                    "class": "charting_api_examples.routes.billing_line_items:BillingLineItemAPI",
                    "description": "Endpoints for interacting with billing line items on a note."
                },
                {
                    "class": "charting_api_examples.routes.commands:CommandAPI",
                    "description": "Endpoints for interacting with commands on a note."
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": ["simpleapi-api-key"],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  routes/ 
###  commands.py 
This file provides an example of how to define REST API endpoints in a Canvas-based plugin for inserting medical charting commands to clinical notes, with validation, error handling, and support for both single and batch command operations.
**Endpoints**
  1. `/notes/<id>/diagnose/` (POST): 
     - Adds a DiagnoseCommand to the specified note.
     - Expects a JSON body with at least an "icd10_code" parameter, and optionally "committed" (boolean).
     - If "committed" is true, the diagnose command is also committed immediately after being originated.
     - Handles missing attribute errors and note-not-found situations gracefully, responding with appropriate error messages and status codes.
  2. `/notes/<id>/prechart/` (POST): 
     - Initiates (originates) several commands at once for a note: ReasonForVisitCommand, PhysicalExamCommand, DiagnoseCommand, and PlanCommand.
     - Designed to quickly set up the structure for clinical pre-charting with a single request.
**Implementation Highlights**
  - The API is protected with API key authentication via `APIKeyAuthMixin`.
  - Uses utility functions (`get_note_from_path_params`, `note_not_found_response`) to locate notes and standardize error responses.
  - Returns both command effects (operations that are intended to be executed in the Canvas system) and standard JSON responses.
  - Uses status codes according to best practices, addressing Python version differences by using explicit numeric codes where needed.
**Canvas SDK Features Used**
  - Commands: `DiagnoseCommand`, `PhysicalExamCommand`, `PlanCommand`, `ReasonForVisitCommand` — each representing an action to be performed on a note.
  - Effects: Chainable "originate" (create/begin the command) and "commit" (finalize/commit the command).
    ```python
    from http import HTTPStatus
    from uuid import uuid4
    from canvas_sdk.commands import (
        DiagnoseCommand,
        PhysicalExamCommand,
        PlanCommand,
        ReasonForVisitCommand,
    )
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyAuthMixin, SimpleAPI, api
    from canvas_sdk.v1.data.note import Note
    from charting_api_examples.util import get_note_from_path_params, note_not_found_response
    class CommandAPI(APIKeyAuthMixin, SimpleAPI):
        PREFIX = "/notes"
        """
        This shows how you can create an endpoint to insert a particular type of
        command. In this example, it's a diagnose command. It can be committed or
        left uncommitted.
        POST /plugin-io/api/charting_api_examples/notes/<note-id>/diagnose/
        Headers: "Authorization <your value for 'simpleapi-api-key'>"
        Body: {
            "icd10_code": "E11.9",
            "committed": false
        }
        """
        @api.post("/<id>/diagnose/")
        def add_diagnose_command(self) -> list[Response | Effect]:
            required_attributes = {"icd10_code",}
            request_body = self.request.json()
            missing_attributes = required_attributes - request_body.keys()
            if len(missing_attributes) > 0:
                return [
                    JSONResponse(
                        {"error": f"Missing required attribute(s): {', '.join(missing_attributes)}"},
                        # Normally you should use a constant, but this status
                        # code's constant changes in 3.13 from
                        # UNPROCESSABLE_ENTITY to UNPROCESSABLE_CONTENT. Using the
                        # number directly here avoids that future breakage.
                        status_code=422,
                    )
                ]
            note = get_note_from_path_params(self.request.path_params)
            if not note:
                return note_not_found_response()
            diagnose_command = DiagnoseCommand(
                note_uuid=str(note.id),
                icd10_code=request_body["icd10_code"].upper(),
            )
            if request_body.get("committed"):
                # To chain command effects, you must know what the command's id
                # is. To accomplish that, we set the id ourselves rather than
                # allow the database to assign one.
                diagnose_command.command_uuid = str(uuid4())
                command_effects = [diagnose_command.originate(), diagnose_command.commit()]
            else:
                command_effects = [diagnose_command.originate()]
            return [
                *command_effects,
                JSONResponse({"message": "Command data accepted for creation"}, status_code=HTTPStatus.ACCEPTED)
            ]
        """
        This shows how you can originate many commands from the same request.
        POST /plugin-io/api/charting_api_examples/notes/<note-id>/prechart/
        Headers: "Authorization <your value for 'simpleapi-api-key'>"
        Body: {
        }
        """
        @api.post("/<id>/prechart/")
        def add_precharting_commands(self) -> list[Response | Effect]:
            request_body = self.request.json()
            note = get_note_from_path_params(self.request.path_params)
            if not note:
                return note_not_found_response()
            rfv = ReasonForVisitCommand(note_uuid=str(note.id))
            exam = PhysicalExamCommand(note_uuid=str(note.id))
            diagnose = DiagnoseCommand(note_uuid=str(note.id))
            plan = PlanCommand(note_uuid=str(note.id))
            return [
                rfv.originate(),
                exam.originate(),
                diagnose.originate(),
                plan.originate(),
                JSONResponse({"message": "Command data accepted for creation"}, status_code=HTTPStatus.ACCEPTED)
            ]
    ```
###  notes.py 
Defines an API endpoint for working with clinical notes. The API supports listing, creating, and retrieving notes, with filtering and pagination features. Authentication is handled through an API key.
**Endpoints**
  - **GET /notes/**
    - Returns a paginated list of notes.
    - Supports filters: 
      - `patient_id`: Filter notes for a specific patient.
      - `note_type`: Filter by note type (by code or by system | code).  
---|---  
      - `datetime_of_service`, `datetime_of_service__gt`, `datetime_of_service__gte`, `datetime_of_service__lt`, `datetime_of_service__lte`: Date/time based filters.
    - Pagination: 
      - `limit`: Number of results (default 10, min 1, max 100).
      - `offset`: Pagination offset (default 0, min 0).
    - If more results exist after the current page, a `next_page` link is included.
    - Returns a JSON object with `notes` (list), `count` (number of notes returned), and `next_page` (URL or None).
  - **POST /notes/**
    - Creates a new note.
    - Requires a JSON body with: 
      - `note_type_id`, `datetime_of_service` (as string), `patient_id`, `practice_location_id`, `provider_id`, `title`
    - If required fields are missing, returns an error with status 422.
    - Otherwise, initiates note creation and immediately returns an accepted response (`202 Accepted`) with a confirmation message.
  - **GET /notes/ <note-id>/**
    - Returns details for a specific note by its ID.
    - If the note doesn't exist, returns a "not found" response.
    - If found, returns note details, including its state (from `CurrentNoteStateEvent`), patient/provider IDs, datetime, and type info (id, name, coding).
**Helpers and Utilities**
  - Uses utilities such as `get_note_from_path_params` and `note_not_found_response` for ID lookup and error handling.
  - Uses Django-style ORM filters and queryset slicing.
  - Uses the `arrow` library for date parsing.
  - All endpoints expect authentication via the `simpleapi-api-key`.
    ```python
    import arrow
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.note.note import Note as NoteEffect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyAuthMixin, SimpleAPI, api
    from canvas_sdk.v1.data.note import Note, CurrentNoteStateEvent
    from charting_api_examples.util import get_note_from_path_params, note_not_found_response
    class NoteAPI(APIKeyAuthMixin, SimpleAPI):
        PREFIX = "/notes"
        """
        GET /plugin-io/api/charting_api_examples/notes/
        Headers: "Authorization <your value for 'simpleapi-api-key'>"
        """
        @api.get("/")
        def index(self) -> list[Response | Effect]:
            notes = Note.objects.select_related('patient', 'provider', 'note_type_version').order_by("dbid")
            query_params = self.request.query_params
            # User specified, default 10, min 1, max 100
            limit = min(max(int(query_params.get("limit", 10)), 1), 100)
            # User specified, default 0, min 0, no max
            offset = max(int(query_params.get("offset", 0)), 0)
            if "patient_id" in query_params:
                notes = notes.filter(patient__id=query_params["patient_id"])
            if "note_type" in query_params:
                # You can search by just the code value or you can search by the
                # system and code in the format system|code (e.g
                # http://snomed.info/sct|308335008).
                if "|" in query_params["note_type"]:
                    system, code = query_params["note_type"].split("|")
                    notes = notes.filter(note_type_version__system=system, note_type_version__code=code)
                else:
                    notes = notes.filter(note_type_version__code=query_params["note_type"])
            if "datetime_of_service" in query_params:
                notes = notes.filter(datetime_of_service=query_params["datetime_of_service"])
            if "datetime_of_service__gt" in query_params:
                notes = notes.filter(datetime_of_service__gt=query_params["datetime_of_service__gt"])
            if "datetime_of_service__gte" in query_params:
                notes = notes.filter(datetime_of_service__gte=query_params["datetime_of_service__gte"])
            if "datetime_of_service__lt" in query_params:
                notes = notes.filter(datetime_of_service__lt=query_params["datetime_of_service__lt"])
            if "datetime_of_service__lte" in query_params:
                notes = notes.filter(datetime_of_service__lte=query_params["datetime_of_service__lte"])
            # If there are more results matching the filter after the ones we're
            # returning, provide the link to the next page with the proper offset.
            # If there aren't any more results, return None so the client can tell
            # that there are no more results to fetch.
            link_to_next = None
            if notes[offset+limit:].count() > 0:
                requested_uri = self.context.get("absolute_uri")
                if "offset" in query_params:
                    link_to_next = requested_uri.replace(f"offset={offset}", f"offset={offset+limit}")
                else:
                    param_separator = "?" if len(query_params) == 0 else "&"
                    link_to_next = requested_uri + f"{param_separator}offset={offset+limit}"
            # Apply limit and offset
            notes = notes[offset:offset+limit]
            count = len(notes)
            return [
                JSONResponse({
                    "next_page": link_to_next,
                    "count": count,
                    "notes": [{
                        "id": str(note.id),
                        "patient_id": str(note.patient.id),
                        "provider_id": str(note.provider.id),
                        "datetime_of_service": str(note.datetime_of_service),
                        "note_type": {
                            "id": str(note.note_type_version.id),
                            "name": note.note_type_version.name,
                            "coding": {
                                "display": note.note_type_version.display,
                                "code": note.note_type_version.code,
                                "system": note.note_type_version.system,
                            },
                        },
                    } for note in notes]
                })
            ]
        """
        POST /plugin-io/api/charting_api_examples/notes/
        Headers: "Authorization <your value for 'simpleapi-api-key'>"
        Body: {
    		"note_type_id": "c5df4f03-58e4-442b-ad6c-0d3dadc6b726",
            "datetime_of_service": "2025-02-21 23:31:42",
    		"patient_id": "5350cd20de8a470aa570a852859ac87e",
    		"practice_location_id": "306b19f0-231a-4cd4-ad2d-a55c885fd9f8",
    		"provider_id": "6b33e69474234f299a56d480b03476d3",
    		"title": "My Note Title",
        }
        """
        @api.post("/")
        def create(self) -> list[Response | Effect]:
            required_attributes = {
                "note_type_id",
                "datetime_of_service",
                "patient_id",
                "practice_location_id",
                "provider_id",
                "title",
            }
            request_body = self.request.json()
            missing_attributes = required_attributes - request_body.keys()
            if len(missing_attributes) > 0:
                return [
                    JSONResponse(
                        {"error": f"Missing required attribute(s): {', '.join(missing_attributes)}"},
                        # Normally you should use a constant, but this status
                        # code's constant changes in 3.13 from
                        # UNPROCESSABLE_ENTITY to UNPROCESSABLE_CONTENT. Using the
                        # number directly here avoids that future breakage.
                        status_code=422,
                    )
                ]
            note_type_id = request_body["note_type_id"]
            datetime_of_service = arrow.get(request_body["datetime_of_service"]).datetime
            patient_id = request_body["patient_id"]
            practice_location_id = request_body["practice_location_id"]
            provider_id = request_body["provider_id"]
            title = request_body["title"]
            note_effect = NoteEffect(
                note_type_id=note_type_id,
                datetime_of_service=datetime_of_service,
                patient_id=patient_id,
                practice_location_id=practice_location_id,
                provider_id=provider_id,
                title=title,
            )
            return [
                note_effect.create(),
                JSONResponse({"message": "Note data accepted for creation"}, status_code=HTTPStatus.ACCEPTED)
            ]
        """
        GET /plugin-io/api/charting_api_examples/notes/<note-id>/
        Headers: "Authorization <your value for 'simpleapi-api-key'>"
        """
        @api.get("/<id>/")
        def read(self) -> list[Response | Effect]:
            note = get_note_from_path_params(self.request.path_params)
            if not note:
                return note_not_found_response()
            status_code = HTTPStatus.OK
            current_note_state = CurrentNoteStateEvent.objects.get(note=note).state
            response = {
                "note": {
                    "id": str(note.id),
                    "patient_id": str(note.patient.id),
                    "provider_id": str(note.provider.id),
                    "datetime_of_service": str(note.datetime_of_service),
                    "state": current_note_state,
                    "note_type": {
                        "id": str(note.note_type_version.id),
                        "name": note.note_type_version.name,
                        "coding": {
                            "display": note.note_type_version.display,
                            "code": note.note_type_version.code,
                            "system": note.note_type_version.system,
                        },
                    },
                },
            }
            return [JSONResponse(response, status_code=status_code)]
    ```
###  billing_line_items.py 
This file defines an API endpoint for adding billing line items (represented by CPT codes) to a note.
**Key Components**
  - Imports utility and SDK classes for effects, API handling, and response generation.
  - Defines a class, `BillingLineItemAPI`, which inherits API authentication and handling functionalities.
  - Registers an HTTP POST endpoint at `/notes/<note-id>/billing_line_items/`.
  - Expects an API key in the request header for authentication.
  - Expects the request body to be JSON with a "cpt_code" attribute.
    ```python
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.billing_line_item import AddBillingLineItem
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyAuthMixin, SimpleAPI, api
    from canvas_sdk.v1.data.note import Note
    from charting_api_examples.util import get_note_from_path_params, note_not_found_response
    class BillingLineItemAPI(APIKeyAuthMixin, SimpleAPI):
        PREFIX = "/notes"
        """
        POST /plugin-io/api/charting_api_examples/notes/<note-id>/billing_line_items/
        Headers: "Authorization <your value for 'simpleapi-api-key'>"
        Body: {
            "cpt_code": "98006"
        }
        """
        @api.post("/<id>/billing_line_items/")
        def add_billing_line_item(self) -> list[Response | Effect]:
            required_attributes = {"cpt_code",}
            request_body = self.request.json()
            missing_attributes = required_attributes - request_body.keys()
            if len(missing_attributes) > 0:
                return [
                    JSONResponse(
                        {"error": f"Missing required attribute(s): {', '.join(missing_attributes)}"},
                        # Normally you should use a constant, but this status
                        # code's constant changes in 3.13 from
                        # UNPROCESSABLE_ENTITY to UNPROCESSABLE_CONTENT. Using the
                        # number directly here avoids that future breakage.
                        status_code=422,
                    )
                ]
            note = get_note_from_path_params(self.request.path_params)
            if not note:
                return note_not_found_response()
            # To see what else you can do with billing line items, visit our docs:
            # https://docs.canvasmedical.com/sdk/effect-billing-line-items/#adding-a-billing-line-item
            effect = AddBillingLineItem(
                note_id=str(note.id),
                cpt=request_body["cpt_code"],
            )
            return [
                effect.apply(),
                JSONResponse({"message": "Billing line item data accepted for creation"}, status_code=HTTPStatus.ACCEPTED)
            ]
    ```
##  util.py 
This file provides utility functions for working with Note objects. The utilities include input validation, standard JSON error responses, and fetching Note objects by ID.
**Function: is_valid_uuid**
This function checks whether a given string is a valid UUID (specifically version 4).
  - Takes a single string argument.
  - Returns True if the string is a properly formatted version 4 UUID, False otherwise.
**Function: note_not_found_response**
This function returns a standardized JSON error response indicating that a requested Note was not found.
  - Uses JSONResponse from the SDK.
  - Sets the response status to HTTP 404 (NOT FOUND) and the body to {"error": "Note not found."}.
**Function: get_note_from_path_params**
This function attempts to retrieve a Note object using a dictionary of path parameters.
  - Extracts the "id" from path_params.
  - Validates the ID as a UUID using is_valid_uuid.
  - If invalid, returns None.
  - If valid, attempts to retrieve a Note object with the given ID (using Note.objects.get).
  - If the Note does not exist, catches the DoesNotExist exception and returns None.
  - Returns the Note object if found, or None if not found/invalid.
**Imports and External Dependencies**
  - uuid.UUID: For validating UUIDs.
  - http.HTTPStatus: For standardized HTTP status codes.
  - canvas_sdk.effects.simple_api.JSONResponse: For returning consistent API responses.
  - canvas_sdk.v1.data.note.Note: For interacting with Note objects from the Canvas SDK.
    ```python
    from uuid import UUID
    from http import HTTPStatus
    from canvas_sdk.effects.simple_api import JSONResponse
    from canvas_sdk.v1.data.note import Note
    def is_valid_uuid(possible_uuid):
        try:
            uuid_obj = UUID(possible_uuid, version=4)
        except ValueError:
            return False
        return str(uuid_obj) == possible_uuid
    def note_not_found_response():
        return JSONResponse(
            {"error": "Note not found."},
            status_code=HTTPStatus.NOT_FOUND,
        )
    def get_note_from_path_params(path_params) -> Note | None:
        note_id = path_params["id"]
        # Ensure the note id is a valid UUID
        if not is_valid_uuid(note_id):
            return None
        try:
            note = Note.objects.get(id=note_id)
        except (Note.DoesNotExist):
            return None
        return note
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-charting_api_examples/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-example_chart_app/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/example_chart_app) for this plugin on GitHub. 
An example custom UI Application for the patient chart. This particular application loads the active staff user and displays some attributes about them (ex: their name), and it also loads templated HTML and JavaScript to make a REST call to a user-defined endpoint, right in the Canvas EMR.
##  SDK Features 
  - Creates a `GET` [Simple API](/sdk/handlers-simple-api-http/) endpoint that retrieves the logged in [Staff user](/sdk/data-staff/) from the event context, [renders a template](/sdk/layout-effect/#custom-html-and-django-templates), and returns HTML content
  - Creates a `POST` [Simple API](/sdk/handlers-simple-api-http/) endpoint that [creates a task](/sdk/effect-tasks/#adding-a-task)
  - Defines a custom template containing JavaScript that makes a REST call to the user-defined `POST` endpoint above
  - Adds an [Application](/sdk/handlers-applications/) effect that, on open, returns a [LaunchModalEffect](/sdk/layout-effect/#modals) in the right chart pane with content from the `GET` endpoint
##  Configuration 
These SimpleAPI endpoints use the [StaffSessionAuthMixin](/sdk/handlers-simple-api-http/#staff-session)
The `CANVAS_MANIFEST.json` file defines attributes specific to the Application, including scope (`patient_specific`) and icon image.
##  Structure 
    ```plaintext
    example_chart_app/
    ├── applications/
    │   ├── __init__.py
    │   ├── my_application.py     # Defines API endpoints and Application
    ├── assets
    |   ├──rx.png                 # Image file
    ├── templates/
    │   └── custom_ui.html        # HTML template for visualization UI
    ├── CANVAS_MANIFEST.json      # Plugin configuration
    └── README.md                 # Documentation
    ```
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "example_chart_app",
        "description": "Used to test various canvas plugins functionality",
        "url_permissions": [],
        "components": {
            "protocols": [
                {
                    "class": "example_chart_app.applications.my_application:MyApi",
                    "description": "Provides api for the application",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
            ],
            "applications": [
                {
                    "class": "example_chart_app.applications.my_application:MyChartApplication",
                    "name": "Example Chart App",
                    "description": "Show a custom, interactive UI in the chart",
                    "scope": "patient_specific",
                    "icon": "assets/rx.png"
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  templates/ 
###  custom-ui.html 
This is the html template called by the [`render_to_string` function](/sdk/layout-effect/#custom-html-and-django-templates) with a `logged_in_staff` object. It contains styling and custom Javascript to call the user-defined POST endpoint when a specific element is clicked.
##  applications/ 
###  my_application.py 
This file defines an application plugin for Canvas Medical using the Canvas SDK. It includes a custom application (`MyChartApplication`) and an API (`MyApi`) for rendering a modal user interface pane and handling related actions, such as adding tasks.
**MyChartApplication Class**
  - Subclasses the `Application` class from the Canvas SDK.
  - The `on_open` method is triggered when the application is opened. It retrieves the current patient's ID from `self.context`.
  - It returns a `LaunchModalEffect`, which opens a custom modal UI in the right chart pane. The URL for this modal includes the patient ID as a query parameter.
**MyApi Class**
  - Subclasses both `StaffSessionAuthMixin` and `SimpleAPI`, enabling API definition with authentication.
  - Defines two endpoints using the `@api` decorator: a GET and a POST.
**GET /custom-ui**
  - Endpoint: `/custom-ui`
  - Retrieves the logged-in staff user via the header `"canvas-logged-in-user-id"` and the Canvas SDK Staff data model (but it could retrieve any data!)
  - Renders a template (`templates/custom-ui.html`) with context including the logged-in staff and the selected patient ID.
  - Returns the rendered HTML as an `HTMLResponse` with HTTP 200 (OK) status.
**POST /add-task**
  - Endpoint: `/add-task`
  - Creates a new task for the specified patient (using `patient_id` from the posted JSON payload).
  - Sets the task to be due in 5 days from the current UTC time and sets its status to open.
  - Returns two responses: 
    - The effect to add a task (which also triggers any related UI updates).
    - A JSON response with a success message and HTTP 202 (Accepted) status.
**Miscellaneous**
  - Imports various components and utilities from the Canvas SDK, such as effects for UI actions, response types, authentication mixins, and template rendering.
  - Uses the `arrow` library for time/date handling.
**Summary**
The code provides a Canvas plugin that opens a modal UI displaying custom content for a selected patient. It can also create a new patient-related task when a specific endpoint is called, handling user authentication and returning appropriate UI and API responses. The flow is tailored to staff users interacting with patient charts.
    ```python
    import arrow
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.effects.simple_api import Response, JSONResponse, HTMLResponse
    from canvas_sdk.effects.task import AddTask, TaskStatus
    from canvas_sdk.handlers.application import Application
    from canvas_sdk.handlers.simple_api import StaffSessionAuthMixin, SimpleAPI, api
    from canvas_sdk.templates import render_to_string
    from canvas_sdk.v1.data.staff import Staff
    class MyChartApplication(Application):
        def on_open(self) -> Effect:
            patient_id = self.context['patient']['id']
            return LaunchModalEffect(
                url=f"/plugin-io/api/example_chart_app/custom-ui?patient={patient_id}",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
    class MyApi(StaffSessionAuthMixin, SimpleAPI):
        @api.get("/custom-ui")
        def custom_ui(self) -> list[Response | Effect]:
            logged_in_staff = Staff.objects.get(id=self.request.headers["canvas-logged-in-user-id"])
            context = {
                "logged_in_staff": logged_in_staff,
                "patient_id": self.request.query_params["patient"],
            }
            return [
                HTMLResponse(
                    render_to_string("templates/custom-ui.html", context),
                    status_code=HTTPStatus.OK,
                )
            ]
        @api.post("/add-task")
        def add_task(self) -> list[Response | Effect]:
            add_task = AddTask(
                title="This came from the custom patient ui.",
                patient_id=self.request.json()["patient_id"],
                due=arrow.utcnow().shift(days=5).datetime,
                status=TaskStatus.OPEN,
            )
            return [
                add_task.apply(),
                JSONResponse(
                    {"message": "Task will be created"},
                    status_code=HTTPStatus.ACCEPTED
                )
            ]
    ```
##  assets/ 
###  rx.png 
This is an image file used as the Application icon within the Canvas UI.
----- END PAGE https://docs.canvasmedical.com/sdk/example-example_chart_app/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-extend_ai_pdf/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/extend_ai_pdf) for this plugin on GitHub. 
##  Description 
Plugin that provides a SimpleAPI for intelligent document processing using the Extend AI client. It supports listing processors, running document extraction on PDF files, checking run status, managing stored files, and retrieving processing results. Includes a chart application that renders a form interface for PDF processing directly from the chart.
##  Configuration 
This example plugin defines the following "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "ExtendAiKey"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  ExtendAiKey 
Your Extend AI API key.
##  CANVAS_MANIFEST.json 
    ```json
    {
      "sdk_version": "0.81.0",
      "plugin_version": "0.0.1",
      "name": "pdf_manip",
      "description": "use extent.ai to extract information from a PDF document",
      "components": {
        "protocols": [
          {
            "class": "pdf_manip.handlers.pdf_manip:PdfManip",
            "description": "PDF extractor based on extent.ai"
          }
        ],
        "applications": [
          {
            "class": "pdf_manip.handlers.pdf_form_app:PdfFormApp",
            "name": "PDF Upload",
            "description": "Extend.ai manip",
            "icon": "static/pdf_manip.png",
            "scope": "patient_specific",
            "show_in_panel": false
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [
        "ExtendAiKey"
      ],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
    ```
##  handlers/ 
###  pdf_manip.py 
**Purpose**
This code defines a SimpleAPI handler that exposes REST endpoints for processing PDF documents using the Extend AI client from the Canvas SDK.
**Class Overview**
  - The main class, `PdfManip`, extends `StaffSessionAuthMixin` and `SimpleAPI`.
  - It creates an Extend AI client using an API key stored in plugin secrets.
**Main Workflow**
  - `GET /processors` — Lists all available Extend AI processors.
  - `GET /processors/<processor_id>` — Retrieves configuration for a specific processor.
  - `POST /execute` — Starts a processor run on a document from a public S3 URL.
  - `GET /status/<run_id>` — Checks the status of a run and cleans up files if completed.
  - `GET /result/<run_id>` — Retrieves the processing result for a completed run.
  - `GET /stored_files` — Lists all files stored in Extend AI.
  - `POST /delete_files` — Deletes specified files from Extend AI storage.
**Extend AI Client Integration**
  - The `_extend_client` method creates a `Client` instance from `canvas_sdk.clients.extend_ai.libraries`.
  - Error handling uses the `RequestFailed` exception from the Extend AI client structures.
    ```python
    from datetime import datetime
    from http import HTTPStatus
    from canvas_sdk.clients.extend_ai.constants import RunStatus, VersionName
    from canvas_sdk.clients.extend_ai.libraries import Client
    from canvas_sdk.clients.extend_ai.structures import RequestFailed
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import SimpleAPI, StaffSessionAuthMixin, api
    from pdf_manip.constants.secrets import Secrets
    class PdfManip(StaffSessionAuthMixin, SimpleAPI):
        """API handler for Extend AI PDF processing operations."""
        PREFIX = None
        USER_TYPE_STAFF = "Staff"
        def _extend_client(self) -> Client:
            """Create and return a configured Extend AI client."""
            return Client(self.secrets[Secrets.extend_ai_key])
        @api.get("/processors")
        def list_processors(self) -> list[Response | Effect]:
            """Retrieve all available Extend AI processors."""
            try:
                content: list | dict = [p.to_dict() for p in self._extend_client().list_processors()]
                status_code = HTTPStatus(HTTPStatus.OK)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
        @api.get("/processors/<processor_id>")
        def get_processor(self) -> list[Response | Effect]:
            """Retrieve the configuration for a specific processor by ID."""
            try:
                processor_id = self.request.path_params["processor_id"]
                response = self._extend_client().processor(processor_id, VersionName.DRAFT.value)
                content = response.config.to_dict()
                status_code = HTTPStatus(HTTPStatus.OK)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
        @api.get("/result/<run_id>")
        def run_result(self) -> list[Response | Effect]:
            """Retrieve the processing result for a completed run."""
            try:
                run_id = self.request.path_params["run_id"]
                response = self._extend_client().run_status(run_id)
                if response.status == RunStatus.PROCESSED:
                    content = {"result": response.output.to_dict()}
                    status_code = HTTPStatus(HTTPStatus.OK)
                else:
                    content = {"result": response.status}
                    status_code = HTTPStatus(HTTPStatus.UNPROCESSABLE_ENTITY)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
        @api.get("/status/<run_id>")
        def run_status(self) -> list[Response | Effect]:
            """Check the status of a processor run and clean up files if completed."""
            try:
                run_id = self.request.path_params["run_id"]
                extend_ai = self._extend_client()
                response = extend_ai.run_status(run_id)
                if response.status == RunStatus.PROCESSED:
                    for file in response.files:
                        extend_ai.delete_file(file.id)
                content = {"runId": response.id, "status": response.status.value}
                status_code = HTTPStatus(HTTPStatus.OK)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
        @api.get("/stored_files")
        def extend_stored_files(self) -> list[Response | Effect]:
            """List all files stored in Extend AI."""
            try:
                content: list | dict = [f.to_dict() for f in self._extend_client().list_files()]
                status_code = HTTPStatus(HTTPStatus.OK)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
        @api.post("/delete_files")
        def extend_delete_files(self) -> list[Response | Effect]:
            """Delete specified files from Extend AI storage."""
            try:
                content: list | dict = [
                    {
                        "id": file_id,
                        "deleted": self._extend_client().delete_file(file_id),
                    }
                    for file_id in self.request.json().get("fileIds") or []
                ]
                status_code = HTTPStatus(HTTPStatus.OK)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
        @api.post("/execute")
        def run_start(self) -> list[Response | Effect]:
            """Start a processor run on a document from a public S3 URL."""
            try:
                received = self.request.json()
                aws_s3_url = received.get("fileAwsS3Url")
                processor_id = received.get("processorId")
                response = self._extend_client().run_processor(
                    processor_id=processor_id,
                    file_name=f"processed-{datetime.now().isoformat(timespec='seconds')}",
                    file_url=aws_s3_url,
                    config=None,
                )
                content = {"runId": response.id, "status": response.status.value}
                status_code = HTTPStatus(HTTPStatus.OK)
            except RequestFailed as e:
                content = {"information": e.message}
                status_code = HTTPStatus(e.status_code)
            return [JSONResponse(content, status_code=status_code)]
    ```
###  pdf_form_app.py 
**Purpose**
This code defines an Application handler that launches a modal form in the right chart pane for interacting with the Extend AI PDF processing API endpoints.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    from canvas_sdk.templates import render_to_string
    class PdfFormApp(Application):
        """Application handler that displays the PDF processing form in a modal."""
        PLUGIN_API_BASE_ROUTE = "/plugin-io/api/pdf_manip"
        def on_open(self) -> Effect:
            """Render and launch the PDF processing form modal in the right chart pane."""
            content = render_to_string(
                "templates/pdf_form.html",
                {
                    "processorsURL": f"{self.PLUGIN_API_BASE_ROUTE}/processors",
                    "statusURL": f"{self.PLUGIN_API_BASE_ROUTE}/status",
                    "executeURL": f"{self.PLUGIN_API_BASE_ROUTE}/execute",
                    "resultURL": f"{self.PLUGIN_API_BASE_ROUTE}/result",
                    "storedFilesURL": f"{self.PLUGIN_API_BASE_ROUTE}/stored_files",
                    "deleteFilesURL": f"{self.PLUGIN_API_BASE_ROUTE}/delete_files",
                },
            )
            return LaunchModalEffect(
                content=content,
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-extend_ai_pdf/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-llm/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/llm) for this plugin on GitHub. 
##  Description 
Plugin that provides a SimpleAPI for interacting with multiple LLM providers (Anthropic, Google, OpenAI) through the Canvas SDK's unified LLM client. It supports image analysis with structured JSON output, multi-turn chat conversations, and file content analysis. Includes a chart application that renders a form interface for LLM interactions directly from the chart.
##  Configuration 
This example plugin defines the following "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "AnthropicKey",
            "GoogleKey",
            "OpenaiKey"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  AnthropicKey 
Your [Anthropic API key](https://console.anthropic.com/settings/keys).
###  GoogleKey 
Your [Google AI API key](https://aistudio.google.com/apikey).
###  OpenaiKey 
Your [OpenAI API key](https://platform.openai.com/api-keys).
##  CANVAS_MANIFEST.json 
    ```json
    {
      "sdk_version": "0.81.0",
      "plugin_version": "0.0.1",
      "name": "llm_manip",
      "description": "use LLM to interact with the user",
      "components": {
        "protocols": [
          {
            "class": "llm_manip.handlers.llm_manip:LlmManip",
            "description": "LLM communication wrapper"
          }
        ],
        "applications": [
          {
            "class": "llm_manip.handlers.llm_form_app:LlmFormApp",
            "name": "LLM Interactions",
            "description": "LLM interactions with the user",
            "icon": "static/llm_manip.png",
            "scope": "patient_specific",
            "show_in_panel": false
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [
        "AnthropicKey",
        "GoogleKey",
        "OpenaiKey"
      ],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
    ```
##  handlers/ 
###  llm_manip.py 
**Purpose**
This code defines a SimpleAPI handler that exposes REST endpoints for interacting with LLM providers using the Canvas SDK's unified LLM client.
**Class Overview**
  - The main class, `LlmManip`, extends `SimpleAPI`.
  - It supports three LLM providers: Anthropic (Claude), Google (Gemini), and OpenAI (GPT Models).
  - It demonstrates structured JSON output using Pydantic models (`LlmResponse`, `Result`).
**Main Workflow**
  - `POST /animals_count/<llm_provider>` — Analyzes an image URL to count animals using LLM vision capabilities with structured JSON output.
  - `POST /chat/<llm_provider>` — Processes a multi-turn chat conversation with system, user, and model roles.
  - `POST /file/<llm_provider>` — Analyzes uploaded file content using multipart form data.
**LLM Client Integration**
  - The `_llm_client` method creates provider-specific clients (`LlmAnthropic`, `LlmGoogle`, `LlmOpenai`) with their respective settings classes.
  - Structured output is configured via `client.set_schema()` with Pydantic models extending `BaseModelLlmJson`.
  - File attachments are supported via `LlmFileUrl` for URLs and `FileContent` for binary content.
    ```python
    import base64
    from http import HTTPStatus
    from pydantic import Field
    from canvas_sdk.clients.llms.constants import FileType
    from canvas_sdk.clients.llms.libraries import LlmAnthropic, LlmApi, LlmGoogle, LlmOpenai
    from canvas_sdk.clients.llms.structures import BaseModelLlmJson, FileContent, LlmFileUrl
    from canvas_sdk.clients.llms.structures.settings import (
        LlmSettingsAnthropic,
        LlmSettingsGemini,
        LlmSettingsGpt4,
    )
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, PlainTextResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPI, api
    from canvas_sdk.handlers.simple_api.api import FileFormPart, StringFormPart
    from llm_manip.constants.secrets import Secrets
    class Result(BaseModelLlmJson):
        """Structured response model for animal counting results."""
        count_dogs: int = Field(description="the number of dogs")
        count_cats: int = Field(description="the number of cats")
        count_total: int = Field(description="the number of animals")
    class LlmResponse(BaseModelLlmJson):
        """Structured response model for LLM animal analysis with optional result."""
        comment: str = Field(description="the comment")
        result: Result | None
    class LlmManip(SimpleAPI):
        """Simple API handler for LLM-based image analysis and chat operations."""
        PREFIX = None
        LLM_ANTHROPIC = 0
        LLM_GOOGLE = 1
        LLM_OPENAI = 2
        def authenticate(self, credentials: Credentials) -> bool:
            """Authenticate API requests."""
            return True
        def _llm_client(self, provider: int) -> LlmApi:
            """Create and configure a LLM client with credentials from secrets."""
            if provider == self.LLM_ANTHROPIC:
                return LlmAnthropic(
                    LlmSettingsAnthropic(
                        api_key=self.secrets[Secrets.anthropic_key],
                        model="claude-sonnet-4-5",
                        temperature=1.0,
                        max_tokens=8192,
                    )
                )
            elif provider == self.LLM_GOOGLE:
                return (
                    LlmGoogle(
                        LlmSettingsGemini(
                            api_key=self.secrets[Secrets.anthropic_key],
                            model="models/gemini-2.5-flash",
                            temperature=1.0,
                        )
                    ),
                )
            else:
                return LlmOpenai(
                    LlmSettingsGpt4(
                        api_key=self.secrets[Secrets.openai_key],
                        model="gpt-4o",
                        temperature=2.0,
                    )
                )
        @api.post("/animals_count/<llm_provider>")
        def animals_count(self) -> list[Response | Effect]:
            """Analyze an image URL to count animals using LLM vision capabilities."""
            client = self._llm_client(self.request.path_params["llm_provider"])
            url = self.request.json().get("url")
            if not url:
                url = "https://images.unsplash.com/photo-1563460716037-460a3ad24ba9?w=125"
            client.set_schema(LlmResponse)
            client.set_system_prompt(
                ["Your task is to read the pictures provided by the user and count the animals in it."]
            )
            client.set_user_prompt(["Identify the content of the provided picture."])
            client.add_url_file(LlmFileUrl(url=url, type=FileType.IMAGE))
            responses = client.attempt_requests(attempts=2)
            content = [r.to_dict() for r in responses]
            return [JSONResponse(content, status_code=HTTPStatus(HTTPStatus.OK))]
        @api.post("/chat/<llm_provider>")
        def chat(self) -> list[Response | Effect]:
            """Process a multi-turn chat conversation with the LLM."""
            client = self._llm_client(self.request.path_params["llm_provider"])
            for turn in self.request.json():
                if not isinstance(turn, dict):
                    continue
                if turn.get("role") == "system":
                    client.set_system_prompt([turn.get("prompt", "")])
                elif turn.get("role") == "user":
                    client.set_user_prompt([turn.get("prompt", "")])
                else:
                    client.set_model_prompt([turn.get("prompt", "")])
            response = client.attempt_requests(attempts=1)[0]
            return [PlainTextResponse(response.response, status_code=response.code)]
        @api.post("/file/<llm_provider>")
        def file(self) -> list[Response | Effect]:
            """Analyze file content using LLM."""
            content = b""
            mime_type = ""
            user_input = ""
            form_data = self.request.form_data()
            if "file" in form_data and isinstance(form_data["file"], FileFormPart):
                content = form_data["file"].content
                mime_type = form_data["file"].content_type
            if "input" in form_data and isinstance(form_data["input"], StringFormPart):
                user_input = form_data["input"].value
            if not (content and mime_type and user_input):
                return [PlainTextResponse("nothing to do", status_code=HTTPStatus(HTTPStatus.OK))]
            client = self._llm_client(self.request.path_params["llm_provider"])
            file = FileContent(
                mime_type=mime_type,
                content=base64.b64encode(content),
                size=len(content),
            )
            client.file_contents.append(file)
            client.set_system_prompt(["Answer to the question about the file, clearly and concisely."])
            client.set_user_prompt([user_input or "what is in the file?"])
            response = client.attempt_requests(attempts=1)[0]
            return [PlainTextResponse(response.response, status_code=response.code)]
    ```
###  llm_form_app.py 
**Purpose**
This code defines an Application handler that launches a modal form in the right chart pane for interacting with the LLM API endpoints.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    from canvas_sdk.templates import render_to_string
    class LlmFormApp(Application):
        """Application handler for launching the LLM interaction form interface."""
        PLUGIN_API_BASE_ROUTE = "/plugin-io/api/llm_manip"
        def on_open(self) -> Effect:
            """Render and launch the LLM interaction modal form."""
            content = render_to_string(
                "templates/llm_form.html",
                {
                    "animalsCountURL": f"{self.PLUGIN_API_BASE_ROUTE}/animals_count",
                    "chatURL": f"{self.PLUGIN_API_BASE_ROUTE}/chat",
                    "fileURL": f"{self.PLUGIN_API_BASE_ROUTE}/file",
                },
            )
            return LaunchModalEffect(
                content=content,
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-llm/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-patient_creation_platform_sync/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/example_patient_sync) for this plugin on GitHub. 
##  Description 
An example of bidirectional patient creation between Canvas and a 3rd party system.
At a high level, this plugin:
  1. Adds an API endpoint to which the external system can POST a new patient object with a given system_id, which creates a patient in Canvas with an external_identifier.
  2. Configures a webhook for the PATIENT_CREATED event to automatically synchronize patient data. When a patient is created in Canvas, the webhook triggers an update (or creation) in the external system via its patient GET/POST/PATCH API, ensuring the Canvas ID is always included.
##  Sample CURL request 
Once the API endpoint POST action is created, test it is working with the following CURL command (or use a popular GUI like Postman or Bruno). Replace "training" with your Canvas instance name:
    ```plaintext
    curl --request POST \
      --url https://training.canvasmedical.com/plugin-io/api/example_patient_sync/patients \
      --header 'content-type: application/json' \
      --header 'authorization: 97f2a0f033666d29ff09ee42b3afd7e4'
      --data '{
      "firstName": "Alice",
      "lastName": "Example",
      "sexAtBirth": "F",
      "dateOfBirth": "1980-02-22",
      "partnerId": "pat_12345678"
    }'
    ```
##  Defining and Setting Secrets 
This example plugin defines four "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "PARTNER_URL_BASE",
            "PARTNER_API_BASE_URL",
            "PARTNER_SECRET_API_KEY",
            "simpleapi-api-key"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  PARTNER_URL_BASE 
This string value will be set as the "system" in the patient external identifier that is created. A patient can have many external identifiers, so make sure this is a unique value that is searchable to find their external ID in the future. [Read more](https://docs.canvasmedical.com/sdk/effect-create-patient-external-identifier/)
###  PARTNER_API_BASE_URL 
This string value will be used when making REST API calls to a partner system (to create or update a patient record, for example). It may or may not be the same as the PARTNER_URL_BASE.
###  PARTNER_SECRET_API_KEY 
If accessing a partner API requires authorization, this can define the auth secret to enable the API handshake.
###  simpleapi-api-key 
This is the authorization needed for Canvas when using APIKeyAuthMixin. [Read more](https://docs.canvasmedical.com/sdk/handlers-simple-api-http/#session)
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.40.0",
        "plugin_version": "0.0.1",
        "name": "example_patient_sync",
        "description": "Example bidirectional patient synchronization between Canvas and a 3rd party system",
        "components": {
            "protocols": [
                {
                    "class": "example_patient_sync.handlers.patient_sync:PatientSync",
                    "description": "Create or update patients in an external system based on Canvas events",
                },
                {
                    "class": "example_patient_sync.routes.patient_create_api:PatientCreateApi",
                    "description": "Create a patient in Canvas when a user is created in an external system",
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [
            "PARTNER_URL_BASE",
            "PARTNER_API_BASE_URL",
            "PARTNER_SECRET_API_KEY",
            "simpleapi-api-key"
        ],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  routes/ 
###  patient_create_api.py 
**Purpose**
The code defines an HTTP API endpoint for creating new patient records in Canvas from a third-party system. It authenticates requests using an API key and expects data in JSON format.
**Authentication**
The endpoint uses APIKeyAuthMixin, which requires clients to provide a valid API key in the request headers for authorization.
**Endpoint Details**
  - **Route:** POST /patients
  - **Description:** Accepts and processes patient creation requests sent by external systems.
**Request Handling**
  - Expects a JSON body describing the patient. If the JSON body is not a dictionary, returns a "400 Bad Request".
  - Extracts and processes the following fields from the request: 
    - `firstName`: Patient's first name.
    - `lastName`: Patient's last name.
    - `dateOfBirth`: Patient's date of birth, parsed and converted to a date object.
    - `sexAtBirth`: Patient's sex at birth; attempts to standardize and map to one of the PersonSex enum values (`SEX_FEMALE`, `SEX_MALE`, `SEX_OTHER`, `SEX_UNKNOWN`). Unrecognized values are ignored.
    - `partnerId`: An external identifier for the patient, which is combined with a secret value (`PARTNER_URL_BASE`) to create a unique identifier object.
**Patient Creation**
  - Constructs a Patient object with the collected and parsed data.
  - Attaches the external identifier from the requesting system.
**Response**
  - Issues two actions in its response list: 
    - Requests the creation of the Patient record (an Effect for persistence in Canvas).
    - Returns a JSON response (HTTP 202 Accepted) containing the external identifier information (system and value), indicating the request was accepted.
**Error Handling**
  - If the request body is not valid JSON or not a dictionary, the endpoint immediately returns a 400 Bad Request with an error message.
**Dependencies**
  - Relies on the Canvas SDK for authentication, response creation, effect handling, and data models.
  - Uses the arrow library for robust date parsing.
    ```python
    from http import HTTPStatus
    from typing import cast
    import arrow
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient import Patient, PatientExternalIdentifier
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyAuthMixin, SimpleAPI, api
    from canvas_sdk.v1.data.common import PersonSex
    # Authentication is handled by the APIKeyAuthMixin, which checks the API key in the request headers
    # https://docs.canvasmedical.com/sdk/handlers-simple-api-http/#api-key-1
    class PatientCreateApi(APIKeyAuthMixin, SimpleAPI):
        """API endpoint for use by third-party system to create patients in Canvas when that system is the point of origination for that patient record."""
        # Docs: https://docs.canvasmedical.com/sdk/handlers-simple-api-http/
        # POST https://<instance-name>.canvasmedical.com/plugin-io/api/example_patient_sync/patients
        @api.post("/patients")
        def post(self) -> list[Response | Effect]:
            """Handle POST requests for patient sync."""
            json_body = self.request.json()
            if not isinstance(json_body, dict):
                return [
                    JSONResponse(
                        content="Invalid JSON body.", status_code=HTTPStatus.BAD_REQUEST
                    ).apply()
                ]
            birthdate = None
            date_of_birth_str = json_body.get("dateOfBirth")
            if isinstance(date_of_birth_str, str) and date_of_birth_str:
                birthdate = arrow.get(date_of_birth_str).date()
            sex_at_birth = None
            sex_at_birth_str = json_body.get("sexAtBirth")
            if sex_at_birth_str:
                s = cast(str, sex_at_birth_str).strip().upper()
                if s in ("F", "FEMALE"):
                    sex_at_birth = PersonSex.SEX_FEMALE
                elif s in ("M", "MALE"):
                    sex_at_birth = PersonSex.SEX_MALE
                elif s in ("O", "OTHER"):
                    sex_at_birth = PersonSex.SEX_OTHER
                elif s in ("U", "UNKNOWN"):
                    sex_at_birth = PersonSex.SEX_UNKNOWN
                else:
                    sex_at_birth = None
            partner_id = str(json_body.get("partnerId"))
            external_id = PatientExternalIdentifier(
                system=self.secrets['PARTNER_URL_BASE'],
                value=partner_id,
            )
            patient = Patient(
                birthdate=birthdate,
                first_name=str(json_body.get("firstName")),
                last_name=str(json_body.get("lastName")),
                sex_at_birth=sex_at_birth,
                external_identifiers=[external_id],
            )
            response = {"external_identifier": {"system": self.secrets['PARTNER_URL_BASE'], "value": partner_id}}
            return [
                patient.create(),
                JSONResponse(content=response, status_code=HTTPStatus.ACCEPTED).apply(),
            ]
    ```
##  handlers/ 
###  patient_sync.py 
**Summary**
This file defines a synchronization handler for patient data between the Canvas Medical platform and an external partner system. It listens for the event when a patient is created on Canvas and then ensures that this patient also exists (and is linked via an external identifier) in the partner system. The handler manages bidirectional lookup and updates of patient IDs between the two systems.
**Details of Operation**
  - The core class, `PatientSync`, inherits from `BaseHandler` and is triggered by the `PATIENT_CREATED` event in Canvas.
  - It uses configuration secrets and environment variables to determine endpoints, authentication headers, and other partner-specific parameters.
  - When a new patient is created in Canvas, the handler: 
    1. Checks if the patient already has an external identifier linking them to the partner system.
    2. If not, attempts to look up the patient in the partner system using the Canvas patient ID by issuing a GET request.
    3. If an existing patient ID is found in the partner system, or after determining a new patient needs to be created, it prepares a payload with patient details.
    4. Issues a POST request to the partner API to either create or update the patient there.
    5. If creating, the handler expects the partner system to return the newly created patient's external ID.
    6. Handles duplicate creation attempts (HTTP 409) by simply returning without making changes.
    7. When a new external identifier is obtained, triggers an Effect to update the Canvas patient record with this identifier.
**Technical Implementation**
  - Secrets such as API keys and base URLs are used for secure access and configuration.
  - The handler functions as a stateless, event-driven adapter to maintain patient cross-system consistency.
  - HTTP request functionality is abstracted via Canvas SDK utilities.
  - Effects (a pattern used in Canvas plugins) are queued to perform changes in Canvas asynchronously and safely.
  - Logging is imported but not shown in use in the provided code.
**Key Methods**
  - `lookup_external_id_by_system_url`: Searches Canvas patient external identifiers for the partner system's record.
  - `get_patient_from_system_api`: Fetches patient details from the external partner via GET request.
  - `compute`: Main workflow coordinating the above logic, handling deduplication, updates, and creation logic for patients in both systems.
**Error and Edge Cases**
  - Handles the situation where the partner system returns a duplicate on creation.
  - Deals with missing IDs by attempting lookups and only initiating creation when necessary.
  - Only updates Canvas when a new cross-system ID must be set.
**Purpose**
This plugin component ensures that every patient created in Canvas is also represented in a connected partner system, with persistent, synchronized external identifiers to enable cross-platform interoperability and data consistency.
    ```python
    from typing import Any
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient import CreatePatientExternalIdentifier
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.utils import Http
    from canvas_sdk.v1.data.patient import Patient
    from logger import log
    class PatientSync(BaseHandler):
        """Handler for synchronizing patient data between systems."""
        RESPONDS_TO = [
            EventType.Name(EventType.PATIENT_CREATED),
        ]
        @property
        def partner_url_base(self) -> str:
            """Return the base URL for the external partner platform."""
            return self.secrets["PARTNER_URL_BASE"]
        def partner_api_base_url(self) -> str:
            """Return the base URL for the external partner API."""
            return self.secrets["PARTNER_API_BASE_URL"]
        @property
        def partner_request_headers(self) -> dict[str, str]:
            """Return the request headers for external partner API requests."""
            partner_secret_api_key = self.secrets["PARTNER_SECRET_API_KEY"]
            return {"X-API-Key": partner_secret_api_key}
        @property
        def partner_patient_metadata(self) -> Any:
            """Return metadata for creation of the patient on external partner platform."""
            metadata = {"canvasPatientId": self.target}
            subdomain = self.environment["CUSTOMER_IDENTIFIER"]
            canvas_url = f"https://{subdomain}.canvasmedical.com"
            # This sets the canvas URL for the patient in the partner platform metadata
            # Combined with the canvasPatientId, this allows the partner platform to link back to the patient in Canvas
            metadata["canvasUrl"] = canvas_url
            return metadata
        def lookup_external_id_by_system_url(self, canvas_patient: Patient, system: str) -> str | None:
            """Get the system ID for a given patient and system from Canvas."""
            # If the patient already has a external identifier for the partner platform, identified by a matching system url, use the first one
            return (
                canvas_patient.external_identifiers.filter(system=system)
                .values_list("value", flat=True)
                .first()
            )
        def get_patient_from_system_api(self, canvas_patient_id: str) -> Any:
            """Look up a patient in the external system."""
            http = Http()
            return http.get(
                f"{self.partner_api_base_url}/patients/v2/{canvas_patient_id}",
                headers=self.partner_request_headers,
            )
        def compute(self) -> list[Effect]:
            """Compute the sync actions for the patient."""
            canvas_patient_id = self.target
            http = Http()
            canvas_patient = Patient.objects.get(id=canvas_patient_id)
            # by default assume we don't yet have a system patient ID
            # and that we need to update the patient in Canvas to add one
            system_patient_id = self.lookup_external_id_by_system_url(canvas_patient, self.partner_url_base)
            update_patient_external_identifier = system_patient_id is None
            # Here we check if the patient already has an external ID in Canvas for the partner platform
            if not system_patient_id:
                # Get the system external ID by making a GET request to the partner platform
                system_patient = self.get_patient_from_system_api(canvas_patient_id)
                system_patient_id = (
                    system_patient.json()["id"] if system_patient.status_code == 200 else None
                )
            # Great, now we know if the patient is assigned a system external ID with the partner
            # platform, and if we need to update it. At this point the system_patient_id can be 3 possible values:
            # 1. value we already had stored in Canvas in an external identifier,
            # 2. value we just got from our partner GET API lookup, or
            # 3. None
            # And we have a true/false call to action telling us if we need to add
            # an external identifier to our Canvas patient: `update_patient_external_identifier`
            # Generate the payload for creating or updating the patient in partner platform API
            partner_payload = {
                "externalId": canvas_patient.id,
                "firstName": canvas_patient.first_name,
                "lastName": canvas_patient.last_name,
                "dateOfBirth": canvas_patient.birth_date.isoformat(),
            }
            base_request_url = f"{self.partner_api_base_url}/patients/v2"
            # If we have a patient's partner external id, we know this is an update, so we'll append it to the request URL
            request_url = (
                f"{base_request_url}/{system_patient_id}" if system_patient_id else base_request_url
            )
            resp = http.post(request_url, json=partner_payload, headers=self.partner_request_headers)
            # If your system's API returns the ID of the newly created record,
            # grab it from the response so we can add it to the Canvas patient record
            if system_patient_id is None:
                system_patient_id = resp.json().get("id")
            duplicate_patient_attempt = resp.status_code == 409
            if duplicate_patient_attempt:
                # If your system's API can let you know when a duplicate record was attempted to be added,
                # you can use that information to return early here.
                return []
            elif update_patient_external_identifier:
                # Queue up an effect to update the patient in Canvas and add the external identifier
                external_id = CreatePatientExternalIdentifier(
                    patient_id=canvas_patient.id,
                    system=self.partner_url_base,
                    value=str(system_patient_id)
                )
                return [external_id.create()]
            else:
                return [] # Done!
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-patient_creation_platform_sync/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-patient_summary_chart_groups/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/patient_summary_chart_groups) for this plugin on GitHub. 
A plugin that groups Psychiatry conditions and medications in the patient summary chart.
##  SDK Features 
  - Responds to `PATIENT_CHART__CONDITIONS` and `PATIENT_CHART__MEDICATIONS` [events](/sdk/events/#patient-chart-configuration)
  - Loads the patient conditions and medications using event context
  - Iterates through conditions to retrieve the ICD10 CodeSystem and assigns to a [Group effect](/sdk/patient-chart-group-effect/#group) list of items
  - Iterates through medications to find an RxNorm match on a list of plugin-defined medication codes and assigns to a [Group effect](/sdk/patient-chart-group-effect/#group) list of items
  - Returns the [`PatientChartGroup` effect](/sdk/patient-chart-group-effect/) with `.apply()` called
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "patient_summary_chart_groups",
        "description": "A plugin that groups Psychiatry conditions and medications in the patient summary chart.",
        "components": {
            "protocols": [
                {
                    "class": "patient_summary_chart_groups.protocols.my_protocol:Protocol",
                    "description": "A protocol that groups Psychiatry conditions"
                },
                {
                    "class": "patient_summary_chart_groups.protocols.my_protocol:Medications",
                    "description": "A protocol that groups Psychiatry medications"
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  protocols/ 
###  my_protocol.py 
This file defines two custom protocol handlers, `Protocol` and `Medications`, using the Canvas SDK. These handlers listen for specific events related to a patient's medical chart and group relevant diagnoses or medications into a "Psychiatry" category, returning these as effects for further processing or display in the Canvas UI.
**Section:`Protocol` Handler**
  - Inherits from `BaseHandler`.
  - Listens to the `EventType.PATIENT_CHART__CONDITIONS` event (triggered when a patient's chart conditions are accessed).
  - For each condition in the event context, it looks at the `codings` list: 
    - If the coding system is ICD-10 (`CodeSystems.ICD10`) and the code falls within the ICD-10 psychiatry range ("F01" to "F99") or starts with "R45." (indicating certain psychiatric symptoms), the condition is added to a group named "Psychiatry".
  - The resulting group is returned using a `PatientChartGroup` effect, applied to be consumed by other parts of the platform (such as UI rendering).
**Section:`Medications` Handler**
  - Inherits from `BaseHandler`.
  - Listens to the `EventType.PATIENT_CHART__MEDICATIONS` event (triggered when a patient's medication list is accessed).
  - Maintains an explicit list of RxNorm codes (`medication_codes`) representing psychiatric or relevant medications.
  - For each medication in the event context, it looks at the `codings` list: 
    - If the coding system is RxNorm (`CodeSystems.RXNORM`) and the code (converted to integer) is in the handler's medication list, the medication is added to the "Psychiatry" group.
  - The resulting group is returned using a `PatientChartGroup` effect, again allowing psychiatric medications to be grouped in the UI.
**Section: Canvas SDK Constructs Used**
  - **Events:** Listens for specific event types (patient chart conditions or medications).
  - **Effects:** Returns grouping instructions as `PatientChartGroup` effects, making downstream processing or UI changes possible.
  - **Grouping:** Uses the `Group` object to label and prioritize (with `priority=100`) psychiatric items, and the `PatientChartGroup` to wrap effect logic for patient chart groupings.
**Section: Implementation Details**
  - The handlers use dictionary storage for groups but always construct only a single "Psychiatry" group.
  - ICD-10 and RxNorm code checks strictly conform to predefined domain ranges or explicit code lists.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.group import Group
    from canvas_sdk.effects.patient_chart_group import PatientChartGroup
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.commands.constants import CodeSystems
    class Protocol(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART__CONDITIONS)
        def compute(self) -> list[Effect]:
            groups: dict[str, Group] = {}
            groups.setdefault("Psychiatry", Group(priority=100, items=[], name="Psychiatry"))
            for condition in self.event.context:
               for coding in condition["codings"]:
                   if coding["system"] == CodeSystems.ICD10 and ("F01" <= coding["code"] <= "F99" or coding["code"].startswith("R45.")):
                       groups["Psychiatry"].items.append(condition)
                       break
            return [PatientChartGroup(items=groups).apply()]
    class Medications(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART__MEDICATIONS)
        medication_codes = [
            70223, 725, 17941, 1359, 89781, 314517, 1422, 42347, 1841, 3007, 2591497, 62174, 22656, 352372, 3288, 1598,
            3389, 3415, 3416, 3417, 3554, 10402, 11636, 1653781, 4024, 14584, 4328, 325526, 4850, 6130, 6373, 700810, 6664,
            6694, 6782, 6816, 6901, 7243, 326374, 31994, 7781, 2387302, 7966, 33272, 8133, 8150, 8152, 8702, 8704, 9260,
            36514, 1547099, 10689, 11289, 68503, 3920, 4457, 237005, 6378, 6754, 7814, 8001, 9601, 3264, 7242, 7895, 237099,
            203223, 3554, 2626143, 6711, 7407, 314875, 11256, 82819, 161203, 16735, 272, 2557217, 237099, 596, 704, 719,
            722, 725, 17381, 89013, 1673265, 641465, 784649, 38400, 1291301, 1292, 1373, 2690627, 2176312, 2121777, 1658314,
            1749, 19759, 19777, 1819, 42347, 1827, 477631, 19874, 2002, 1667655, 2296, 2356, 2372, 2373, 2403, 2406, 2556,
            2597, 2598, 2599, 2603, 2353, 2622, 2626, 3013, 2591497, 62174, 3247, 3251, 734064, 352372, 3288, 3322, 3332,
            91235, 3403, 3407, 203223, 3498, 3554, 2687966, 135447, 3634, 3637, 3638, 3642, 3648, 72625, 3755, 4024, 321988,
            2119365, 4077, 461016, 4118, 24474, 4328, 1665509, 4457, 4460, 4493, 4495, 4496, 4501, 4507, 42355, 25480, 4637,
            2672253, 325526, 4903, 40114, 26412, 5093, 2267703, 5553, 73178, 5691, 5975, 262150, 6011, 6026, 285228, 28439,
            2626143, 2272403, 237005, 1433212, 700810, 6448, 746070, 42351, 52105, 1546376, 28863, 6470, 28894, 6475,
            2275602, 1040028, 52356, 6646, 6673, 6680, 6711, 6719, 6760, 6779, 6813, 6816, 6823, 6852, 6901, 6904, 6910,
            6960, 588250, 15996, 30125, 7019, 31479, 7242, 7243, 31565, 7407, 7440, 7486, 3155, 7531, 61381, 26225, 1370971,
            7781, 2387302, 679314, 7895, 7909, 32937, 7966, 7974, 8042, 8047, 8766, 8076, 8123, 8156, 8331, 33739, 8338,
            8348, 2197878, 34345, 746741, 3143, 8627, 8701, 8704, 8742, 8770, 8782, 8787, 8825, 8826, 8886, 35185, 51272,
            9100, 596205, 60842, 9260, 35636, 183379, 616739, 2559612, 9624, 9639, 2562176, 41996, 36437, 36676, 1547099,
            10318, 1490468, 10355, 10390, 37985, 10437, 10454, 10464, 38077, 10502, 10510, 31914, 38260, 314875, 38365,
            38404, 10734, 10737, 10767, 1314420, 10800, 10804, 10805, 10834, 10898, 21406, 11017, 1665222, 253206, 40254,
            39786, 1086769, 11256, 1455099, 2694828, 220982, 74667, 115698, 39993, 2669905
        ]
        def compute(self) -> list[Effect]:
            groups: dict[str, Group] = {}
            groups.setdefault("Psychiatry", Group(priority=100, items=[], name="Psychiatry"))
            for medication in self.event.context:
                for coding in medication["codings"]:
                    if coding["system"] == CodeSystems.RXNORM and int(coding["code"]) in self.medication_codes:
                        groups["Psychiatry"].items.append(medication)
                        break
            return [PatientChartGroup(items=groups).apply()]
    ```
##  Customize 
  - The protocol is extensible: additional groups or more refined code logic could be added in the future.   
----- END PAGE https://docs.canvasmedical.com/sdk/example-patient_summary_chart_groups/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-portal-customization-launch_application/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/example_patient_portal_page) for this plugin on GitHub. 
This plugin demonstrates how to embed custom patient facing content and tools to the Canvas patient portal. It provides an example of how to expose new patient-facing content or features, such as educational materials, forms, or interactive tools. On open, the plugin can launch an application and return effects to update the portal UI or patient data as needed.
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "example_patient_portal_page",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "url_permissions": [
            {
                "url": "https://www.canvasmedical.com/extensions",
                "permissions": ["ALLOW_SAME_ORIGIN", "SCRIPTS", "MICROPHONE", "CAMERA"]
            }
        ],
        "components": {
            "applications": [
                {
                    "class": "example_patient_portal_page.applications.my_application:MyApplication",
                    "name": "My Cool Tool",
                    "description": "Defines the menu item and what it should launch.",
                    "scope": "portal_menu_item",
                    "icon": "assets/icon.png"
                }
            ],
            "protocols": [
                {
                    "class": "example_patient_portal_page.handlers.my_web_app:MyWebApp",
                    "description": "Serves the application"
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  handlers/ 
###  my_web_app.py 
This file defines a simple web application, MyWebApp, that serves HTML, JavaScript, and CSS content.
**Authentication**
The app uses session credentials to check if a user is logged in before providing access to its endpoints. This is done in the authenticate method, which returns True only if a logged-in user exists.
**Endpoints**
  - **/app/patient-portal-application** : 
    - Retrieves the current logged-in Patient using an ID supplied in the request headers.
    - Renders an HTML template ("static/index.html") and supplies the patient's first and last name as context variables.
    - Returns a rendered HTML page as the response.
  - **/app/main.js** : 
    - Serves the contents of "static/main.js" as JavaScript.
  - **/app/styles.css** : 
    - Serves the contents of "static/styles.css" as CSS.
**Template Rendering**
All files (HTML, JS, CSS) are rendered using the Canvas SDK's render_to_string function, allowing the inclusion of dynamic server-side data, especially for the HTML response.
**Security**
Only authenticated (logged-in) users can access any endpoint. The app enforces this globally by overriding the authenticate method.
    ```python
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import HTMLResponse, Response
    from canvas_sdk.handlers.simple_api import SessionCredentials, SimpleAPI, api
    from canvas_sdk.templates import render_to_string
    from canvas_sdk.v1.data.patient import Patient
    #
    # Check out https://docs.canvasmedical.com/sdk/handlers-simple-api-http
    class MyWebApp(SimpleAPI):
        PREFIX = "/app"
        # Using session credentials allows us to ensure only logged in users can
        # access this.
        def authenticate(self, credentials: SessionCredentials) -> bool:
            return credentials.logged_in_user != None
        # Serve templated HTML
        @api.get("/patient-portal-application")
        def index(self) -> list[Response | Effect]:
            logged_in_user = Patient.objects.get(id=self.request.headers["canvas-logged-in-user-id"])
            context = {
                "first_name": logged_in_user.first_name,
                "last_name": logged_in_user.last_name,
            }
            return [
                HTMLResponse(
                    render_to_string("static/index.html", context),
                    status_code=HTTPStatus.OK,
                )
            ]
        # Serve the contents of a js file
        @api.get("/main.js")
        def get_main_js(self) -> list[Response | Effect]:
            return [
                Response(
                    render_to_string("static/main.js").encode(),
                    status_code=HTTPStatus.OK,
                    content_type="text/javascript",
                )
            ]
        # Serve the contents of a css file
        @api.get("/styles.css")
        def get_css(self) -> list[Response | Effect]:
            return [
                Response(
                    render_to_string("static/styles.css").encode(),
                    status_code=HTTPStatus.OK,
                    content_type="text/css",
                )
            ]
    ```
##  assets/ 
###  icon.png 
This icon is displayed in the portal menu.
##  applications/ 
###  my_application.py 
The code defines a custom application called `MyApplication`, which is the mechanism for registering the application in the portal menu..
**Key Functionality**
  - The core implementation is within the `on_open` method, which handles the application's "open" event.
  - When the application is opened, it triggers a launch effect (`LaunchModalEffect`) that opens an iframe modal.
  - The iframe modal displays the content found at the URL `/plugin-io/api/example_patient_portal_page/app/patient-portal-application`.
  - The effect specifically targets the main page area (`target=LaunchModalEffect.TargetType.PAGE`) for embedding.
  - The `on_open` method is a customization point where additional logic could be inserted—for example, dynamic URL selection based on application state or data.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class MyApplication(Application):
        """An embeddable application that can be registered to Canvas."""
        def on_open(self) -> Effect:
            """Handle the on_open event."""
            # Implement this method to handle the application on_open event.
            # You can look up data here to be used in knowing what to launch, if
            # what you're launching depends on some dynamic criteria.
            return LaunchModalEffect(
                # This URL is what will get iframed. It can be hosted elsewhere,
                # or it could be hosted by your plugin! Canvas plugins can serve
                # html, css, js, or json.
                #
                # If embedding a remote URL, be sure to declare it in the URL
                # permissions section of your plugin's CANVAS_MANIFEST.json
                url="/plugin-io/api/example_patient_portal_page/app/patient-portal-application",
                target=LaunchModalEffect.TargetType.PAGE,
            ).apply()
    ```
##  static/ 
###  main.js 
Static javascript referenced by the html template.
###  styles.css 
Stylesheets referenced by the html template.
###  index.html 
Templated HTML to render when the menu item is clicked.
----- END PAGE https://docs.canvasmedical.com/sdk/example-portal-customization-launch_application/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-portal-customization-widgets/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/patient_portal_plugin) for this plugin on GitHub. 
##  Description 
The Patient Portal Widgets Plugin provides various widgets for the patient portal. The plugin listens to the `PATIENT_PORTAL__WIDGET_CONFIGURATION` event.
##  Widgets 
###  Header Widget 
The Header Widget displays the patient's preferred name and has quick links for messaging and scheduling.
For more, visit the [Canvas SDK documentation](https://docs.canvasmedical.com/sdk/data-patient/)
###  Care Team Widget 
It is used to display a compact widget in the Patient Portal that lists the active care team members for a patient.
It renders a scrollable list in a compact plugin format of all active members.
For more information, visit the [Canvas SDK documentation](https://docs.canvasmedical.com/sdk/data-care-team/).
###  Footer Widget 
The Footer Widget displays the support contact information for the patient.
##  Secrets 
The Patient Portal Plugin uses the following secrets:
  - `BACKGROUND_COLOR`: The background color for the widgets. Defaults to `#17634d`.
  - `EMERGENCY_CONTACT`: The emergency contact information. Defaults to `1-888-555-5555`.
In order to deal with `SECRETS` take a look at the [SDK documentation](https://docs.canvasmedical.com/sdk/secrets/).
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "patient_portal_plugin",
        "description": "Patient Portal Plugin for Canvas",
        "components": {
            "protocols": [
                {
                    "class": "patient_portal_plugin.handlers.patient_portal_handler:PatientPortalHandler",
                    "description": "The handler that listens for the patient portal `PATIENT_PORTAL__WIDGET_CONFIGURATION` and responds with the patient portal widgets"
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [
            "BACKGROUND_COLOR",
            "EMERGENCY_CONTACT"
        ],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  templates/ 
###  care_team_widget.html 
###  header_widget.html 
###  footer_widget.html 
##  handlers/ 
###  patient_portal_handler.py 
**Purpose**
The code defines a handler, PatientPortalHandler, for the Canvas Medical SDK that renders custom widgets on the patient portal within Canvas. It listens for a specific widget configuration event and responds by displaying a set of widgets (header, care team, and footer) with certain configurable properties.
**Event Handling**
The handler is triggered (via RESPONDS_TO) when the event type PATIENT_PORTAL__WIDGET_CONFIGURATION occurs. When Canvas requests portal widget configuration for a patient, this handler gets called.
**Widgets Produced**
  - **Header Widget** : Collects basic patient information (first name, last name, etc.), constructs a "preferred full name," and passes it to an HTML template along with a configurable background color (using either a secret or a default).
  - **Care Team Widget** : Fetches the patient's active care team members. For each member, gathers name components, professional role, profile photo URL, and composes formatted display strings. This list is rendered in a compact widget, styled with the background color as a title color.
  - **Footer Widget** : Renders a footer using a background color and an emergency contact number, both customizable via secrets, falling back to sensible defaults if not specified.
**Widget Rendering**
For each widget, an appropriate HTML template is rendered with the relevant payload/context, and the widget is then wrapped as a PortalWidget with defined size and priority. These effects are returned as a list which the Canvas platform uses to display each widget on the patient portal.
**Customization and Defaults**
Two elements are customizable via the plugin's secrets dictionary:
  - BACKGROUND_COLOR: Sets the color for visual elements (widgets, titles).
  - EMERGENCY_CONTACT: Sets the emergency contact number in the footer.
If these are not provided, default values are used:
  - DEFAULT_BACKGROUND_COLOR = "#17634d"
  - DEFAULT_EMERGENCY_CONTACT = "1-888-555-5555"
**Summary**
This file enables a Canvas plugin to inject and style custom patient-facing widgets: a personalized header, a care team overview, and an emergency contact panel, all triggered when the platform requests configuration for the patient portal widgets. It leverages data models and template rendering of the Canvas SDK, with runtime customization via plugin secrets.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.templates import render_to_string
    from canvas_sdk.v1.data import Patient
    from canvas_sdk.v1.data.care_team import CareTeamMembership, CareTeamMembershipStatus
    # Inherit from BaseHandler to properly get registered for events
    class PatientPortalHandler(BaseHandler):
        """Handler responsible for rendering a patient portal widgets."""
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__WIDGET_CONFIGURATION)
        # Default background and title color for the portal's widgets if not provided in secrets
        DEFAULT_BACKGROUND_COLOR = "#17634d"
        # Default emergency contact number if not provided in secrets
        DEFAULT_EMERGENCY_CONTACT = "1-888-555-5555"
        def compute(self) -> list[Effect]:
            """This method gets called when an event of the type RESPONDS_TO is fired."""
            return [
                self.header_widget,
                self.care_team_widget,
                self.footer_widget,
            ]
        @property
        def header_widget(self) -> Effect:
            """Constructs the header widget for the patient portal."""
            # Get the patient needed fields to generate the preferred full name
            patient = Patient.objects.only("first_name", "last_name", "suffix", "nickname").get(id=self.target)
            payload = {
                "preferred_full_name": patient.preferred_full_name,
                "background_color": self.background_color,
            }
            header_widget = PortalWidget(
                content=render_to_string("templates/header_widget.html", payload),
                size=PortalWidget.Size.EXPANDED,
                priority=10,
            )
            return header_widget.apply()
        @property
        def care_team_widget(self) -> Effect:
            """Constructs the care team widget for the patient portal."""
            patient_care_team = CareTeamMembership.objects.values(
                "staff__first_name",
                "staff__last_name",
                "staff__prefix",
                "staff__suffix",
                "staff__photos__url",
                "role_display",
            ).filter(
                patient__id=self.target,
                status=CareTeamMembershipStatus.ACTIVE,
            )
            care_team = []
            for member in patient_care_team:
                # Aliasing the member's name components for clarity
                name = f"{member['staff__first_name']} {member['staff__last_name']}"
                prefixed_name = f"{member['staff__prefix']} " if member['staff__prefix'] else name
                professional_name = f"{prefixed_name}, {member['staff__suffix']}" if member['staff__suffix'] else prefixed_name
                photo_url = member['staff__photos__url']
                role = member['role_display']
                care_team.append(
                    {
                        "name": name,
                        "prefixed_name": prefixed_name,
                        "professional_name": professional_name,
                        "photo_url": photo_url,
                        "role": role,
                    }
                )
            payload = {
                "care_team": care_team,
                "title_color": self.background_color,
            }
            care_team_widget = PortalWidget(
                content=render_to_string("templates/care_team_widget.html", payload),
                size=PortalWidget.Size.COMPACT,
                priority=11,
            )
            return care_team_widget.apply()
        @property
        def footer_widget(self) -> Effect:
            """This method gets called when an event of the type RESPONDS_TO is fired."""
            return PortalWidget(
                content=render_to_string("templates/footer_widget.html", {
                    "background_color": self.background_color,
                    "emergency_contact": self.emergency_contact,
                }),
                size=PortalWidget.Size.EXPANDED,
                priority=12,
            ).apply()
        @property
        def background_color(self) -> str:
            """Get the background color from secrets, defaulting to a specific color if not set."""
            return self.secrets.get("BACKGROUND_COLOR") or self.DEFAULT_BACKGROUND_COLOR
        @property
        def emergency_contact(self) -> str:
            """Get the emergency contact from secrets, defaulting to a specific contact if not set."""
            return self.secrets.get("EMERGENCY_CONTACT") or self.DEFAULT_EMERGENCY_CONTACT
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-portal-customization-widgets/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-send_all_prescriptions/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/send_all_prescriptions) for this plugin on GitHub. 
A Canvas plugin that adds a "Send Prescriptions" button to note footers, allowing healthcare providers to send all committed prescriptions in a note with a single click.
##  SDK Features 
  - Creates an [ActionButton](/sdk/handlers-action-buttons/) that uses the [Note](/sdk/data-note/) context to get all committed prescribe [Commands](/sdk/data-command/) in a Note
  - Returns a list of [PrescribeCommand](sdk/commands/#prescribe) effects with [`send`](/sdk/commands/#send) action request
##  Structure 
    ```plaintext
    send_all_prescriptions/
    ├── CANVAS_MANIFEST.json          # Plugin configuration
    ├── README.md                     # Documentation
    ├── handlers/
    │   └── handler.py                # Defines SendPrescriptionButtonHandler class
    ```
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "1.0.0",
        "name": "send_all_prescriptions",
        "description": "Adds a 'Send Prescriptions' button to note footers that allows providers to send all committed prescriptions in a note with a single click, streamlining the prescription workflow.",
        "components": {
            "protocols": [
                {
                    "class": "send_all_prescriptions.handlers.handler:SendPrescriptionButtonHandler",
                    "description": "Action button that sends all committed prescriptions in the current note.",
                    "data_access": {
                        "event": "",
                        "read": [],
                        "write": []
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": ["https://docs.canvasmedical.com/sdk/handlers-action-buttons/", "https://docs.canvasmedical.com/sdk/commands/#prescribe"],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  handlers/ 
###  handler.py 
This file defines a custom button handler. It provides functionality to send all prescription commands associated with a specific note when the button is activated.
  - The main class, `SendPrescriptionButtonHandler`, inherits from `ActionButton` and represents a custom action button shown in the UI (specifically, at the note footer).
  - The button is labeled "Send Prescriptions" and assigned a unique key "SEND_ALL_PRESCRIPTIONS".
**Button Handling Logic**
  - The `handle` method is the core logic, executed when the user clicks the button.
  - It obtains the `note_id` from the plugin execution context (self.context).
  - It queries the database for all commands of type `"prescribe"` that are committed (i.e., have an associated committer) and belong to the given note.
  - For each qualifying command, it creates a `PrescribeCommand`, sets its UUID to match the command, and calls `send()`, which returns an `Effect`.
  - All created effects are collected into a list and returned; these effects trigger the actual process of sending prescriptions.
    ```python
    from canvas_sdk.commands import PrescribeCommand
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.v1.data import Command
    class SendPrescriptionButtonHandler(ActionButton):
        BUTTON_TITLE = "Send Prescriptions"
        BUTTON_KEY = "SEND_ALL_PRESCRIPTIONS"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_FOOTER
        def handle(self) -> list[Effect]:
            note_id = self.context.get("note_id")
            effects = []
            # get all committed prescribe commands
            prescribe_commands = Command.objects.filter(note_id=note_id, schema_key="prescribe", committer__isnull=False)
            for command in prescribe_commands:
                prescribe = PrescribeCommand()
                prescribe.command_uuid = str(command.id)
                effects.append(prescribe.send())
            return effects
    ```
##  Customization 
###  Button Appearance 
You can customize the button by modifying the class attributes:
    ```python
    BUTTON_TITLE = "Your Custom Title"    # Change button text
    BUTTON_KEY = "YOUR_UNIQUE_KEY"        # Change button identifier
    ```
###  Button Location 
Change where the button appears by modifying:
    ```python
    BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_FOOTER  # or other locations
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-send_all_prescriptions/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-sendgrid_email/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/sendgrid_email) for this plugin on GitHub. 
##  Description 
Plugin that provides a SimpleAPI for sending emails, querying sent emails, managing inbound and outbound webhooks, and handling email status callbacks using the Canvas SDK's SendGrid client. It supports inline images, file attachments, inbound email parsing, and outbound event tracking. Includes a chart application that renders a form interface for email management directly from the chart.
##  Configuration 
This example plugin defines the following "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "SendgridAPIKey"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  SendgridAPIKey 
Your [SendGrid API key](https://docs.sendgrid.com/ui/account-and-settings/api-keys).
##  CANVAS_MANIFEST.json 
    ```json
    {
      "sdk_version": "0.85.0",
      "plugin_version": "0.0.1",
      "name": "email_sender",
      "description": "use Sendgrid to send emails, retrieve sent emails, manage inbound and outbound webhooks",
      "components": {
        "protocols": [
          {
            "class": "email_sender.handlers.email_manip:EmailManip",
            "description": "Emails with Sendgrid"
          }
        ],
        "applications": [
          {
            "class": "email_sender.handlers.email_form_app:EmailFormApp",
            "name": "Emails Sendgrid",
            "description": "Emails with Sendgrid",
            "icon": "static/email_sender.png",
            "scope": "patient_specific",
            "show_in_panel": false
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [
        "SendgridAPIKey"
      ],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
    ```
##  handlers/ 
###  email_manip.py 
**Purpose**
This code defines a SimpleAPI handler that exposes REST endpoints for managing email operations via the Canvas SDK's SendGrid client.
**Class Overview**
  - The main class, `EmailManip`, extends `SimpleAPI`.
  - It creates a SendGrid `EmailClient` using an API key stored in plugin secrets.
  - It uses the plugin cache system for storing webhook callback data.
**Main Workflow**
  - `POST /send_email` — Sends an email with optional inline images and file attachments.
  - `POST /emails_sent` — Queries sent emails with optional filters for recipient and date.
  - `GET /email_events/<message_id>` — Retrieves email events for a specific message.
  - `POST /inbound_webhook` — Enables/disables the SendGrid inbound parse webhook.
  - `GET /inbound_webhook` — Gets the current inbound webhook configuration status.
  - `POST /outbound_webhook` — Enables/disables the SendGrid outbound event webhook.
  - `GET /outbound_webhook` — Gets the current outbound webhook configuration status.
  - `POST /inbound_email` — Receives and caches parsed inbound emails from SendGrid.
  - `GET /inbound_email` — Retrieves the most recent inbound email from cache.
  - `POST /outbound_email_status` — Receives and caches outbound email status events.
  - `GET /outbound_email_status` — Retrieves the most recent outbound status events from cache.
**SendGrid Client Integration**
  - The `_sendgrid_client` method creates an `EmailClient` instance from `canvas_sdk.clients.sendgrid.libraries`.
  - Email composition uses structured types: `Address`, `Recipient`, `BodyContent`, `Attachment`, and `Email`.
  - Error handling uses the `RequestFailed` exception from the SendGrid client structures.
    ```python
    from datetime import UTC, datetime, timedelta
    from http import HTTPStatus
    from email_sender.constants.constants import Constants
    from canvas_sdk.caching.plugins import get_cache
    from canvas_sdk.clients.sendgrid.constants import (
        CriterionOperation,
        RecipientType,
    )
    from canvas_sdk.clients.sendgrid.libraries import EmailClient
    from canvas_sdk.clients.sendgrid.structures import (
        Address,
        Attachment,
        BodyContent,
        CriterionDatetime,
        Email,
        EmailEvent,
        EventWebhook,
        LoggedEmailCriteria,
        ParsedEmail,
        ParseSetting,
        Recipient,
        RequestFailed,
        Settings,
    )
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPI, api
    from logger import log
    class EmailManip(SimpleAPI):
        """API handler for SendGrid email operations including sending, webhooks, and logging."""
        PREFIX = None
        def authenticate(self, credentials: Credentials) -> bool:
            """Authenticate the API request. Always returns True (no authentication required)."""
            return True
        def _sendgrid_client(self) -> EmailClient:
            """Create and return a configured SendGrid email client."""
            settings = Settings(key=self.secrets[Constants.sendgrid_api_key])
            return EmailClient(settings)
        @api.get("/email_events/<message_id>")
        def email_events(self) -> list[Response | Effect]:
            """Retrieve email events for a specific message ID from SendGrid."""
            message_id = self.request.path_params["message_id"]
            client = self._sendgrid_client()
            try:
                result = [
                    JSONResponse(
                        client.logged_email(message_id).to_dict(),
                        status_code=HTTPStatus(HTTPStatus.OK),
                    )
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.post("/emails_sent")
        def emails_sent(self) -> list[Response | Effect]:
            """Query sent emails from SendGrid with optional filters for recipient and date."""
            content = self.request.json()
            to_email = content.get("emailTo")
            on_day = content.get("onDay")
            max_logs = content.get("maxLogs")
            client = self._sendgrid_client()
            try:
                message_created_at = []
                if on_day:
                    date_time = datetime.strptime(on_day, "%Y-%m-%d")
                    message_created_at = [
                        CriterionDatetime(
                            date_time=date_time,
                            operation=CriterionOperation.GREATER_THAN_OR_EQUAL,
                        ),
                    ]
                    next_date = date_time + timedelta(days=1)
                    if next_date < datetime.now():
                        message_created_at.append(
                            CriterionDatetime(
                                date_time=next_date,
                                operation=CriterionOperation.LOWER_THAN_OR_EQUAL,
                            )
                        )
                criteria = LoggedEmailCriteria(
                    message_id="",
                    subject="",
                    to_email=to_email,
                    reason="",
                    status=[],
                    message_created_at=message_created_at,
                )
                result = [
                    JSONResponse(
                        [email.to_dict() for email in client.logged_emails(criteria, max_logs)],
                        status_code=HTTPStatus(HTTPStatus.OK),
                    )
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.post("/send_email")
        def send_email(self) -> list[Response | Effect]:
            """Send an email via SendGrid with optional inline images and attachments."""
            content = self.request.json()
            email_from = content.get("emailFrom")
            email_to = content.get("emailTo")
            email_cc = content.get("emailCc")
            subject = content.get("subject")
            body = content.get("body")
            inline_url = content.get("inlineUrl")
            attachment_url = content.get("attachmentUrl")
            client = self._sendgrid_client()
            try:
                sender = Address(email=email_from, name="Sender")
                reply_tos = [Address(email=email_from, name="ReplyTo")]
                recipients = [
                    Recipient(address=Address(email=email_to, name="RecTo"), type=RecipientType.TO)
                ]
                if email_cc:
                    cc = Recipient(address=Address(email=email_cc, name="RecCc"), type=RecipientType.CC)
                    recipients.append(cc)
                subject = f"{subject} - {datetime.now(UTC).strftime('%H:%M:%S')}"
                bodies = [BodyContent(type="text/plain", value=body)]
                attachments = []
                if inline_url:
                    attached = Attachment.from_url_inline(
                        inline_url, {}, "inline_picture.png", "pictureId"
                    )
                    attachments.append(attached)
                    html_body = BodyContent(
                        type="text/html",
                        value=f"<html><body>{body}<br/>"
                        '<img src="cid:pictureId" width="200px"/><br/>'
                        "Bye!</body></html>",
                    )
                    bodies.append(html_body)
                if attachment_url:
                    attached = Attachment.from_url(attachment_url, {}, "attached_picture.png")
                    attachments.append(attached)
                email = Email(
                    sender=sender,
                    reply_tos=reply_tos,
                    recipients=recipients,
                    subject=subject,
                    bodies=bodies,
                    attachments=attachments,
                    send_at=Email.now(),
                )
                result = [
                    JSONResponse(
                        {"successful": client.simple_send(email)},
                        status_code=HTTPStatus(HTTPStatus.OK),
                    )
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        def parser_url(self) -> str:
            """Build the URL for the inbound email parser webhook endpoint."""
            host = f"https://{self.environment[Constants.customer_identifier]}.canvasmedical.com"
            return f"{host}{Constants.plugin_api_base_route}/inbound_email"
        @api.post("/inbound_webhook")
        def inbound_webhook_toggle(self) -> list[Response | Effect]:
            """Enable or disable the SendGrid inbound parse webhook."""
            content = self.request.json()
            enabled = content.get("enabled")
            hostname = content.get("hostname")
            client = self._sendgrid_client()
            try:
                result = [JSONResponse({"enabled": enabled}, status_code=HTTPStatus(HTTPStatus.OK))]
                parser_url = self.parser_url()
                parsers = [
                    parser.hostname
                    for parser in client.parser_setting_list()
                    if parser.url == parser_url
                ]
                if enabled and not parsers:
                    setting = ParseSetting(
                        url=self.parser_url(),
                        hostname=hostname,
                        spam_check=True,
                        send_raw=False,
                    )
                    client.parser_setting_add(setting)
                if not enabled and parsers:
                    client.parser_setting_delete(parsers[0])
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.get("/inbound_webhook")
        def inbound_webhook_get(self) -> list[Response | Effect]:
            """Get the current status of the inbound parse webhook configuration."""
            client = self._sendgrid_client()
            try:
                parser_url = self.parser_url()
                parsers = [
                    parser for parser in client.parser_setting_list() if parser.url == parser_url
                ]
                response = {"enabled": bool(parsers), "hostname": ""}
                if parsers:
                    response["hostname"] = parsers[0].hostname
                result = [JSONResponse(response, status_code=HTTPStatus(HTTPStatus.OK))]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        def webhook_url(self) -> str:
            """Build the URL for the outbound email status webhook endpoint."""
            host = f"https://{self.environment[Constants.customer_identifier]}.canvasmedical.com"
            return f"{host}{Constants.plugin_api_base_route}/outbound_email_status"
        @api.post("/outbound_webhook")
        def outbound_webhook_toggle(self) -> list[Response | Effect]:
            """Enable or disable the SendGrid outbound event webhook."""
            content = self.request.json()
            enabled = content.get("enabled")
            client = self._sendgrid_client()
            try:
                result = [JSONResponse({"enabled": enabled}, status_code=HTTPStatus(HTTPStatus.OK))]
                webhook_url = self.webhook_url()
                webhook_ids = [
                    webhook.id for webhook in client.event_webhook_list() if webhook.url == webhook_url
                ]
                if enabled and not webhook_ids:
                    event = EventWebhook(
                        url=webhook_url,
                        enabled=True,
                        group_resubscribe=False,
                        group_unsubscribe=False,
                        delivered=True,
                        spam_report=True,
                        bounce=True,
                        unsubscribe=False,
                        processed=True,
                        open=True,
                        click=True,
                        dropped=True,
                        friendly_name="Canvas Plugin Webhook",
                    )
                    client.event_webhook_add(event)
                if not enabled and webhook_ids:
                    client.event_webhook_delete(webhook_ids[0])
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.get("/outbound_webhook")
        def outbound_webhook_get(self) -> list[Response | Effect]:
            """Get the current status of the outbound event webhook configuration."""
            client = self._sendgrid_client()
            try:
                webhook_url = self.webhook_url()
                enabled = any(
                    webhook.id for webhook in client.event_webhook_list() if webhook.url == webhook_url
                )
                result = [JSONResponse({"enabled": enabled}, status_code=HTTPStatus(HTTPStatus.OK))]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.get("/outbound_email_status")
        def last_outbound_status(self) -> list[Response | Effect]:
            """Retrieve the most recent outbound email status events from cache."""
            return [
                JSONResponse(
                    self.cache_retrieve("outbound_email_status"), status_code=HTTPStatus(HTTPStatus.OK)
                )
            ]
        @api.post("/outbound_email_status")
        def outbound_status_save(self) -> list[Response | Effect]:
            """Receive and cache outbound email status events from SendGrid webhook."""
            events = [EmailEvent.from_dict(item) for item in self.request.json()]
            self.cache_save("outbound_email_status", [e.to_dict() for e in events])
            log.info(f"outbound status received:{len(events)}")
            return [Response(status_code=HTTPStatus(HTTPStatus.OK))]
        @api.get("/inbound_email")
        def last_inbound_email(self) -> list[Response | Effect]:
            """Retrieve the most recent inbound email from cache."""
            return [
                JSONResponse(
                    self.cache_retrieve("inbound_treatment"),
                    status_code=HTTPStatus(HTTPStatus.OK),
                )
            ]
        @api.post("/inbound_email")
        def inbound_email_save(self) -> list[Response | Effect]:
            """Receive and cache parsed inbound emails from SendGrid webhook."""
            form = self.request.form_data()
            message = {}
            files = []
            for key, value in form.multi_items():
                if (
                    hasattr(value, "file")
                    and hasattr(value, "filename")
                    and hasattr(value, "content_type")
                ):
                    files.append((key, value))
                else:
                    if hasattr(value, "value"):
                        message[key] = value.value
                    elif isinstance(value, str):
                        message[key] = value
                    else:
                        message[key] = str(value)
            parsed = ParsedEmail.from_dict(message)
            self.cache_save("inbound_treatment", [parsed.to_dict()])
            log.info(f"inbound email received from {parsed.email_from} to {parsed.email_to}")
            return [Response(status_code=HTTPStatus(HTTPStatus.OK))]
        @classmethod
        def cache_save(cls, key: str, payload: list) -> None:
            """Store a payload in the plugin cache under the given key."""
            get_cache().set(key, payload)
        @classmethod
        def cache_retrieve(cls, key: str) -> list:
            """Retrieve a cached payload by key, returning an empty list if not found."""
            return get_cache().get(key) or []
    ```
###  email_form_app.py 
**Purpose**
This code defines an Application handler that launches a modal form in the right chart pane for interacting with the SendGrid email API endpoints.
    ```python
    from email_sender.constants.constants import Constants
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    from canvas_sdk.templates import render_to_string
    class EmailFormApp(Application):
        """Application handler that displays the email sender form in a modal."""
        def on_open(self) -> Effect:
            """Render and launch the email form modal in the right chart pane."""
            content = render_to_string(
                "templates/email_form.html",
                {
                    "sendEmailURL": f"{Constants.plugin_api_base_route}/send_email",
                    "emailsSentURL": f"{Constants.plugin_api_base_route}/emails_sent",
                    "emailEventsURL": f"{Constants.plugin_api_base_route}/email_events",
                    "outboundWebhookURL": f"{Constants.plugin_api_base_route}/outbound_webhook",
                    "outboundStatusesURL": f"{Constants.plugin_api_base_route}/outbound_email_status",
                    "inboundWebhookURL": f"{Constants.plugin_api_base_route}/inbound_webhook",
                    "inboundEmailURL": f"{Constants.plugin_api_base_route}/inbound_email",
                },
            )
            return LaunchModalEffect(
                content=content,
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-sendgrid_email/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-twilio_sms_mms/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/twilio_sms_mms) for this plugin on GitHub. 
##  Description 
Plugin that provides a SimpleAPI for sending and receiving SMS/MMS messages using the Canvas SDK's Twilio client. It supports listing phone numbers, sending messages, retrieving message history and media, managing inbound webhooks, handling delivery status callbacks, and auto-replying to inbound messages. Includes a chart application that renders a form interface for SMS management directly from the chart.
##  Configuration 
This example plugin defines the following "secrets" in the manifest file:
    ```plaintext
        "secrets": [
            "TwilioAccountSID",
            "TwilioAPIKey",
            "TwilioAPISecret"
        ],
    ```
Once defined in the `MANIFEST.json`, set the secrets for your plugin in the Admin UI of your Canvas EMR. [Read more](https://docs.canvasmedical.com/sdk/secrets/)
###  TwilioAccountSID 
Your [Twilio Account SID](https://www.twilio.com/docs/iam/api/account).
###  TwilioAPIKey 
Your [Twilio API Key SID](https://www.twilio.com/docs/iam/api-keys).
###  TwilioAPISecret 
Your [Twilio API Key Secret](https://www.twilio.com/docs/iam/api-keys).
##  CANVAS_MANIFEST.json 
    ```json
    {
      "sdk_version": "0.85.0",
      "plugin_version": "0.0.1",
      "name": "twilio_sms_mms",
      "description": "use Twillio to send and receive SMS/MMS",
      "components": {
        "protocols": [
          {
            "class": "twilio_sms_mms.handlers.sms_manip:SmsManip",
            "description": "SMS/MMS with Twilio"
          }
        ],
        "applications": [
          {
            "class": "twilio_sms_mms.handlers.sms_form_app:SmsFormApp",
            "name": "SMS Twilio",
            "description": "SMS/MMS with Twilio",
            "icon": "static/twilio_sms_mms.png",
            "scope": "patient_specific",
            "show_in_panel": false
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [
        "TwilioAccountSID",
        "TwilioAPIKey",
        "TwilioAPISecret"
      ],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
    ```
##  handlers/ 
###  sms_manip.py 
**Purpose**
This code defines a SimpleAPI handler that exposes REST endpoints for managing SMS/MMS operations via the Canvas SDK's Twilio client.
**Class Overview**
  - The main class, `SmsManip`, extends `StaffSessionAuthMixin` and `SimpleAPI`.
  - It creates a Twilio `SmsClient` using credentials stored in plugin secrets (Account SID, API Key, API Secret).
**Main Workflow**
  - `GET /phone_list` — Retrieves all phone numbers associated with the Twilio account, including capabilities and webhook configuration.
  - `GET /message_list/<number>/<direction>` — Lists messages for a specific phone number filtered by direction (from/to).
  - `GET /message/<message_sid>` — Retrieves details of a specific message.
  - `GET /medias/<message_sid>` — Retrieves all media attachments for a specific message.
  - `DELETE /message_delete/<message_sid>` — Deletes a specific message.
  - `POST /sms_send` — Sends an SMS message with optional status callback URL.
  - `POST /inbound_webhook/<phone_sid>` — Configures the inbound webhook URL for a Twilio phone number.
  - `POST /outbound_api_status` — Handles status callbacks for outbound SMS messages.
  - `POST /inbound_treatment` — Processes incoming messages and sends automatic replies with optional media.
**Twilio Client Integration**
  - The `_twillio_client` method creates an `SmsClient` instance from `canvas_sdk.clients.twilio.libraries`.
  - Error handling uses the `RequestFailed` exception from the Twilio client structures.
  - Inbound message handling generates TwiML responses for automatic replies.
    ```python
    from http import HTTPStatus
    from canvas_sdk.clients.twilio.constants import DateOperation, HttpMethod
    from canvas_sdk.clients.twilio.libraries import SmsClient
    from canvas_sdk.clients.twilio.structures import (
        RequestFailed,
        Settings,
        SmsMms,
        StatusInbound,
        StatusOutboundApi,
    )
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import HTMLResponse, JSONResponse, Response
    from canvas_sdk.handlers.simple_api import SimpleAPI, StaffSessionAuthMixin, api
    from logger import log
    from ..constants.constants import Constants
    class SmsManip(StaffSessionAuthMixin, SimpleAPI):
        """API handler for Twilio SMS/MMS operations."""
        PREFIX = None
        def _twillio_client(self) -> SmsClient:
            """Create and configure a Twilio SMS client."""
            settings = Settings(
                account_sid=self.secrets[Constants.twillio_account_sid],
                key=self.secrets[Constants.twillio_api_key],
                secret=self.secrets[Constants.twillio_api_secret],
            )
            return SmsClient(settings)
        @api.get("/phone_list")
        def phone_list(self) -> list[Response | Effect]:
            """Retrieve the list of phone numbers associated with the Twilio account."""
            client = self._twillio_client()
            try:
                result = [
                    JSONResponse(
                        [
                            {
                                "sid": p.sid,
                                "phoneNumber": p.phone_number,
                                "label": p.friendly_name,
                                "capabilities": p.capabilities.to_dict(),
                                "statusCallback": p.status_callback,
                                "status": p.status,
                                "inboundWebhook": {
                                    "url": p.sms_url,
                                    "method": p.sms_method.value,
                                },
                            }
                            for p in client.account_phone_numbers()
                        ],
                        status_code=HTTPStatus(HTTPStatus.OK),
                    ),
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.get("/message_list/<number>/<direction>")
        def message_list(self) -> list[Response | Effect]:
            """Retrieve a list of messages for a specific phone number."""
            number = self.request.path_params["number"]
            direction = self.request.path_params["direction"]
            number_from = number if direction == "from" else ""
            number_to = number if direction == "to" else ""
            client = self._twillio_client()
            try:
                result = [
                    JSONResponse(
                        [
                            {
                                "sid": p.sid,
                                "sent": p.date_sent.isoformat(),
                                "status": p.status.value,
                                "mediaCount": p.count_media,
                            }
                            for p in client.retrieve_all_sms(
                                number_to, number_from, "", DateOperation.ON_EXACTLY
                            )
                        ],
                        status_code=HTTPStatus(HTTPStatus.OK),
                    ),
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.get("/message/<message_sid>")
        def message(self) -> list[Response | Effect]:
            """Retrieve details of a specific message."""
            message_sid = self.request.path_params["message_sid"]
            client = self._twillio_client()
            try:
                result = [
                    JSONResponse(
                        client.retrieve_sms(message_sid).to_dict(),
                        status_code=HTTPStatus(HTTPStatus.OK),
                    ),
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.get("/medias/<message_sid>")
        def media_list(self) -> list[Response | Effect]:
            """Retrieve all media attachments for a specific message."""
            message_sid = self.request.path_params["message_sid"]
            client = self._twillio_client()
            try:
                result = [
                    Response(
                        content_type=p.content_type,
                        content=client.retrieve_raw_media(message_sid, p.sid),
                    )
                    for p in client.retrieve_media_list(message_sid)
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.delete("/message_delete/<message_sid>")
        def message_delete(self) -> list[Response | Effect]:
            """Delete a specific message from Twilio."""
            message_sid = self.request.path_params["message_sid"]
            client = self._twillio_client()
            try:
                result = [
                    JSONResponse(
                        {
                            "sid": message_sid,
                            "deleted": client.delete_sms(message_sid),
                        },
                        status_code=HTTPStatus(HTTPStatus.OK),
                    )
                ]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.post("/inbound_webhook/<phone_sid>")
        def inbound_webhook(self) -> list[Response | Effect]:
            """Configure the inbound webhook URL for a Twilio phone number."""
            phone_sid = self.request.path_params["phone_sid"]
            content = self.request.json()
            webhook_url = content["url"]
            method = HttpMethod(content["method"])
            client = self._twillio_client()
            try:
                response = client.set_inbound_webhook(phone_sid, webhook_url, method)
                result = [JSONResponse({"result": response}, status_code=HTTPStatus(HTTPStatus.OK))]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.post("/sms_send")
        def sms_send(self) -> list[Response | Effect]:
            """Send an SMS message via Twilio."""
            content = self.request.json()
            number_from = content.get("numberFrom")
            number_from_id = content.get("numberFromSid")
            number_to = content.get("numberTo")
            callback_url = content.get("callbackUrl")
            text = content.get("text")
            client = self._twillio_client()
            try:
                sms_mms = SmsMms(
                    number_from=number_from,
                    number_from_sid=number_from_id,
                    number_to=number_to,
                    message=text,
                    media_url="",
                    status_callback_url=callback_url,
                )
                response = client.send_sms_mms(sms_mms)
                result = [JSONResponse(response.to_dict(), status_code=HTTPStatus(HTTPStatus.OK))]
            except RequestFailed as e:
                result = [
                    JSONResponse({"information": e.message}, status_code=HTTPStatus(e.status_code))
                ]
            return result
        @api.post("/outbound_api_status")
        def outbound_api_status(self) -> list[Response | Effect]:
            """Handle status callbacks for outbound SMS messages."""
            status = StatusOutboundApi.callback_outbound_api(self.request.text())
            log.info(f"sms_extern: sid/status: {status.sms_sid}/{status.sms_status}")
            return [Response(status_code=HTTPStatus(HTTPStatus.OK))]
        @api.post("/inbound_treatment")
        def inbound_treatment(self) -> list[Response | Effect]:
            """Handle inbound SMS messages with automatic replies."""
            inbound = StatusInbound.callback_inbound(self.request.text())
            if "hello" in inbound.body.lower():
                reply = "Hello!"
                image = "<Media>https://img.freepik.com/free-psd/hand-drawn-summer-frame-illustration_23-2151631028.jpg</Media>"
            else:
                reply = "Say hello!"
                image = ""
            response = (
                '<?xml version="1.0" encoding="UTF-8"?>\n'
                "<Response>"
                f"<Message><Body>{reply}</Body>{image}</Message>"
                "</Response>"
            )
            return [
                HTMLResponse(
                    content=response,
                    status_code=HTTPStatus(HTTPStatus.OK),
                )
            ]
    ```
###  sms_form_app.py 
**Purpose**
This code defines an Application handler that launches a modal form in the right chart pane for interacting with the Twilio SMS/MMS API endpoints.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    from canvas_sdk.templates import render_to_string
    from ..constants.constants import Constants
    class SmsFormApp(Application):
        """Application handler for the SMS/MMS form interface."""
        def on_open(self) -> Effect:
            """Render and launch the SMS form modal in the right chart pane."""
            host = f"https://{self.environment[Constants.customer_identifier]}.canvasmedical.com"
            content = render_to_string(
                "templates/sms_form.html",
                {
                    "smsSendURL": f"{Constants.plugin_api_base_route}/sms_send",
                    "phoneListURL": f"{Constants.plugin_api_base_route}/phone_list",
                    "setInboundWebhookURL": f"{Constants.plugin_api_base_route}/inbound_webhook",
                    "messageListURL": f"{Constants.plugin_api_base_route}/message_list",
                    "messageURL": f"{Constants.plugin_api_base_route}/message",
                    "mediaURL": f"{Constants.plugin_api_base_route}/medias",
                    "deleteMessageURL": f"{Constants.plugin_api_base_route}/message_delete",
                    "defaultCallbackURL": f"{host}{Constants.plugin_api_base_route}/outbound_api_status",
                },
            )
            return LaunchModalEffect(
                content=content,
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            ).apply()
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-twilio_sms_mms/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-upsert_patient_metadata/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/upsert_patient_metadata) for this plugin on GitHub. 
This plugin showcases how to store patient metadata key/value pairs from a plugin using the Canvas SDK.
In this example, we extract key-value pairs from a plan command's narrative and store them as patient metadata.
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "upsert_patient_metadata",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "components": {
            "protocols": [
                {
                    "class": "upsert_patient_metadata.protocols.my_protocol:Protocol",
                    "description": "A protocol that does xyz..."
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
##  protocols/ 
###  my_protocol.py 
This file defines a Canvas plugin handler that uses the update of a plan command as an excuse to trigger. When a user updates a plan command and includes certain key-value data in the narrative, this handler extracts that information and saves it as patient metadata.
**Narrative Parsing**
The protocol retrieves the narrative text from the event context. It uses regular expressions to look for patterns of the form:
  - `key=somekey`
  - `value=somevalue`
The separator between key/value and their contents can be any character except alphanumerics, underscores, asterisks, hashes, or whitespace. For example, `key=blood_pressure*value=120/80`.
**Action Taken**
If both a key and value are found in the narrative:
  - It logs an informational message including the patient id, key, and value.
  - It returns a list containing one Effect: an upsert (create or update) of patient metadata (via PatientMetadata) for that patient, saving the found key and value.
If either the key or value is missing, no action is performed.
    ```python
    import re
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient_metadata import PatientMetadata
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from logger import log
    class Protocol(BaseHandler):
        """
        Extracts key-value pairs from plan update narratives and stores them as patient metadata.
        Parses narrative text for patterns like "key=somekey*value=somevalue" where the separator
        can be any non-alphanumeric character. If both key and value are found, creates or updates
        the corresponding patient metadata entry.
        Triggers on: PLAN_COMMAND__POST_UPDATE events
        Effects: PatientMetadata upsert operations
        """
        RESPONDS_TO = EventType.Name(EventType.PLAN_COMMAND__POST_UPDATE)
        def compute(self) -> list[Effect]:
            """This method gets called when an event of the type RESPONDS_TO is fired."""
            patient_id = self.context["patient"]["id"]
            fields = self.context.get("fields", {})
            narrative = fields.get("narrative", "")
            key_match = re.search(r"key=([^*#_\s]+)", narrative)
            value_match = re.search(r"value=([^*#_\s]+)", narrative)
            key = key_match.group(1) if key_match else None
            value = value_match.group(1) if value_match else None
            log.info(
                f"Upserting patient metadata for patient {patient_id} with key: {key} and value: {value}"
            )
            if not key or not value:
                return []
            return [PatientMetadata(patient_id=patient_id, key=str(key)).upsert(str(value))]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-upsert_patient_metadata/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/example-vitals_visualizer_plugin/
> **Note:** [View the source](https://github.com/canvas-medical/canvas-plugins/tree/main/example-plugins/vitals_visualizer_plugin) for this plugin on GitHub. 
A Canvas plugin that displays a "Visualize" button in the vitals section of the chart summary and shows interactive vital signs visualizations.
##  SDK Features 
  - Creates and responds to a [Simple API](/sdk/handlers-simple-api-http/) endpoint that [renders a template](/sdk/layout-effect/#custom-html-and-django-templates) and returns HTML content
  - Parses [Observation data model](/sdk/data-observation/) to obtain vitals data and format into readable content
  - Adds a "Visualize" [Action Button](/sdk/handlers-action-buttons/) to the vitals section of the patient chart summary.
  - Returns a [LaunchModalEffect](/sdk/layout-effect/#modals) in the right chart pane with content from the vitals endpoint.
##  Configuration 
This SimpleAPI endpoint uses the [StaffSessionAuthMixin](/sdk/handlers-simple-api-http/#staff-session)
##  Structure 
    ```plaintext
    vitals_visualizer_plugin/
    ├── handlers/
    │   ├── __init__.py
    │   ├── vitals_button.py      # Action button handler
    │   └── vitals_api.py         # API endpoint with visualization
    ├── templates/
    │   └── vitals_visualization.html # HTML template for visualization UI
    ├── CANVAS_MANIFEST.json      # Plugin configuration
    └── README.md                 # Documentation
    ```
##  CANVAS_MANIFEST.json 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.1.0",
        "name": "vitals_visualizer_plugin",
        "description": "A plugin that adds visualization capabilities to patient vital signs in the chart summary",
        "components": {
            "protocols": [
                {
                    "class": "vitals_visualizer_plugin.handlers.vitals_button:VitalsVisualizerButton",
                    "description": "A button that opens vitals visualization modal",
                    "data_access": {
                        "event": "SHOW_CHART_SUMMARY_VITALS_SECTION_BUTTON",
                        "read": ["v1.Observation"],
                        "write": []
                    }
                },
                {
                    "class": "vitals_visualizer_plugin.handlers.vitals_api:VitalsVisualizerAPI",
                    "description": "API endpoint that serves vitals visualization data and UI",
                    "data_access": {
                        "event": "",
                        "read": ["v1.Observation"],
                        "write": []
                    }
                }
            ],
            "commands": [],
            "content": [],
            "effects": [],
            "views": []
        },
        "secrets": [],
        "tags": [],
        "license": "NONE",
        "readme": "./README.md"
    }
    ```
##  templates/ 
###  vitals_visualization.html 
This is the html template called by the[ `render_to_string` function](/sdk/layout-effect/#custom-html-and-django-templates) with a `vitals_data` object. It contains styling and custom JavaScript to form the chart.
##  handlers/ 
###  vitals_api.py 
The `vitals_api.py` file defines a class-based API endpoint called `VitalsVisualizerAPI` for a Canvas Medical plugin. This endpoint provides both a user interface (HTML) and data (as JSON) for visualizing patient vitals—specifically weight, body temperature, and oxygen saturation.
  - **API Endpoint** : The endpoint is accessed at `/visualize`, and requires staff authentication via `StaffSessionAuthMixin`.
  - **Request Handling** : The main entry point is the `get()` method, which expects a `patient_id` as a query parameter. 
    - If `patient_id` is missing, it returns a 400 JSON error response.
    - If present, it fetches and compiles the patient's vital sign data, then generates and returns an HTML interface for visualization.
  - **Vitals Data Extraction** : The `_get_vitals_data(patient_id)` method: 
    - Queries Canvas Medical's `Observation` resource for the specified patient.
    - Filters for observations in the "vital-signs" category that are not deleted, not entered in error, and are not "Vital Signs Panel" summary records.
    - Extracts individual observations for: 
      - **Weight** (converting from ounces to pounds),
      - **Body Temperature** (with default units °F if missing),
      - **Oxygen Saturation** (with default units % if missing).
    - Organizes the data into a dictionary keyed by vital sign name, each containing a list of timestamped values.
  - **HTML Visualization Rendering** : The `_generate_visualization_html(vitals_data)` method: 
    - Serializes the vitals data as JSON.
    - Passes it as context to a template called `vitals_visualization.html` for rendering the UI.
  - **Error Handling and Logging** : All major steps have try/except blocks, logging errors and returning JSON error responses if needed.
**How the Components Work Together**
  - The endpoint provides a combined UI/data interface for staff to review prescribed vitals over time for a selected patient.
  - The code is built for integration into the Canvas Medical system utilizing their SDK, data models, and permission system.
  - All HTML and logic for visualization are rendered server-side using a templating mechanism.
**Dependencies and Assumptions**
  - Depends on `Observation` model/data from Canvas Medical's API SDK.
  - Uses Canvas SDK facilities for routing, API responses, session authentication, and template rendering.
  - Relies on templates being in the `templates/` folder, specifically one for vitals visualization.
  - Expects a structured logging setup.
**Returned Data Types**
  - Templated HTML (for visualization) or JSON (for errors), wrapped in Canvas SDK response objects (`HTMLResponse`, `JSONResponse`).
    ```python
    import json
    from typing import Any, Dict, List
    from canvas_sdk.effects.simple_api import HTMLResponse, JSONResponse
    from canvas_sdk.handlers.simple_api import SimpleAPIRoute, StaffSessionAuthMixin
    from canvas_sdk.templates import render_to_string
    from canvas_sdk.v1.data import Observation
    from logger import log
    class VitalsVisualizerAPI(StaffSessionAuthMixin, SimpleAPIRoute):
        """API endpoint that serves vitals visualization data and UI."""
        PATH = "/visualize"
        def get(self) -> list[HTMLResponse | JSONResponse]:
            """Return the vitals visualization UI and data."""
            patient_id = self.request.query_params.get("patient_id")
            if not patient_id:
                return [JSONResponse({"error": "Patient ID is required"}, status_code=400)]
            try:
                vitals_data = self._get_vitals_data(patient_id)
                html_content = self._generate_visualization_html(vitals_data)
                return [HTMLResponse(content=html_content)]
            except Exception as e:
                log.error(f"Error in VitalsVisualizerAPI: {str(e)}")
                return [JSONResponse({"error": str(e)}, status_code=500)]
        def _get_vitals_data(self, patient_id: str) -> Dict[str, List[Dict[str, Any]]]:
            """Get vitals data for the patient using Canvas vitals structure."""
            try:
                # Get individual vital observations from vital signs panels
                vital_observations = (
                    Observation.objects.for_patient(patient_id)
                    .filter(
                        category="vital-signs",
                        effective_datetime__isnull=False,
                        deleted=False,
                    )
                    .exclude(name="Vital Signs Panel")
                    .exclude(entered_in_error__isnull=False)
                    .select_related("is_member_of")
                    .order_by("effective_datetime")
                )
                vitals_data = {
                    "weight": [],
                    "body_temperature": [],
                    "oxygen_saturation": [],
                }
                for obs in vital_observations:
                    if not obs.value or obs.name in ["note", "pulse_rhythm"]:
                        continue
                    if obs.name == "weight":
                        try:
                            value_oz = float(obs.value)
                            value_lbs = value_oz / 16
                            vitals_data["weight"].append(
                                {
                                    "date": obs.effective_datetime.isoformat(),
                                    "value": round(value_lbs, 1),
                                    "units": "lbs",
                                }
                            )
                        except (ValueError, TypeError):
                            continue
                    elif obs.name == "body_temperature":
                        try:
                            value = float(obs.value)
                            vitals_data["body_temperature"].append(
                                {
                                    "date": obs.effective_datetime.isoformat(),
                                    "value": value,
                                    "units": obs.units or "°F",
                                }
                            )
                        except (ValueError, TypeError):
                            continue
                    elif obs.name == "oxygen_saturation":
                        try:
                            value = float(obs.value)
                            vitals_data["oxygen_saturation"].append(
                                {
                                    "date": obs.effective_datetime.isoformat(),
                                    "value": value,
                                    "units": obs.units or "%",
                                }
                            )
                        except (ValueError, TypeError):
                            continue
                return vitals_data
            except Exception as e:
                log.error(f"Error collecting vitals data: {str(e)}")
                return {"weight": [], "body_temperature": [], "oxygen_saturation": []}
        def _generate_visualization_html(
            self, vitals_data: Dict[str, List[Dict[str, Any]]]
        ) -> str:
            """Generate the HTML for the vitals visualization using template."""
            context = {"vitals_data": json.dumps(vitals_data)}
            return render_to_string("templates/vitals_visualization.html", context)
    ```
###  vitals_button.py 
This file adds a "Visualize" button to the patient chart's vitals section, which, when clicked, opens a modal with a visual representation of the patient's vitals data, using the Canvas plugin and effect framework.
**Class Details**
  - The class `VitalsVisualizerButton` inherits from `ActionButton`.
  - It specifies metadata such as title ("Visualize"), a unique key (`vitals_visualizer_button`), the section of the UI where it appears (vitals summary), and its priority (1).
**Functionality**
  - When a user clicks the button, the `handle` method is triggered.
  - This method constructs a URL to an API endpoint for visualizing vitals: `/plugin-io/api/vitals_visualizer_plugin/visualize?patient_id=<id>`, where `<id>` is the current patient ID.
  - The button initiates a `LaunchModalEffect`, opening a large modal on the right side of the chart pane with the title "Vitals Visualization".
  - The modal displays the contents served by the constructed URL (likely a vitals graph or dashboard).
**Integration with Canvas SDK**
  - Uses SDK classes: 
    - `ActionButton` for button behaviors and placement.
    - `LaunchModalEffect` to open a modal window within the Canvas UI.
    - The effect is returned in a list, as required by the SDK's handler pattern.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.action_button import ActionButton
    class VitalsVisualizerButton(ActionButton):
        """A button that opens the vitals visualization modal."""
        BUTTON_TITLE = "Visualize"
        BUTTON_KEY = "vitals_visualizer_button"
        BUTTON_LOCATION = ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION
        PRIORITY = 1
        def handle(self) -> list[Effect]:
            """Handle button click by opening vitals visualization modal."""
            # The API endpoint will be at /plugin-io/api/vitals_visualizer_plugin/visualize
            # We need to pass the patient ID in the URL
            patient_id = self.target
            return [
                LaunchModalEffect(
                    url=f"/plugin-io/api/vitals_visualizer_plugin/visualize?patient_id={patient_id}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE_LARGE,
                    title="Vitals Visualization"
                ).apply()
            ]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/example-vitals_visualizer_plugin/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/examples/
The pages below showcase example plugins written with the Canvas SDK. All pages describe the file structure, the functionality, and link to GitHub where you can grab the code yourself and start iterating.
[ AI Note Titles ](/sdk/example-ai_note_titles/) [ API Samples ](/sdk/example-api_samples/) [ AWS S3 ](/sdk/example-aws_s3/) [ Abnormal Lab Task Notification ](/sdk/example-abnormal_lab_task_notification/) [ Charting API Examples ](/sdk/example-charting_api_examples/) [ Example Chart Application ](/sdk/example-example_chart_app/) [ Extend AI PDF ](/sdk/example-extend_ai_pdf/) [ Group Items in Patient Chart ](/sdk/example-patient_summary_chart_groups/) [ LLM ](/sdk/example-llm/) [ Patient Creation Platform Sync ](/sdk/example-patient_creation_platform_sync/) [ Send All Prescriptions ](/sdk/example-send_all_prescriptions/) [ SendGrid Email ](/sdk/example-sendgrid_email/) [ Twilio SMS/MMS ](/sdk/example-twilio_sms_mms/) [ Upsert Patient Metadata ](/sdk/example-upsert_patient_metadata/) [ Vitals Visualizer ](/sdk/example-vitals_visualizer_plugin/) [ Patient Portal Customization ]()
----- END PAGE https://docs.canvasmedical.com/sdk/examples/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/form-result-effect/
##  Overview 
Forms are a key part of the Patient Portal experience. They allow developers to dynamically display questionnaires to patients based on various criteria and optionally create a Questionnaire Command within a Note. Since these effects are evaluated on every page load, it's essential to ensure that only the appropriate forms are shown.
##  Structure 
A Form Result effect consists of the following properties:
  - **questionnaire_id** : The unique identifier for the Questionnaire.
  - **create_command** : A boolean flag that, when set to `True`, creates a Questionnaire Command within a Note.
  - **note_id** : Optionally associates the effect with an existing Note.
These properties ensure that the effect integrates seamlessly with the rest of the Canvas SDK.
###  **Attributes**
Attribute | Type | Description  
---|---|---  
`questionnaire_id` | `str | UUID` | The unique ID of the Questionnaire.  
`create_command` | `bool` | If `True`, a Questionnaire Command is created inside a Note.  
`note_id` | `str | UUID | None` | Associates the response with an existing Note if applicable.  
----- END PAGE https://docs.canvasmedical.com/sdk/form-result-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-action-buttons/
Action buttons are UI elements that trigger specific actions when clicked in the Canvas UI. These buttons can be placed in different locations and can interact with runtime data to execute custom code.
##  Overview 
An `ActionButton` class allows you to define custom buttons that appear in different sections of the Canvas UI. When a user clicks the button, the action associated with the button is executed. Action buttons can be added to various locations in the UI, and you can control their visibility and behavior through effects in a handler class.
There are no limitations on the number of action buttons you can create. You can define multiple buttons in a single handler class or create separate classes for each button.
##  Creating an Action Button 
To implement a custom action button, you need to create a handler class that inherits from the `ActionButton` class. Your handler class must:
  1. Define the constants `BUTTON_TITLE`, `BUTTON_KEY`, and `BUTTON_LOCATION`.
  2. Implement the `handle()` method to specify the action that should be triggered when the button is clicked.
  3. Optionally, implement the `visible()` method to control when the button should be shown.
###  Required Constants 
  - **`BUTTON_TITLE`**  
A string that defines the label of the button displayed in the Canvas UI. This is the text the user sees when interacting with the button.
  - **`BUTTON_KEY`**  
A unique identifier for your button. This key is used to route events, such as a click, to the appropriate handler method (`handle()`).
  - **`BUTTON_LOCATION`**  
Specifies where the button will appear within the Canvas UI. The button can be placed in various locations, such as the note header or footer, or other areas within the chart summary.
  - **`PRIORITY`** An optional integer that specifies the order in which the button should appear relative to other buttons in the same location. Lower values appear first. If not specified, no order is guaranteed.
###  Optional: Implement the `visible()` Method 
By default, the `ActionButton` class assumes the button is always visible (`return True`). If you want the button to only be visible under certain conditions, you can override the `visible()` method. This method must return a boolean value (`True` to show the button, `False` to hide it).
###  Implementing the `handle()` Method 
The `handle()` method is called when the action button is clicked. Inside this method, you can define what action should occur. The `handle()` method must return a list of [`Effect`](/sdk/effects/) objects, which represent the actions to be executed when the button is clicked. If no action is required, you can return an empty list.
###  Button Locations 
The `ActionButton` class defines several locations where the button can be placed. The location is defined using the `ButtonLocation` enum. Supported button locations include:
**Location** | **Description**  
---|---  
`NOTE_HEADER` | The button will appear in the header of each note.  
`NOTE_FOOTER` | The button will appear in the footer of each note.  
`CHART_SUMMARY_SOCIAL_DETERMINANTS_SECTION` | The button will appear in the Social Determinants section of the chart summary.  
`CHART_SUMMARY_GOALS_SECTION` | The button will appear in the Goals section of the chart summary.  
`CHART_SUMMARY_CONDITIONS_SECTION` | The button will appear in the Conditions section of the chart summary.  
`CHART_SUMMARY_MEDICATIONS_SECTION` | The button will appear in the Medications section of the chart summary.  
`CHART_SUMMARY_ALLERGIES_SECTION` | The button will appear in the Allergies section of the chart summary.  
`CHART_SUMMARY_CARE_TEAMS_SECTION` | The button will appear in the Care Teams section of the chart summary.  
`CHART_SUMMARY_VITALS_SECTION` | The button will appear in the Vitals section of the chart summary.  
`CHART_SUMMARY_IMMUNIZATIONS_SECTION` | The button will appear in the Immunizations section of the chart summary.  
`CHART_SUMMARY_SURGICAL_HISTORY_SECTION` | The button will appear in the Surgical History section of the chart summary.  
`CHART_SUMMARY_FAMILY_HISTORY_SECTION` | The button will appear in the Family History section of the chart summary.  
`CHART_SUMMARY_CODING_GAPS_SECTION` | The button will appear in the Coding Gaps section of the chart summary.  
##  Example Implementations 
###  Example 1: Log Information When Button is Clicked 
This example demonstrates a simple action button that logs some information when clicked. The button is visible only during the month of January.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from datetime import datetime
    from logger import log
    class MyButton(ActionButton):
        BUTTON_TITLE = "🪵 Log Action"
        BUTTON_KEY = "LOG_ACTION"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_HEADER
        def visible(self) -> bool:
            # Only show this button in January
            return datetime.now().month == 1
        def handle(self) -> list[Effect]:
            log.info("Button clicked!")
            log.info(self.event.context)
            log.info(self.event.target)
            return []
    ```
###  Example 2: Commit All Commands in a Note 
This example demonstrates an action button in the note footer that commits all commands within a note. The button is always visible since the `visible()` method is not overridden.
    ```python
    import json
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.v1.data.command import Command
    from canvas_sdk.effects.base import EffectType
    # Define a mapping of schema_key to EffectType
    schema_key_to_effect_type = {
        "allergy": EffectType.COMMIT_ALLERGY_COMMAND,
        "assess": EffectType.COMMIT_ASSESS_COMMAND,
        "changeMedication": EffectType.COMMIT_CHANGE_MEDICATION_COMMAND,
        "closeGoal": EffectType.COMMIT_CLOSE_GOAL_COMMAND,
        "diagnose": EffectType.COMMIT_DIAGNOSE_COMMAND,
        "familyHistory": EffectType.COMMIT_FAMILY_HISTORY_COMMAND,
        "goal": EffectType.COMMIT_GOAL_COMMAND,
        "instruct": EffectType.COMMIT_INSTRUCT_COMMAND,
        "hpi": EffectType.COMMIT_HPI_COMMAND,
        "medicalHistory": EffectType.COMMIT_MEDICAL_HISTORY_COMMAND,
        "medicationStatement": EffectType.COMMIT_MEDICATION_STATEMENT_COMMAND,
        "perform": EffectType.COMMIT_PERFORM_COMMAND,
        "plan": EffectType.COMMIT_PLAN_COMMAND,
        "questionnaire": EffectType.COMMIT_QUESTIONNAIRE_COMMAND,
        "reasonForVisit": EffectType.COMMIT_REASON_FOR_VISIT_COMMAND,
        "removeAllergy": EffectType.COMMIT_REMOVE_ALLERGY_COMMAND,
        "stopMedication": EffectType.COMMIT_STOP_MEDICATION_COMMAND,
        "surgicalHistory": EffectType.COMMIT_SURGICAL_HISTORY_COMMAND,
        "task": EffectType.COMMIT_TASK_COMMAND,
        "updateDiagnosis": EffectType.COMMIT_UPDATE_DIAGNOSIS_COMMAND,
        "updateGoal": EffectType.COMMIT_UPDATE_GOAL_COMMAND,
        "vitals": EffectType.COMMIT_VITALS_COMMAND,
    }
    class CommitButtonHandler(ActionButton):
        BUTTON_TITLE = "Commit all commands"
        BUTTON_KEY = "COMMIT_ALL_COMMANDS"
        BUTTON_LOCATION = ActionButton.ButtonLocation.NOTE_FOOTER
        def handle(self) -> list[Effect]:
            note_id = self.context.get("note_id")
            effects = []
            for command in Command.objects.filter(note_id=note_id):
                effect_type = schema_key_to_effect_type.get(command.schema_key)
                if not effect_type:
                    raise ValueError(f"No EffectType defined for schema key '{command.schema_key}'.")
                effects.append(
                    Effect(
                        type=effect_type,
                        payload=json.dumps({"command": str(command.id)}),
                    )
                )
            return effects
    ```
###  Example 3: Show Button in Vitals Section and render HTML on click 
In this example, we place a button in the Vitals section and define an action where the button, when clicked, displays custom HTML content to the user. For more info about `LaunchModalEffect`, check the [documentation](/sdk/layout-effect/#modals).
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.handlers.action_button import ActionButton
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from logger import log
    class VitalsButtonHandler(ActionButton):
        BUTTON_TITLE = "📊 Show Vitals Info"
        BUTTON_KEY = "SHOW_VITALS_INFO"
        BUTTON_LOCATION = ActionButton.ButtonLocation.CHART_SUMMARY_VITALS_SECTION
        def handle(self) -> list[Effect]:
            # This method will be called when the button is clicked
            log.info("Vitals info button clicked!")
            # Custom HTML content to display
            custom_html = """
            <div style="padding: 20px; background-color: #f0f8ff; border-radius: 5px;">
                <h3>Vitals Information</h3>
                <p>Patient's latest vitals data:</p>
                <ul>
                    <li>Heart Rate: 72 bpm</li>
                    <li>Blood Pressure: 120/80 mmHg</li>
                    <li>Respiratory Rate: 16 breaths/min</li>
                    <li>Temperature: 98.6°F</li>
                </ul>
                <p>For more details, please refer to the full report.</p>
            </div>
            """
            # Return a LaunchModalEffect to show the custom HTML content in a modal
            return [LaunchModalEffect(
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL,
                content=custom_html
            ).apply()]
        def visible(self) -> bool:
            # Optionally, make the button visible only under specific conditions
            return True
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-action-buttons/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-applications/
Applications are accessible in the app drawer and launch your content when clicked. Applications can be patient specific, or global.
##  Implementing an Application 
To add an application, your handler class should inherit from the `Application` class.
Your class must implement the `on_open()` method. In most cases, you will return a `LaunchModalEffect`, with either a URL you wish to iframe into the Canvas UI or HTML to be rendered in that iframe directly, make sure to set a `title` so users can easily recognize the application when it's minimized. You can return a single `Effect` or a list of `Effect`s from the `on_open()` method.
You can also optionally implement the `on_context_change()` method to handle context changes within the application. This method is automatically triggered when users navigate to different URLs within Canvas, allowing your application to react to contextual changes with rich information about the current page.
Context change events are currently supported for revenue workflows and include:
  - **URL information** : The current page URL that triggered the context change
  - **Patient data** : Patient information when applicable
  - **Resource-specific context** : Additional context based on the specific page: 
    - `/revenue/claims/<id>` \- Includes claim data with externally exposable ID
    - `/revenue/queues/<id>` \- Includes queue data with database ID
    - `/revenue` \- Base revenue page with no additional context
This method can return an `Effect` or list of `Effect`s to perform actions when the application's context changes, or `None` if no action is needed. When `None` is returned, no effect will be added to the execution queue.
Here is an example of an implemented application class:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class IFrameApp(Application):
        def on_open(self) -> Effect | list[Effect]:
            return LaunchModalEffect(url=f"https://www.your-iframe-app.com",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE, title="Your Iframe App").apply()
        def on_context_change(self) -> Effect | list[Effect] | None:
            # Access the current URL that triggered the context change
            current_url = self.event.context.get("url", "")
            # Handle claim-specific context
            if claim := self.event.context.get("claim"):
                claim_id = claim["id"]
                return LaunchModalEffect(
                    url=f"https://www.your-iframe-app.com?claim_id={claim_id}&source_url={current_url}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                    title=f"Your Iframe App - Claim {claim_id}"
                ).apply()
            # Handle queue-specific context
            if queue := self.event.context.get("claim_queue"):
                queue_id = queue["dbid"]
                return LaunchModalEffect(
                    url=f"https://www.your-iframe-app.com?queue_id={queue_id}&source_url={current_url}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                    title=f"Your Iframe App - Queue {queue_id}"
                ).apply()
            # Handle general revenue page context
            if current_url.startswith("/revenue"):
                return LaunchModalEffect(
                    url=f"https://www.your-iframe-app.com?page=revenue&source_url={current_url}",
                    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                    title="Your Iframe App - Revenue"
                ).apply()
            # Return None when no relevant context - this will result in an empty effect list
            return None
    ```
##  Context Change Events 
Context change events are automatically triggered when users navigate between different URLs within Canvas. This feature allows your applications to react dynamically to the user's current context, providing relevant information and functionality based on where they are in the system.
###  Event Triggers 
Context change events are currently supported for revenue workflows and are triggered when:
  - A user navigates to a different URL within Canvas
  - The application is already open and running
  - The new URL is within the `/revenue` namespace
###  Context Data Structure 
When a context change event occurs, your `on_context_change()` method receives contextual information through `self.event.context`:
    ```python
    {
        "url": "/revenue/claims/123",           # Current URL that triggered the event
        "patient": {"id": "patient_key"},       # Patient information (when applicable)
        "user": {...},                          # User information
        "claim": {"id": "external_claim_id"},   # Claim context (for /revenue/claims/<id>)
        "claim_queue": {"dbid": "queue_id"}     # Queue context (for /revenue/queues/<id>)
    }
    ```
###  Supported URL Patterns 
URL Pattern | Context Provided | Description  
---|---|---  
`/revenue` | Base context only | General revenue page  
`/revenue/claims/<id>` | `claim` object with externally exposable ID | Specific claim details page  
`/revenue/queues/<id>` | `claim_queue` object with database ID | Specific queue management page  
###  Best Practices 
  1. **Always check for context existence** : Use safe dictionary access patterns to avoid KeyErrors
  2. **Handle multiple context types** : Your application may receive different types of context based on the URL
  3. **Return None appropriately** : When no relevant action is needed, return None to avoid unnecessary effects
###  Advanced Example 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import Application
    class AdvancedRevenueApp(Application):
        def on_open(self) -> Effect | list[Effect]:
            return LaunchModalEffect(
                url="https://www.your-app.com/dashboard",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                title="Revenue Analytics"
            ).apply()
        def on_context_change(self) -> Effect | list[Effect] | None:
            current_url = self.event.context.get("url", "")
            patient = self.event.context.get("patient", {})
            user = self.event.context.get("user", {})
            # Build base parameters
            params = {
                "source_url": current_url,
                "user_id": user.get("id", ""),
                "patient_id": patient.get("id", "")
            }
            # Handle specific contexts
            if claim := self.event.context.get("claim"):
                params["claim_id"] = claim["id"]
                params["view"] = "claim_details"
                title = f"Revenue Analytics - Claim {claim['id']}"
            elif queue := self.event.context.get("claim_queue"):
                params["queue_id"] = queue["dbid"]
                params["view"] = "queue_management"
                title = f"Revenue Analytics - Queue {queue['dbid']}"
            elif current_url.startswith("/revenue"):
                params["view"] = "revenue_overview"
                title = "Revenue Analytics - Overview"
            else:
                # No relevant context for this application
                return None
            # Build query string
            query_string = "&".join(f"{k}={v}" for k, v in params.items() if v)
            return LaunchModalEffect(
                url=f"https://www.your-app.com/revenue?{query_string}",
                target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
                title=title
            ).apply()
    ```
In addition, your `CANVAS_MANIFEST.json` file must provide some information about your application. You reference your class in the "applications" section of the components so your application is registered in the app drawer on plugin installation.
This is also where you can define the title and icon that displays your app in the app drawer. The icon will be rendered at 48px by 48px, so should be square and simple enough to not lose detail at that size.
##  Application Scopes 
The `scope` attribute determines where your application is visible within Canvas. The following scopes are available:
Scope | Description  
---|---  
`patient_specific` | Visible only within a patient's chart in the app drawer  
`global` | Visible outside of patient charts in the app drawer  
`full_chart` | Displayed as a tab in the patient chart navigation menu alongside Chart and Profile  
`provider_menu_item` | Displayed as a menu item in the provider menu  
`portal_menu_item` | Displayed as a menu item in the patient portal  
###  Full Chart Scope 
Applications with the `full_chart` scope appear as navigation tabs at the top of the patient chart, alongside the default "Chart" and "Profile" tabs. This is ideal for building comprehensive patient-level views or dashboards.
    ```json
    {
      "class": "my_plugin.apps.analytics:PatientAnalytics",
      "name": "Analytics",
      "description": "Patient analytics dashboard",
      "icon": "/assets/analytics-icon.png",
      "scope": "full_chart"
    }
    ```
##  Note Applications 
Note Applications appear as tabs within a patient's note, allowing you to embed custom interfaces directly in the clinical documentation workflow.
###  Implementing a Note Application 
To create a Note Application, your handler class should inherit from `NoteApplication` and define two required class attributes:
Attribute | Description  
---|---  
`NAME` | The display title shown on the tab (supports emojis)  
`IDENTIFIER` | A unique key for the application (recommended format: `plugin_name__app_name`)  
Your class must implement the `handle()` method, which is called when the user clicks on the tab. This method should return a list of `Effect`s, typically a `LaunchModalEffect` with `target` set to `LaunchModalEffect.TargetType.NOTE`.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import NoteApplication
    class PatientIntakeApp(NoteApplication):
        """Note application for patient intake workflow."""
        NAME = "📋 Patient Intake"
        IDENTIFIER = "my_plugin__patient_intake"
        def handle(self) -> list[Effect]:
            """Launch the intake form when the tab is clicked."""
            note_id = self.context.get("note_id")
            return [
                LaunchModalEffect(
                    target=LaunchModalEffect.TargetType.NOTE,
                    content="<html>Your form HTML here</html>",
                    title="Patient Intake Form"
                ).apply()
            ]
    ```
![Note Application Tabs](../../../assets/images/note-application-tabs.png)
###  Context and Event Data 
The `handle()` method has access to context data through `self.context`:
Key | Description  
---|---  
`note_id` | The database ID of the current note  
`user` | Information about the current user  
Additional data is available through the event object:
Property | Description  
---|---  
`self.event.target` | The patient associated with the note  
`self.event.actor` | The authenticated user who triggered the event  
###  Controlling Visibility 
You can control when your Note Application tab is visible by overriding the `visible()` method. This method has access to the same context and event data as `handle()`:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.handlers.application import NoteApplication
    class ConditionalIntakeApp(NoteApplication):
        NAME = "📋 Intake"
        IDENTIFIER = "my_plugin__conditional_intake"
        def visible(self) -> bool:
            """Only show for specific conditions."""
            # Add your visibility logic here
            return True
        def handle(self) -> list[Effect]:
            return [LaunchModalEffect(
                target=LaunchModalEffect.TargetType.NOTE,
                content="<html>Form content</html>",
                title="Intake"
            ).apply()]
    ```
##  Panel Display 
If you want to increase your application's visibility and display it alongside other panel buttons (instead of in the applications drawer), you can add the `show_in_panel` attribute. If you've added more than one application to that panel, you can set their priorities using the `panel_priority` attribute.
For security reasons you also need to specify the domains that will be loaded within the iframe, or they will not be rendered. For more info on the format of the `url_permissions` field, check the [Additional Configuration](/sdk/layout-effect/#additional-configuration) for `LaunchModalEffect`.
Here's what your `CANVAS_MANIFEST.json` might look like:
    ```json
    {
      "sdk_version": "0.1.4",
      "plugin_version": "0.0.1",
      "name": "my_application",
      "description": "This is a very nice application",
      "url_permissions": [
        {
          "url": "https://example.com/",
          "permissions": ["ALLOW_SAME_ORIGIN", "MICROPHONE", "SCRIPTS", "CAMERA"]
        }
      ],
      "components": {
        "protocols": [],
        "applications": [
          {
            "class": "my_application.apps.iframe:IFrameApp",
            "name": "My Application",
            "description": "Test App for patients",
            "icon": "/assets/cappuccino.png",
            "scope": "patient_specific",
            "show_in_panel": true,
            "panel_priority": 100
          }
        ],
        "commands": [],
        "content": [],
        "effects": [],
        "views": []
      },
      "secrets": [],
      "tags": {},
      "references": [],
      "license": "",
      "diagram": false,
      "readme": "./README.md"
    }
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-applications/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-basehandler/
The `BaseHandler` is the simplest of all handlers. Specify which events you are interested in, then provide the code to execute when one of those events is emitted. All the [handlers](/sdk/handlers/) inherit from `BaseHandler`, and many of yours will too.
##  Handling Events With `BaseHandler`
To create a class that responds to one or more events, inherit from `BaseHandler`, set the `RESPONDS_TO` constant, and implement the `compute()` method.
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    class MyEventHandler(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
        def compute(self):
            # Your code goes here!
            return []
    ```
You can respond to one event, or several. To respond to multiple events, set `RESPONDS_TO` to a list of [event types](/sdk/events/).
    ```python
    # Respond when tasks are created:
    RESPONDS_TO = EventType.Name(EventType.TASK_CREATED)
    # Respond when tasks are created OR updated:
    RESPONDS_TO = [
        EventType.Name(EventType.TASK_CREATED),
        EventType.Name(EventType.TASK_UPDATED),
    ]
    ```
The `compute()` method must return a list of [Effects](/sdk/effects/). That list can be empty, of course. You have access to event information with `self.event`, `self.target`, and`self.context`, as well as configuration information for your plugin with `self.secrets` and for the running instance with `self.environment`. You can use our [Data Module](/sdk/data/) to retrieve additional information at runtime.
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-basehandler/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-crontask/
You can write a handler that subclasses `CronTask` to execute code on a schedule. You might use this to automate reporting on task performance (every hour, send the number of tasks created during the previous hour, and the number of tasks completed during the previous hour), to send birthday wishes to your patients (at 7am every morning, find patients born on this day and send them an email wishing them a happy birthday), or to send customized appointment reminders (every hour, find appointments that start on this hour the following day and send the patients of those appointments a message that says "Dr. X is looking forward to seeing you at (location) at (time)").
##  Example 
This example `CronTask` shows an extremely basic example that just logs the time. You can see the critical pieces here:
  - Subclass `CronTask`
  - Set your `SCHEDULE` with a cron string
  - Implement an `execute` method with the code you want to schedule to run, returning a list containing any effects you want to return, or an empty list if you do not wish to return any effects.
    ```python
    from canvas_sdk.handlers.cron_task import CronTask
    from canvas_sdk.effects import Effect
    from logger import log
    class LogTheTime(CronTask):
        # A cron string.
        #           ┌───────────── minute (0 - 59)
        #           │ ┌───────────── hour (0 - 23)
        #           │ │ ┌───────────── day of the month (1 - 31)
        #           │ │ │ ┌───────────── month (1 - 12)
        #           │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
        #           │ │ │ │ │
        #           │ │ │ │ │
        #           │ │ │ │ │
        SCHEDULE = "* * * * *"  # Run every minute, which is the most frequently something can run.
        def execute(self) -> list[Effect]:
            # The current timestamp can be found as an iso8601 string in
            # `self.target`
            log.info(f"The current time is {self.target}")
            # We don't need to return any effects
            return []
    ```
###  Output 
Here's what this scheduled task would output in the logs:
`INFO 2024-07-18 18:47:00,000 The current time is 2024-07-18T18:47:00.000000+00:00`
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-crontask/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-http/
The Canvas SDK provides a way to define an HTTP API with any number of endpoints in your instance. Developers can define the routes and implement the code that will handle incoming HTTP requests.
This feature allows developers to create endpoints that can receive webhook events from other services. An endpoint receiving a request can invoke Effects in a Canvas instance, send another request to a different service, or simply return a response back to the requester.
##  Quickstart 
Follow the instructions in [Your First Plugin (with Claude Code)](https://docs.canvasmedical.com/guides/your-first-plugin-with-claude-code/) to create a plugins project. For this exercise, use `my_api` as your project (i.e. plugin) name.
Open `CANVAS_MANIFEST.json` in your editor. You can modify filenames, directory structures, and class names as you see fit in your project, but for this exercise, we are just going to set the value at `components -> protocols -> 0 -> class` to be `my_api.protocols.my_protocol:MyAPI`.
We're going to need a secret value for authentication. The instructions for declaring secrets are outlined on the [Your First Plugin (Manual)](https://docs.canvasmedical.com/guides/your-first-plugin/) page. Declare a secret in `CANVAS_MANIFEST.json` named `my-api-key`.
Open `my_api/protocols/my_protocol.py` and replace the contents of the file with this code:
    ```python
    from hmac import compare_digest
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            provided_api_key = credentials.key
            api_key = self.secrets["my-api-key"]
            # compare_digest requires bytes, so we must encode the strings
            return compare_digest(provided_api_key.encode(), api_key.encode())
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
    ```
The next step is to deploy your plugin; the instructions for doing so are on the [Your First Plugin (Manual)](https://docs.canvasmedical.com/guides/your-first-plugin/) page.
You can see in the code above that the `authenticate` method is going to authenticate using API key authentication. We've already declared the secret, so now we need to generate a value and set it on your instance. You can generate an API key like this:
    ```shell
    python -c "import secrets; print(secrets.token_hex(16))"
    ```
Copy the value that it prints out and set the value for `my-api-key` in your plugin secrets on your instance.
Now that your plugin is deployed and your secret is set, you can send requests to your endpoint with `curl`. The `curl` command would look like the following (note that you will need to supply your instance name and API key):
    ```shell
    curl --location 'https://<instance-name>.canvasmedical.com/plugin-io/api/my_api/routes/hello-world' \
         --header 'Authorization: <api-key>'
    ```
##  Defining APIs 
The Canvas SDK offers two styles for defining API endpoints. To implement an API endpoint or set of endpoints using one of the two styles, your handler will simply inherit from a specific base class. The following HTTP verbs are supported:
  - GET
  - POST
  - PUT
  - DELETE
  - PATCH
###  SimpleAPIRoute 
For handlers that inherit from **SimpleAPIRoute** , you set a class variable in your handler called `PATH` as in the example above, and then implementations of the HTTP verbs you wish to support on that path. The method names will match the names of the HTTP verbs, but lowercased.
The plugin name and the `PATH` value together will form the unique part of the full URL for your endpoint. The format of the full URL will be:
`https://<instance-name>.canvasmedical.com/plugin-io/api/<plugin-name>/<PATH>`
We can adapt the previous example to add a POST endpoint for the same route on the same handler:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my GET endpoint!"})
            ]
        def post(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my POST endpoint!"})
            ]
    ```
The handler can now respond to both GET and POST requests at `/routes/hello-world`.
###  SimpleAPI 
For handlers that inherit from **SimpleAPI** , the syntax is a little different. You can include any number of endpoints in your handler class, and you can name your route handling methods anything you wish. Here is an example:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPI, api
    class MyAPI(SimpleAPI):
        PREFIX = "/routes"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        @api.get("/hello-world")
        def hello_world_get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my GET endpoint!"})
            ]
        @api.post("/hello-world")
        def hello_world_post(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world from my POST endpoint!"})
            ]
        @api.get("/goodbye")
        def goodbye_get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Goodbye from my GET endpoint!"})
            ]
    ```
This syntax will be familiar if you have used Python API frameworks like `Flask` or `FastAPI`. The decorator functions are named for the HTTP verb you wish to implement on the route, and the URL path is passed into the decorator function. If you have many endpoints that you wish to share the same authentication, this syntax may be more convenient.
You can also specify a path `PREFIX` value for endpoint grouping purposes, as shown in the example above. If you have multiple endpoints that will all have the same path prefix, you can specify it by setting a value for `PREFIX`. With `PREFIX` set, each endpoint does not have to individually specify the `/routes` portion of the URL path.
###  Path patterns 
If you want to set up an endpoint that will respond to requests where the path matches a pattern rather than an exact string, you can use a path pattern. This is common in cases where the path of an endpoint contains a resource identifier.
You can specify a path pattern by by denoting any number of the path parameters in the path using `<>` syntax, with the name of the path parameters in between the angle brackets. Path parameter names must be be unique within the path. They can also be specified in the path prefix (for **SimpleAPI** handlers).
Path parameters will be extracted from the path and will be available on the request object in the `path_params` attribute.
In the example below, the value `id` is specified as part of the path, and can be accessed by the handler:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world/<id>"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            id_ = self.request.path_params["id"]
            return [
                JSONResponse(
                    {
                        "message": "Hello world from my GET endpoint!",
                        "id": id_
                    }
                )
            ]
    ```
####  Path matching 
When you specify routes using path patterns, it is possible that multiple endpoints may match with a request. This has a few implications that need to be considered, because only one endpoint can provide a response.
If the endpoints that match are all part of the same handler class, then the request will be handled by the endpoint that appears highest up in the class definition, i.e. the one that is defined first. Consider two endpoints specified to match the following patterns:
    /routes/hello-world/current-user
    /routes/hello-world/<id>
The first uses an exact match, and the second uses a pattern. The path `/routes/hello-world/current-user` matches both of those patterns. However, if you register the second endpoint first it would never be possible for a request with the path of `/routes/hello-world/current-user` to match with the endpoint for `/routes/hello-world/current-user`. If you need to define endpoints that use exact matching that may overlap with endpoints defined with path patterns, order must be carefully considered.
If, however, you have defined multiple **SimpleAPIRoute** or **SimpleAPI** handlers, and a request matches with multiple endpoints across these handlers, an error condition will result. There is not a way to specify priority across handlers, so if you need fine-grained control over request routing for endpoints that use path patterns, make sure they are contained within the same handler class.
###  Request objects 
When a handler is invoked to handle an incoming HTTP request, the request object is available as an attribute on the handler. The request method, path, query parameters, content type, and body are all available as attributes on the request object:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    from logger import log
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            request = self.request
            # HTTP method
            method = request.method
            # URL path component
            path = request.path
            # Raw query string
            query_string = request.query_string
            # Query parameters as a key-value mapping
            query_params = request.query_params
            # Request headers
            headers = request.headers
            # Request body content type
            content_type = request.content_type
            # Raw body
            body = request.body
            # JSON body as a Python dictionary (for requests with application/json content types)
            json_body = request.json()
            # Body as plain text
            text_body = request.text()
            # Body parsed as form data
            form_data = request.form_data()
            return [
                JSONResponse({"message": "Hello world!"})
            ]
    ```
####  Key-value mappings 
Attributes on the request object like headers, query parameters, and form data can in most cases be represented by mappings containing key-value pairs (e.g. Python dictionaries) with a small caveat: keys are not required to be unique. Because of this, there can be more than one value per key.
These attributes are represented by a data structure that most of the time will behave like a Python dictionary, unless you want to access the additional values for a key. If you do request the value for a key using standard dictionary syntax, you will get the first value that was encountered for that key. If you want the other values, you will need to use different methods to access them.
Here is an example showing how to access the additional values:
    ```python
    # Request sent to /route?value1=a&value1=b&value2=c
    query_params = request.query_params
    # Get the first value for value1
    value1: str = query_params["value1"]
    # Get all values for value1 with get_list
    value1_all: list[str] = query_params.get_list("value1")
    # Iterate over all query parameters (repeating keys if necessary) with multi_items
    for key, value in query_params.multi_items():
        log.info(f"key:   {key}")
        log.info(f"value: {value}")
    ```
####  Forms 
If your endpoint is set up to accept `application/x-www-form-urlencoded` or `multipart/form-data` data, there is method named `form_data` on the request object that will parse the request body. This method will return a key-value mapping containing `FormPart` objects, each of which represents a subpart of the form.
Every subpart in a form has a name, and these names are the keys in the mapping that is returned by the method. A `FormPart` can represent either a simple string value or a file. A `FormPart` that represents a string will have attributes for `name` and `value`. A `FormPart` that represents a file will have attributes for `name`, `filename`, `content`, `content_type`.
If the content type of a request is `application/x-www-form-urlencoded`, then all `FormPart` objects will represent simple string values. If the content type of a request is `multipart/form-data`, then each `FormPart` object may represent either a simple string value or a file.
Here is an example of how to use the `form_data` method to iterate over the subparts of a request body with form data:
    ```python
    form_data = request.form_data()
    # To iterate over all parts, we have to use the multi_items method because there may be more than
    # one part with the same name
    for name, part in form_data.multi_items():
        log.info(f"part name:    {name}")
        if part.is_file():
            # It's a file
            log.info(f"content:      {part.content}")
            log.info(f"filename:     {part.filename}")
            log.info(f"content type: {part.content_type}")
        else:
            # It's a simple string
            log.info(f"value:        {part.value}")
    ```
If you know the name of the subparts you are looking for, you can also access the subparts directly by looking up the name in the mapping returned by `form_data`:
    ```python
    form_data = request.form_data()
    # Get the first part named "my-part-name"
    part = form_data["my-part-name"]
    # Get all parts named "my-part-name"
    parts_all = form_data.get_list("my-part-name")
    ```
###  Responses 
Endpoint handlers may return zero or one response objects and any number of Effects. Handlers that return multiple response objects will return a **500 Internal Server Error** response back to the requester. If your endpoint does not provide a response object, then the requester will receive a **204 No Content** response.
####  Response types 
Several response types are provided for convenience:
  - HTMLResponse
  - JSONResponse
  - PlainTextResponse
  - Response (for returning raw content)
In addition to the response body, you can also specify the response status code and the response headers.
    ```python
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import HTMLResponse, JSONResponse, PlainTextResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            ...
        def get(self) -> list[Response | Effect]:
            return [
                HTMLResponse(
                    "<p>Hello world from my GET endpoint!</p>",
                    status_code=HTTPStatus.OK,
                    headers={"My-Header", "my header value"}
                )
            ]
        def post(self) -> list[Response | Effect]:
            return [
                JSONResponse(
                    {"message": "Hello world from my POST endpoint!"},
                    status_code=HTTPStatus.CREATED,
                    headers={"My-Header", "my header value"}
                )
            ]
        def put(self) -> list[Response | Effect]:
            return [
                PlainTextResponse(
                    "Hello world from my PUT endpoint!",
                    status_code=HTTPStatus.ACCEPTED,
                    headers={"My-Header", "my header value"}
                )
            ]
        def patch(self) -> list[Response | Effect]:
            return [
                Response(
                    b'{"message": "Hello world from my PATCH endpoint!"}',
                    status_code=HTTPStatus.NOT_MODIFIED,
                    headers={"My-Header", "my header value"},
                    content_type="application/json"
                )
            ]
    ```
####  Returning Effects 
**SimpleAPI** endpoints can return any number of Effects just like any Canvas plugin; this is why **SimpleAPI** endpoints return a list of items rather than just a single response object.
Any effects present in the list returned by an endpoint will be processed by your Canvas instance, and the response object, if provided, will be sent back to the original requester.
###  Authentication 
Defining an `authenticate` method on your handler is required. By default, **SimpleAPI** handlers will return a **401 Unauthorized** response if no `authenticate` method is defined. The `authenticate` method should return `True` or `False` depending on whether the requester is authenticated.
Please keep in mind that while setting plugins secrets on your instance is out of scope for this guide, best practices would dictate that most `authenticate` methods would use these secrets to authenticate credentials in a request (OAuth being a notable exception). Your secrets can be accessed through the `secrets` attribute on the handler.
Additionally, to assist with adhering to security and cryptography best practices, the Python `hashlib`, `hmac`, and `secrets` modules are available for use.
Examples of how to define `authenticate` methods for various authentication schemes are shown in the next section, but if you are interested in something that is more "batteries included", please skip ahead to the Authentication mixins section below. The API key authentication mixin is a good choice that offers simplicity and good security if you need something to get started.
####  Authentication schemes 
The Canvas SDK can parse and validate the format of the Authentication header automatically for several authentication schemes, but you must authenticate the credentials in your `authenticate` method. You can specify which authentication scheme you want to use for your route or API in the method signature of your `authenticate` method.
#####  Basic 
For Basic authentication, use `BasicCredentials`:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import BasicCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: BasicCredentials) -> bool:
            provided_username = credentials.username
            provided_password = credentials.password
            # Validate provided username and password against a username and password in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
    ```
#####  Bearer 
For Bearer authentication, use `BearerCredentials`:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import BearerCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: BearerCredentials) -> bool:
            provided_token = credentials.token
            # Validate provided access token via OAuth
            ...
        def get(self) -> list[Response | Effect]:
            ...
    ```
#####  API key 
For API key authentication, use `APIKeyCredentials`:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import APIKeyCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: APIKeyCredentials) -> bool:
            provided_api_key = credentials.key
            # Validate provided key against an API key in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
    ```
#####  Session 
To authenticate using a logged-in user's session, use `SessionCredentials`:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import SessionCredentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: SessionCredentials) -> bool:
            logged_in_user = credentials.logged_in_user
            # Structure looks like:
            # {
            #     "id": "abc123",
            #     "type": "Staff"
            # }
            # Where "type" is "Staff" or "Patient"
            # You could authenticate based on type or check to see if the
            # individual is in a particular group or team.
            ...
        def get(self) -> list[Response | Effect]:
            ...
    ```
#####  Custom 
It's also possible to create custom authentication schemes. There are two ways to do this.
The first way is to access authentication headers on the request object directly. If you wish to do this, then you would define your authenticate method to take a `Credentials` object, and pull the authentication values from the request headers:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPIRoute
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: Credentials) -> bool:
            provided_api_key = self.request.headers["My-API-Key"]
            provided_app_key = self.request.headers["My-App-Key"]
            # Validate provided credentials against the credentials in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
    ```
Another way to do this is by defining your own `Credentials` subclass which obtains the authentication values out of the request headers:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPIRoute
    from canvas_sdk.handlers.simple_api.api import Request
    class MyCredentials(Credentials):
        def __init__(self, request: Request) -> None:
            self.api_key = self.request.headers['My-API-Key']
            self.app_key = self.request.headers['My-App-Key']
    class MyAPI(SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def authenticate(self, credentials: MyCredentials) -> bool:
            provided_api_key = credentials.api_key
            provided_app_key = credentials.app_key
            # Validate provided credentials against the credentials in self.secrets
            ...
        def get(self) -> list[Response | Effect]:
            ...
    ```
####  Authentication mixins 
The Canvas SDK offers several "batteries included" authentication mixins that you can use to implement your authentication method. If you choose to use these, then the only action you must take is to ensure that you set the appropriate secrets for your plugin on your instance.
Make sure you always list the mixin class to the left of the base class, which is **SimpleAPIRoute** in the examples below.
#####  Basic 
If you want an implementation of Basic authentication, you can use the `BasicAuthMixin`. You will need to declare the `simpleapi-basic-username` and `simpleapi-basic-password` secrets in your manifest file, and then set the secrets on your instance after you deploy your plugin.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import BasicAuthMixin, SimpleAPIRoute
    class MyAPI(BasicAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
    ```
#####  API key 
If you want an implementation of API key authentication, you can use the `APIKeyAuthMixin`. You will need to declare the `simpleapi-api-key` secret in your manifest file, and then set the secret on your instance after you deploy your plugin.
You can generate a secure, random API key like this:
    ```shell
    python -c "import secrets; print(secrets.token_hex(16))"
    ```
Copy the output from that command, and set the `simpleapi-api-key` secret on your instance.
After you set your secret, you can use the `APIKeyAuthMixin`:
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import APIKeyAuthMixin, SimpleAPIRoute
    class MyAPI(APIKeyAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
    ```
#####  Staff Session 
If you want to ensure the visiting user is a logged in staff user, you can use the `StaffSessionAuthMixin`. This makes no assertions about the particular staff member, just that they are staff, and that they are logged in.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import StaffSessionAuthMixin, SimpleAPIRoute
    class MyAPI(StaffSessionAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
    ```
#####  Patient Session 
If you want to ensure the visiting user is a logged in patient user, you can use the `PatientSessionAuthMixin`. This makes no assertions about the particular patient, just that they are a patient, and that they are logged in.
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import JSONResponse, Response
    from canvas_sdk.handlers.simple_api import PatientSessionAuthMixin, SimpleAPIRoute
    class MyAPI(PatientSessionAuthMixin, SimpleAPIRoute):
        PATH = "/routes/hello-world"
        def get(self) -> list[Response | Effect]:
            return [
                JSONResponse({"message": "Hello world!"})
            ]
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-http/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-websocket/
WebSocket APIs in Canvas let you define **channels** that clients can connect to. These APIs support one-way, server-to-client communication, and are designed for use cases such as real-time notifications.
###  Defining a WebSocket API 
To define a WebSocket handler, subclass `WebSocketAPI`. You must implement an `authenticate` method that determines whether the connection should be accepted.
    ```python
    from canvas_sdk.handlers.simple_api.websocket import WebSocketAPI
    class MyWebSocketAPI(WebSocketAPI):
        def authenticate(self) -> bool:
            ...
    ```
If `authenticate()` returns `True`, the connection is accepted. Otherwise, it is denied.
Clients should connect using a URL that maps to your plugin and channel name:
    wss://<instance>.canvasmedical.com/plugin-io/ws/<plugin_name>/<channel_name>/
###  WebSocket Object 
When a handler is invoked, the `websocket` object is available as an attribute on the handler. This object provides details about the connection, including:
  - `channel`: The channel name from the connection URL
  - `headers`: A dictionary of headers associated with the connection
  - `api_key`: The api key, if present
  - `logged_in_user`: A dictionary like `{ "id": ..., "type": ... }` if a logged-in user is present
You can access this object within your handler methods using `self.websocket`.
###  Authentication 
You must implement the `authenticate()` method in your handler class. Two authentication methods are supported:
#####  Session-Based (Internal Clients) 
For connections initiated from within the Canvas browser UI by a logged-in user:
    ```python
    def authenticate(self) -> bool:
        logged_in_user = self.websocket.logged_in_user
        # Structure looks like:
        # {
        #     "id": "abc123",
        #     "type": "Staff"
        # }
        # Where "type" is "Staff" or "Patient"
        # You could authenticate based on type or check to see if the
        # individual is in a particular group or team.
        ...
    ```
#####  APIKey-Based (External Clients) 
For external tools or scripts, pass an auth key as a query parameter:
    wss://<instance>.canvasmedical.com/plugin-io/ws/<plugin>/<channel>?api_key=<key>
The key is made available in your handler via `self.websocket.api_key`. You can store this key as a secret.
    ```python
    def authenticate(self) -> bool:
      provided_token = self.websocket.api_key
      # Validate provided key against an API key in self.secrets
      ...
    ```
###  Broadcasting Messages 
To send a message to all connected clients on a WebSocket channel, use the `Broadcast` effect. This effect can be returned from any handler.
The `Broadcast` effect takes the following parameters:
  - `message`: A JSON-serializable Python dictionary or value.
  - `channel`: The target channel name as a string.
Here's an example using a SimpleAPI HTTP POST route to trigger a broadcast:
    ```python
    from http import HTTPStatus
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.simple_api import Broadcast, JSONResponse, Response
    from canvas_sdk.handlers.simple_api import Credentials, SimpleAPI, api
    class WebhookAPI(SimpleAPI):
        @api.post("/callback")
        def broadcast_message(self) -> list[Response | Effect]:
            body = self.request.json()
            return [
                Broadcast(message=body, channel="notifications").apply(),
                JSONResponse({"status": "ok"}, status_code=HTTPStatus.ACCEPTED),
            ]
    ```
In this example, when the `/callback` endpoint receives a POST request, it broadcasts the request body as a message to all clients subscribed to the `notifications` channel.
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api-websocket/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api/
The Canvas SDK allows developers to define both HTTP and WebSocket APIs to integrate custom plugin logic into a Canvas instance.
[ HTTP API Define endpoints to handle incoming HTTP requests using custom logic and authentication. ](/sdk/handlers-simple-api-http) [ WebSocket API Establish real-time communication channels for interactive plugin behavior and updates. ](/sdk/handlers-simple-api-websocket)
----- END PAGE https://docs.canvasmedical.com/sdk/handlers-simple-api/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/handlers/
The handlers module lets you define reactions to events.
Handlers respond to [Events](/sdk/events/) and return zero, one, or many [Effects](/sdk/effects/).
There are some special types of handlers, like [Protocols](/sdk/protocols/) and [CronTasks](/sdk/handlers-crontask/). These offer a differentiated interface for their particular use-cases. For example, CronTasks only ever respond to the `CRON` event, require a schedule to be specified, and expect the `execute` method to be implemented rather than `compute`.
All handlers inherit from [BaseHandler](/sdk/handlers-basehandler/), which means you always have access to event and configuration data with the following accessors:
  - `self.event`
    - Information about the event including the event type
  - `self.context`
    - Data included as the event payload
  - `self.target`
    - Identifying information to help you reference the subject of the event
  - `self.secrets`
    - Configuration key-value store for your plugin
    - Secrets have their keys defined in the `CANVAS_MANIFEST.json` and their values are set by the Canvas instance administrator after installing your plugin via the Canvas UI on your plugin's configuration page
  - `self.environment`
    - Information about the Canvas instance your plugin is being executed on, like the subdomain, which we refer to as the customer identifier.
    - Example: `self.environment['CUSTOMER_IDENTIFIER']`
## [ Action Button  Add a button that executes your custom code when clicked. ![Abridged source code of an action button implementation.](/assets/images/sdk/handlers/ActionButton.png) ![Image of an action button in a note header.](/assets/images/sdk/handlers/action-button-in-action.png) ](/sdk/handlers-action-buttons/) ## [ Application  Launch an iframe when your icon is clicked in the app drawer. ![Abridged source code of an application implementation.](/assets/images/sdk/handlers/Application-cropped.png) ![Image of application icons in the app drawer.](/assets/images/sdk/handlers/application-applied.png) ](/sdk/handlers-applications/) ## [ Cron Task  Execute your code on a cron-like schedule. ![Abridged source code of an action button implementation.](/assets/images/sdk/handlers/CronTask-cropped.png) ![Picture of Mr. Cron, the little time monster that remembers which tasks should be executed at any given time.](/assets/images/sdk/handlers/mr-cron.png) ](/sdk/handlers-crontask/) ## [ Base Handler  Respond to events with your custom code. ![Abridged source code of a base handler implementation.](/assets/images/sdk/handlers/BaseHandler-cropped.png) ![Stylized text that reads 'When X occurs, under Y conditions, I want Z to happen'.](/assets/images/sdk/handlers/base-handler-can-lend-a-hand.png) ](/sdk/handlers-basehandler/)
----- END PAGE https://docs.canvasmedical.com/sdk/handlers/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/layout-effect/
##  Patient Summary 
There are many summary sections in a patient's chart, organized by data type. While there is a default ordering, you can use an Effect to reorder them or hide some of them entirely. The `PatientChartSummaryConfiguration` class helps you craft the effect to do so.
![Before and after](/assets/images/sdk/summary-section-modified.png)
The example below shows reordering and hiding or omitting some of the sections:
    ```python
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers.base import BaseHandler
    from canvas_sdk.effects.patient_chart_summary_configuration import PatientChartSummaryConfiguration
    class SummarySectionLayout(BaseHandler):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION)
        def compute(self):
            layout = PatientChartSummaryConfiguration(sections=[
              PatientChartSummaryConfiguration.Section.CARE_TEAMS,
              PatientChartSummaryConfiguration.Section.SOCIAL_DETERMINANTS,
              PatientChartSummaryConfiguration.Section.ALLERGIES,
              PatientChartSummaryConfiguration.Section.CONDITIONS,
              PatientChartSummaryConfiguration.Section.MEDICATIONS,
              PatientChartSummaryConfiguration.Section.VITALS,
            ])
            return [layout.apply()]
    ```
The `PatientChartSummaryConfiguration` takes a single argument, `sections`, which is expected to be a list at least one element long, filled with choices from the `PatientChartSummaryConfiguration.Section` enum. The `.apply()` method returns a well-formed `Effect` object.
This effect is only used in response to the `PATIENT_CHART_SUMMARY__SECTION_CONFIGURATION` event. It does nothing in any other context.
Values in the `PatientChartSummaryConfiguration.Section` enum are:
Constant | Description  
---|---  
SOCIAL_DETERMINANTS | social_determinants  
GOALS | goals  
CONDITIONS | conditions  
MEDICATIONS | medications  
ALLERGIES | allergies  
CARE_TEAMS | care_teams  
VITALS | vitals  
IMMUNIZATIONS | immunizations  
SURGICAL_HISTORY | surgical_history  
FAMILY_HISTORY | family_history  
CODING_GAPS | coding_gaps  
###  Action Buttons 
Each section of the patient chart can also be customized with action buttons. Please refer to the [Action Buttons](/sdk/handlers-action-buttons/) documentation for more information.
##  Patient Profile 
The `PatientProfileConfiguration` class allows you to reorder, hide, and/or specificy whether sections load expanded or collapsed.
    ```python
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.effects.patient_profile_configuration import PatientProfileConfiguration
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    from logger import log
    class Protocol(BaseProtocol):
        """This protocol is used to configure which sections appear in the Patient Profile section.
        The SHOW_PATIENT_PROFILE_SECTIONS payload expects a list of sections where each section is a dict like { "type": str, "start_expanded": bool }
        The accepted values for the "type" are:
        "demographics", "preferences", "preferred_pharmacies", "patient_consents",
        "care_team", "parent_guardian", "addresses", "phone_numbers", "emails", "contacts"
        """
        # Name the event type you wish to run in response to
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PROFILE__SECTION_CONFIGURATION)
        def compute(self) -> list[Effect]:
            """This method gets called when an event of the type RESPONDS_TO is fired."""
            sections = [
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.PREFERENCES,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.DEMOGRAPHICS,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(
                    type=PatientProfileConfiguration.Section.PREFERRED_PHARMACIES, start_expanded=True),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.PARENT_GUARDIAN,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.CONTACTS,
                                                    start_expanded=True),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.CARE_TEAM,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.TELECOM,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.ADDRESSES,
                                                                 start_expanded=False),
                PatientProfileConfiguration.Payload(type=PatientProfileConfiguration.Section.PATIENT_CONSENTS,
                                                    start_expanded=False),
            ]
            effect = PatientProfileConfiguration(sections=sections).apply()
            return [effect]
    ```
The `PatientProfileConfiguration` takes a single argument, `sections`, which is expected to be a list at least one element long, filled with `PatientProfileConfiguration.Payload` objects. These are python typed dictionaries that expect a `PatientProfileConfiguration.Section` choice, which describes a section of the patient profile, and a `start_expanded` boolean, which determines if the fields in that section should be exposed by default. The `.apply()` method returns a well-formed `Effect` object.
This effect is only used in response to the `PATIENT_PROFILE__SECTION_CONFIGURATION` event. It does nothing in any other context.
Values in the `PatientProfileConfiguration.Section` enum are:
Constant | Description  
---|---  
DEMOGRAPHICS | demographics  
PREFERENCES | preferences  
PREFERRED_PHARMACIES | preferred_pharmacies  
PATIENT_CONSENTS | patient_consents  
CARE_TEAM | care_team  
PARENT_GUARDIAN | parent_guardian  
ADDRESSES | addresses  
TELECOM | telecom  
CONTACTS | contacts  
##  Panel Configuration 
This effect allows you to define which panel buttons should be displayed on the main page or the patient page.
The order of the buttons in the array will determine their order on the panel.
![Before and after](/assets/images/sdk/panel-configuration-before-after.png)(width:70%)
    ```python
    from canvas_sdk.effects.panel_configuration import PanelConfiguration
    PanelConfiguration(
      sections=[
        PanelConfiguration.PanelPatientSection.REFILL_REQUEST,
        PanelConfiguration.PanelPatientSection.LAB_REPORT,
        PanelConfiguration.PanelPatientSection.CHANGE_REQUEST,
        PanelConfiguration.PanelPatientSection.TASK,
    ], page=PanelConfiguration.Page.PATIENT).apply()
    ```
A PanelConfiguration effect consists of the following properties:
###  Attributes 
Attribute | Type | Description  
---|---|---  
`sections` | `list[PanelPatientSection] or list[PanelGlobalSection]` | list of section items.  
`page` | `Page` | PATIENT or GLOBAL.  
Values in the `PanelGlobalSection` enum are:
Constant | Description  
---|---  
APPOINTMENT | appointment  
CHANGE_REQUEST | changeRequest  
IMAGING_REPORT | imagingReport  
INPATIENT_STAY | inpatientStay  
LAB_REPORT | labReport  
MESSAGE | message  
OUTSTANDING_REFERRAL | outstandingReferral  
PRESCRIPTION_ALERT | prescriptionAlert  
RECALL_APPOINTMENT | recallAppointment  
REFERRAL_REPORT | referralReport  
REFILL_REQUEST | refillRequest  
TASK | task  
UNCATEGORIZED_DOCUMENT | uncategorizedDocument  
Values in the `PanelPatientSection` enum are:
Constant | Description  
---|---  
CHANGE_REQUEST | changeRequest  
COMMAND | command  
IMAGING_REPORT | imagingReport  
INPATIENT_STAY | inpatientStay  
LAB_REPORT | labReport  
PRESCRIPTION_ALERT | prescriptionAlert  
REFERRAL_REPORT | referralReport  
REFILL_REQUEST | refillRequest  
TASK | task  
UNCATEGORIZED_DOCUMENT | uncategorizedDocument  
##  Modals 
The `LaunchModalEffect` class allows you to launch modals in Canvas, providing a flexible way to display content or navigate to external resources.
###  Example Usage 
    ```python
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    class ModalEffectHandler:
        def compute(self):
            modal_effect = LaunchModalEffect(
                url="https://example.com/info",
                content=None,
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL,
                title="Example Info"
            )
            return [modal_effect.apply()]
    ```
The `LaunchModalEffect` class has the following properties:
  - **url** : A string containing the URL to load within the modal. If `content` is also specified, an error will be raised.
  - **content** : A string containing the content to be displayed directly within the modal. If `url` is also provided, an error will be raised.
  - **target** : Defines where the modal should be launched. Options include: 
    - `DEFAULT_MODAL`: Opens the URL in a modal centered on the screen.
    - `NEW_WINDOW`: Opens the content in a new browser window.
    - `RIGHT_CHART_PANE`: Opens the URL in the right-hand pane of the patient chart.
    - `RIGHT_CHART_PANE_LARGE`: Like above, but a bit wider.
    - `PAGE`: Opens the content as a full page.
    - `NOTE`: Opens the content within a note tab (used with Note Applications).
  - **title** : A string containing the title of the modal and will be displayed when minimized. Defaults to `Untitled`
###  Closing Modals from Applications 
When building applications with the Canvas SDK, you may encounter scenarios where you need to programmatically dismiss modals. This can be particularly useful in automated testing or when creating user flows that require closing modals based on certain conditions.
Here's a simple example of how to dismiss modals from your applications using JavaScript.
    ```html
    <script>
        let messagePort = null;
        // Listen for the port transfer from the Canvas Application
        window.addEventListener('message', (event) => {
          // Check if this is the INIT_CHANNEL message with a port
          if (event.data?.type === 'INIT_CHANNEL' && event.ports[0]) {
            // Store the port for later use
            messagePort = event.ports[0];
            messagePort.start();
            messagePort.postMessage({ type: 'CLOSE_MODAL' });
          }
        });
    </script>
    ```
And that's it! This script establishes a communication channel with the Canvas Application by listening for the `INIT_CHANNEL` event, capturing the message port, and then sending a `CLOSE_MODAL` message through that port to close any open modals when the application loads. You can customize the event listener to trigger the modal dismissal based on your specific requirements.
While developers might find odd to be sending a message to themselves, this is the current method supported by the Canvas SDK for dismissing modals, in order to avoid potential security issues with cross-origin messaging and flooding the main application with messages.
This twist on the _Holywood Principle_ ensures that your application remains secure while still providing the functionality needed to manage modals effectively.
##  Resizing Modals 
Modal overlays can now be dynamically resized by embedded applications using the MessageChannel API. Applications launching with a `DEFAULT_MODAL` target can send a `RESIZE` message to adjust the modal's width and/or height:
    ```html
    <script>
        let messagePort = null;
        // Listen for the port transfer from the Canvas Application
        window.addEventListener('message', (event) => {
          // Check if this is the INIT_CHANNEL message with a port
          if (event.data?.type === 'INIT_CHANNEL' && event.ports?.[0]) {
            // Store the port for later use
            messagePort = event.ports[0];
            messagePort.start();
            // Example: Resize modal to specific dimensions
            messagePort.postMessage({
              type: 'RESIZE',
              width: 800,  // pixels
              height: 600  // pixels
            });
          }
        });
    </script>
    ```
This enables embedded applications to optimize their display area based on content requirements, improving the user experience for dynamic or responsive plugin interfaces.
##  Portal Landing Page Widgets 
The `PortalWidget` class allows you to add widgets of various sizes to the patient portal landing page. You can fully customize your widgets or leverage ready-made widgets provided by Canvas, such as Appointments and Messaging.
###  Example Usage 
    ```python
    from canvas_sdk.effects.widgets import PortalWidget
    class PortalWidgetHandler:
        def compute(self):
            portal_widget = PortalWidget(
                url="https://example.com/info",
                size=PortalWidget.Size.COMPACT,
                priority=25
            )
            return [portal_widget.apply()]
    ```
The `PortalWidget` class has the following properties:
  - **url** : A string containing the URL to load within the widget. If either `content` or `component` is specified, an error will be raised.
  - **content** : A string containing the content to be displayed directly within the widget. If either `url` or `component` is provided, an error will be raised.
  - **component** : Choose one of ready-made widgets made by Canvas. If either `url` or `content` is provided, an error will be raised. The available ready-made widgets include: 
    - `APPOINTMENTS`: Displays upcoming appointments.
    - `MESSAGING`: Enables quick messaging.
  - **Size** : Determines the widget's layout on the frontend grid: 
    - `EXPANDED`: Fills an entire row (12 columns).
    - `MEDIUM`: Occupies 8 columns.
    - `COMPACT`: Occupies 4 columns.
    - **Note: All sizes have a fixed height of 300px.**
  - **priority** : This value is used to order the widgets within the patient portal. A lower number indicates a higher priority.
##  Custom HTML and Django Templates 
To facilitate the use of custom HTML, you can utilize the `render_to_string` utility from `canvas_sdk.templates` to render Django templates with a specified context. This allows for dynamic rendering of HTML that can be passed to a `LaunchModalEffect` or `PortalWidget`.
    ```python
    from typing import Any
    def render_to_string(template_name: str, context: dict[str, Any] | None = None) -> str | None:
        """Load a template and render it with the given context.
        Args:
            template_name (str): The path to the template file, relative to the plugin package.
                If the path starts with a forward slash ("/"), it will be stripped during resolution.
            context (dict[str, Any] | None): A dictionary of variables to pass to the template
                for rendering. Defaults to None, which uses an empty context.
        Returns:
            str: The rendered template as a string.
        Raises:
            FileNotFoundError: If the template file does not exist within the plugin's directory
                or if the resolved path is invalid.
        """
    ```
####  Example Template 
Consider a simple HTML file named `templates/custom_content.html`:
    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <title>{{ title }}</title>
      </head>
      <body>
        <h1>{{ heading }}</h1>
        <p>{{ message }}</p>
      </body>
    </html>
    ```
This template uses Django template placeholders like `{{ title }}`, `{{ heading }}`, and `{{ message }}` to dynamically render content based on the provided context.
####  Rendering the Template in Python 
Here's how you can use the `render_to_string` utility to render the template and pass the resulting HTML to a `LaunchModalEffect` or `PortalWidget`:
    ```python
    from canvas_sdk.effects.launch_modal import LaunchModalEffect
    from canvas_sdk.effects.widgets import PortalWidget
    from canvas_sdk.templates import render_to_string
    class ModalEffectHandler:
        def compute(self):
            # Define the context for the template
            context = {
                "title": "Welcome Modal",
                "heading": "Hello, User!",
                "message": "This is a dynamically rendered modal using Django templates."
            }
            # Render the HTML content using the template and context
            rendered_html = render_to_string("templates/custom_content.html", context)
            # Create a LaunchModalEffect with the rendered content
            modal_effect = LaunchModalEffect(
                content=rendered_html,
                target=LaunchModalEffect.TargetType.DEFAULT_MODAL
            )
            return [modal_effect.apply()]
    class PortalWidgetHandler:
        def compute(self):
            # Define the context for the template
            context = {
                "title": "Welcome Modal",
                "heading": "Hello, User!",
                "message": "This is a dynamically rendered modal using Django templates."
            }
            # Render the HTML content using the template and context
            rendered_html = render_to_string("templates/custom_content.html", context)
            # Create a PortalWidget with the rendered content
            portal_widget = PortalWidget(
                content=rendered_html,
                size=PortalWidget.Size.COMPACT,
                priority=25
            )
            return [portal_widget.apply()]
    ```
##  Additional Configuration 
To use URLs or custom scripts within the `LaunchModalEffect` or `PortalWidget`, additional security configurations must be specified in the `CANVAS_MANIFEST.json` file of your plugin.
  - **Allowing URLs** : URLs specified in the **url** property must be added to the `url_permissions` section of the `CANVAS_MANIFEST.json` in order for the URL to load properly.
  - **Allowing custom scripts** : If you need to load scripts from an external source, the URL for the script must be added to the `url_permissions` section of the `CANVAS_MANIFEST.json` and `'SCRIPTS'` must be in the permissions list.
  - **Requesting microphone access** : If the site in your modal or widget needs microphone access, `'MICROPHONE'` must be in the URL's permissions list.
  - **Requesting camera access** : If the site in your modal or widget needs camera access, `'CAMERA'` must be in the URL's permissions list.
  - **Allowing browser access to cookies from the iframe's origin** : If you want the loaded URL to access cookies for its domain, `'ALLOW_SAME_ORIGIN'` must be in the URL's permissions list. If the URL you're loading requires authentication, this will prevent your user from having to log in each time the modal is launched.
The URLs must match the format available [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#host-source).
    ```json
    {
      "sdk_version": "0.1.4",
      "plugin_version": "0.0.1",
      "name": "custom_html",
      "description": "...",
      "url_permissions": [
        {
          "url": "https://example.com/info",
          "permissions": ["ALLOW_SAME_ORIGIN", "MICROPHONE", "CAMERA"]
        },
        {
          "url": "https://d3js.org/d3.v4.js",
          "permissions": ["SCRIPTS"]
        }
      ]
    }
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/layout-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/patient-chart-group-effect/
##  Overview 
This effect allows developers to group items in a patient chart section. You can define multiple groups with a name, priority, and the items that belong to each group.
Currently, this is supported for the Conditions, Medications, and Detected Issues sections.
    ```python
    from canvas_sdk.effects.patient_chart_group import PatientChartGroup
    from canvas_sdk.effects.group import Group
    conditions = [{
        "id": 1,
        "codings": {
          "code": "111",
          "system": "ICD-10",
          "display": "Ophiasis",
        }
      }, {
        "id": 2,
        "codings": {
          "code": "112",
          "system": "ICD-10",
          "display": "Acute angle-closure glaucoma",
        }
    }]
    PatientChartGroup(items=[
      {
        "Psychiatry": Group(priority=100, items=conditions, name="Psychiatry")
      },
      {
        "General": Group(priority=200, items=conditions, name="General")
      }
    ])
    ```
##  Structure 
###  **Group**
A Group consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`items` | `list` | list of items for each group, ex: [Condition] or [Medication]  
`priority` | `int` | the group's priority within the section.  
`name` | `str` | the group label.  
###  **PatientChartGroup**
A PatientChartGroup consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`items` | `dict[str, Group]` | list of Groups  
----- END PAGE https://docs.canvasmedical.com/sdk/patient-chart-group-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/patient-metadata-create-form-effect/
##  Overview 
This allows developers to dynamically display additional fields in the patient profile. For more guidance please reference ["How to add additional profile fields" guide](https://docs.canvasmedical.com/guides/profile-additional-fields/).
    ```python
    from canvas_sdk.effects.patient_metadata import PatientMetadataCreateFormEffect, InputType, FormField
    PatientMetadataCreateFormEffect(form_fields=[
        FormField(
            key='status',
            label='Status',
            type=InputType.SELECT,
            required=False,
            editable=True,
            options=["open", "close"]
        ),
    ])
    ```
##  Structure 
###  **FormField**
A FormField consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`key` | `str` | unique identifier of the field - patient metadata key  
`label` | `str` | the label that will be displayed on the field  
`type` | `InputType` | the type of the input - TEXT, SELECT, DATE.  
`required` | `bool` | if the input is required.  
`editable` | `bool` | if the input can be editabled.  
`options` | `list[str]` | possible options for when the input type is set to "SELECT"  
###  **PatientMetadataCreateFormEffect**
A PatientMetadataCreateFormEffect consists of the following properties:
####  Attributes 
Attribute | Type | Description  
---|---|---  
`form_fields` | `list[FormField]` | list of fields.  
----- END PAGE https://docs.canvasmedical.com/sdk/patient-metadata-create-form-effect/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/patient-portal/
The Canvas SDK allows you to configure the patient portal.
##  Configuring the Patient Portal 
To configure the patient portal, you can use the `PatientPortalApplicationConfiguration` effect
Attribute | Type | Description  
---|---|---  
can_schedule_appointments | bool | If the patient is allowed to book or reschedule appointments  
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.patient_portal.application_configuration import PatientPortalApplicationConfiguration
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__GET_APPLICATION_CONFIGURATION)
        def compute(self) -> list[Effect]:
            return [
              PatientPortalApplicationConfiguration(
                can_schedule_appointments=True
              ).apply()
            ]
    ```
##  Customize Landing Page (Portal Widgets) 
To customize the landing page you can leverage the [Portal Widgets](/sdk/layout-effect/#portal-landing-page-widgets) effect.
Visit our guide [Tailoring Portal Landing Page](/guides/custom-landing-page/) for examples.
##  Customize Appointment Cards 
Customize your patient appointment cards so patients can easily join their telehealth appointments, cancel or reschedule appointments. Each appointment can be customized individually, allowing each one to have its own unique settings.
###  Hide 'Cancel' button 
    ```python
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__APPOINTMENT_CAN_BE_CANCELED)
        def compute(self) -> list[Effect]:
            return [
              Effect(
                type=EffectType.PATIENT_PORTAL__APPOINTMENT_IS_CANCELABLE,
                payload=json.dumps({"result": False}))
            ]
    ```
###  Hide 'Reschedule' button 
    ```python
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__APPOINTMENT_CAN_BE_RESCHEDULED)
        def compute(self) -> list[Effect]:
            return [
              Effect(
                type=EffectType.PATIENT_PORTAL__APPOINTMENT_IS_RESCHEDULABLE,
                payload=json.dumps({"result": False}))
            ]
    ```
###  Hide 'Join' button 
This button shows on telehealth appointments
    ```python
    import json
    from canvas_sdk.effects import Effect, EffectType
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_PORTAL__APPOINTMENT_CAN_SHOW_MEETING_LINK)
        def compute(self) -> list[Effect]:
            return [
              Effect(
                type=EffectType.PATIENT_PORTAL__APPOINTMENT_SHOW_MEETING_LINK,
                payload=json.dumps({"result": True}))
            ]
    ```
##  Update User 
This effect is intended for updating a user's phone number or email. In the future, we may expand its capabilities to support additional attributes, but for now, only these two are supported.
Attribute | Type | Description  
---|---|---  
`user_dbid` | `str | UUID` | The unique ID of the User.  
`phone_number` | `str` | Specifies the phone number to be stored.  
`email` | `str` | Specifies the email to be stored.  
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.update_user import UpdateUserEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import PatientContactPoint
    class ContactPoint(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.PATIENT_CONTACT_POINT_UPDATED)]
        def compute(self) -> list[Effect]:
            contact_point = PatientContactPoint.objects.get(id=self.target)
            patient = contact_point.patient
            return [
                UpdateUserEffect(user_dbid=patient.user.dbid, email="test@email.com", phone_number="1234567890").apply(),
            ]
    ```
##  Send Invite 
This effect triggers a portal invitation that allows the patient to register or activate their account on the patient portal.
Attribute | Type | Description  
---|---|---  
`user_dbid` | `str | UUID` | The unique ID of the User.  
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.send_invite import SendInviteEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.handlers import BaseHandler
    from canvas_sdk.v1.data import PatientContactPoint
    class ContactPoint(BaseHandler):
        RESPONDS_TO = [EventType.Name(EventType.PATIENT_CONTACT_POINT_UPDATED)]
        def compute(self) -> list[Effect]:
            contact_point = PatientContactPoint.objects.get(id=self.target)
            patient = contact_point.patient
            return [
                SendInviteEffect(user_dbid=patient.user.dbid).apply(),
            ]
    ```
##  Send Contact Verification 
The `SendContactVerification` effect instructs Canvas to send a verification (for example, an email or SMS code) to a specific Patient Contact Point. Typical uses are verifying a patient's email address or phone number before enabling patient-portal features that require a verified contact channel.
Attribute | Type | Description  
---|---|---  
`contact_point_id` | `str` or `UUID` | The id of the [`PatientContactPoint`](/sdk/effect-patient/#patientcontactpoint) to verify.  
###  Validation & Errors 
When an effect is prepared, the model validates inputs and returns structured error details if something is invalid.
  - **Contact Point Exists** — The effect verifies the provided `contact_point_id` maps to an existing `PatientContactPoint` record. If no matching record exists the effect will include an error detail with message: `Patient Contact Point does not exist`.
###  Caveats 
  - Emitting this effect will trigger a save to the associated `PatientContactPoint`. If your plugin sends `SendContactVerification` in direct response to a `PATIENT_CONTACT_POINT_UPDATED` event, the save triggered by the effect can cause the same event to fire again, producing an infinite event loop. To avoid this, debounce or detect origin (for example, ignore updates originating from the plugin runner or set a transient flag on the model) before emitting the effect in response to contact point update events.
###  Example Usage 
    ```python
    from canvas_sdk.effects import Effect
    from canvas_sdk.effects.send_contact_verification import SendContactVerificationEffect
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols import BaseProtocol
    class Protocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.PATIENT_CONTACT_POINT_CREATED)
        def compute(self) -> list[Effect]:
            contact_point_id = self.event.target
            verification_effect = SendContactVerificationEffect(contact_point_id=contact_point_id)
            return [verification_effect.apply()]
    ```
###  Notes 
  - This effect only triggers a verification send for the contact point. It does not mark the contact as verified — verification completion is handled by the platform when the patient completes the challenge.
  - The effect relies on `PatientContactPoint` existing in the database. If your integration creates contact points in the same operation, ensure they are persisted before emitting this effect.
----- END PAGE https://docs.canvasmedical.com/sdk/patient-portal/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/plugin-logs/
Canvas provides two ways to access **Plugin Logs** :
  - **UI:** `https://<your-instance>.canvasmedical.com/admin/plugin-io` → **Logs**
  - **CLI:** `canvas logs --help`
This guide explains how to open the UI view and how to use the CLI to filter, paginate, and (optionally) follow live logs.
* * *
###  Plugin Logs in the Admin UI 
From the Django Admin:
Navigation path:  
`Home` › `Plugin_IO` › **Plugin Logs**
The UI lets you:
  - Filter by **source** (e.g., `plugin-runner`, `effect-interpreter`)
  - Filter by **level** (`ERROR`, `WARN`, `INFO`, `DEBUG`)
  - Filter by **time** (start/end)
  - Inspect **full JSON** of a log entry in a modal
  - **Load more** results without leaving the page
> **Info:** The UI defaults to showing the most recent logs first (sorted by `@timestamp desc`). 
* * *
###  CLI Overview 
`canvas logs` now supports **historical lookback** , **filters** , **stateless pagination** with **cursors** , and **interactive paging** , all without breaking the original behavior.
  - **Default (no flags)** → live stream (unchanged)
  - **Add a time window** → fetch history (tail), then **follow** by default
  - **Stop after history** → `--no-follow`
  - **Page through large result sets** → `--limit`, `--page-size`, `--interactive`, or **cursor** tokens
Run `canvas logs --help` to see all options.
###  Common Filters & Examples 
#####  Filter by source 
    ```console
    $ canvas logs --source plugin-runner
    ```
#####  Filter by level (repeat flag) 
    ```console
    # Only errors:
    $ canvas logs --level ERROR
    # Errors and warnings:
    $ canvas logs --level ERROR --level WARN
    ```
#####  Time windows: since / start / end 
**Relative lookback (`--since`)**  
Fetch the last 24 hours, then continue following:
    ```console
    $ canvas logs --since 24h
    ```
**Absolute window (`--start/--end`)**  
Fetch a fixed window and stop:
    ```console
    $ canvas logs --start "2025-09-12T10:00:00Z" --end "2025-09-12T12:00:00Z" --no-follow
    ```
> **Info:** `--since` is mutually exclusive with `--start/--end`. 
#####  Combine filters 
    ```console
    # Errors from plugin-runner in the last 2 hours:
    $ canvas logs --since 2h --level ERROR --source plugin-runner --no-follow
    ```
* * *
###  Interactive Mode 
Use `--interactive` in **historical** mode to page through results one page at a time:
    ```console
    $ canvas logs --no-follow --since 24h --interactive
    # Shows one page, prompts:
    # Load more? [Y/n]
    ```
  - The prompt repeats after each page.
* * *
###  Stateless Paging with Cursors 
When more results are available, the CLI prints a **resume command** with a **cursor token** (encodes the `search_after` and original filters). Re-run it to continue exactly where you left off:
    ```console
    More available. To load the next page, run:
      canvas logs \
      --no-follow \
      --cursor <TOKEN>
    ```
> **Warning:** `--cursor` is **mutually exclusive** with filters (`--since`, `--start/--end`, `--level`, `--source`) to enforce consistency. Use the token alone to resume 
.
* * *
###  Limits & Page Size 
  - **`--page-size`** : how many logs to fetch per request (batching).  
Default is optimized for typical usage.
  - **`--limit`** : maximum number of logs to print **across pages**.
Examples:
    ```console
    # One fixed page of size 200 (default page-size):
    $ canvas logs --no-follow --since 24h
    # Fetch up to 2000 logs across pages (non-interactive):
    $ canvas logs --no-follow --since 72h --limit 2000
    # Smaller batches for slow connections:
    $ canvas logs --no-follow --since 24h --limit 1000 --page-size 100
    ```
> **Info:** In non-interactive, no-limit mode, the CLI prints **one page**. Add `--limit`, `--interactive`, or `--all` to keep paging. 
* * *
###  No-Follow (Historical Only) 
Add `--no-follow` to fetch **only** historical logs and exit:
    ```console
    $ canvas logs --no-follow --since 24h
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/plugin-logs/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/protocols/
The protocols module lets you define workflows and workflow automations.
Protocols respond to [Events](/sdk/events/) and return zero, one, or many [Effects](/sdk/effects/).
##  Contents 
  - BaseProtocol
  - ClinicalQualityMeasure
##  BaseProtocol 
`BaseProtocol` is the abstract base class all protocol implementations inherit from. It extends the handler contract (`BaseHandler`) and provides the lifecycle and surface area plugin authors implement for event-driven protocols.
###  Purpose & lifecycle 
  - The framework will call `compute()` on the protocol instance when an event should be handled. `compute()` must return a list of `Effect` objects that the runtime will apply.
  - Protocols must override the `compute()` method.
###  Constructor and attributes 
  - Your protocol should inherit from `BaseProtocol` and define the following:
    - `RESPONDS_TO` — The `Event(s)` that trigger the protocol.
    - `compute` — The method that handles the Event and returns a list of Effects.
  - Instance attributes available to protocol authors:
    - `self.event` — The `Event` instance.
    - `self.secrets` — Secrets provided to the protocol (defaults to {}).
###  Example 
    ```python
    from canvas_sdk.protocols.base import BaseProtocol
    from canvas_sdk.events import EventType
    from canvas_sdk.effects.task import AddTask
    class SimpleFollowUpProtocol(BaseProtocol):
        RESPONDS_TO = EventType.Name(EventType.IMAGING_REPORT_CREATED)
        def compute(self):
            # Use self.event, self.secrets
            patient_id = self.event.context["patient"]["id"]
            imaging_report_id = self.event.target.id
            # Create a follow-up task effect
            return [AddTask(patient_id=patient_id, title="Follow-up", linked_object_type=AddTask.LinkableObjectType.IMAGING, linked_object_id=imaging_report_id).apply()]
    ```
##  ClinicalQualityMeasure 
`ClinicalQualityMeasure` is the base class for clinical quality measure (CQM) protocols. CQMs are patient-centric protocols used to evaluate, detect, or surface clinical conditions, gaps in care, and population-level metrics. Plugin authors create concrete subclasses that implement the clinical logic and return Effects in response to incoming Events.
When using `ClinicalQualityMeasure`, you have the option to utilize the [Campaigns](https://help.canvasmedical.com/articles/3097826946-campaigns-populations-patients) module in Canvas. However, the `ClinicalQualityMeasure` must return a single [`ProtocolCard`](/sdk/effect-protocol-cards/) effect in order to for patients to be included in the population for that CQM.
###  Meta properties 
Subclasses should populate the `Meta` inner class. Common meta fields include:
  - `title` (str): Human-readable title for the protocol.
  - `identifiers` (list[str]): One or more external identifiers for the measure (for example, CMS/QDM ids). These will show in the subtitle of the protocol card.
  - `description` (str): A short description of what the measure evaluates.
  - `information` (str): Longer contextual information or rationale.
  - `references` (list[str]): Links or identifiers for authoritative references. These are visible in the info button on the protocol card.
  - `source_attributes` (dict[str, str]): Map of the 13 or 31 source attributes that certified health IT developers must reference when implementing DSI or PDSI. These are visible in the info button on the protocol card.
  - `types` (list[str]): Tags or classification strings for the measure, like "CQM" or "HCC". These are visible in the subtitle of the protocol card.
  - `authors` (list[str]): Authors or maintainers of the protocol.
  - `show_in_chart` (bool): Determines whether the protocol card will show on the patient's chart.
  - `show_in_population` (bool): Determines whether the protocol will be included in the Campaigns module of Canvas.
  - `can_be_snoozed` (bool): Determines whether a user can snooze the protocol card to be addressed at a later date.
  - `is_abstract`, `is_predictive` (bool): Behavioral flags for the framework.
###  Key methods 
  - `timeframe` (property) -> `Timeframe`
    - Provides the default timeframe used by the protocol when searching for relevant events or records. The default implementation returns a timeframe with a start one year before now and an end at the current time. Subclasses can override this property to adjust the window of interest.
  - `relative_float(value: str) -> float`
    - Parses comparison-style numeric strings that may include relational prefixes like `<`, `<=`, `>` or `>=`. Returns a float adjusted slightly (±1e-6) for strict `<` or `>` operators so comparisons can be expressed without ambiguity. If parsing fails, returns `0`.
  - `patient_id_from_target()` -> str
    - Extracts and caches the patient id from a protocol event target for supported event types. The method supports a variety of patient-centric event targets (Conditions, LabOrders, LabReports, Medications, Patient create/update events, and ProtocolOverride events). The first call will fetch and cache the patient id to avoid repeated DB lookups. If an unsupported event type is provided a `ValueError` is raised.
###  Example — react to a lab report 
This example shows a protocol that reacts to `LAB_REPORT_CREATED` events, uses `patient_id_from_target` to determine which patient the report belongs to, and emits an Effect when a particular lab value is out of range. Note the example avoids heavy synchronous DB work and emits an Effect for the platform to handle asynchronously.
    ```python
    from datetime import datetime
    from canvas_sdk.commands import TaskCommand
    from canvas_sdk.effects.protocol_card import ProtocolCard
    from canvas_sdk.events import EventType
    from canvas_sdk.protocols.clinical_quality_measure import ClinicalQualityMeasure
    class AbnormalPotassiumMeasure(ClinicalQualityMeasure):
        """Detects clinically significant potassium abnormalities and surfaces follow-up tasks."""
        class Meta:
            title = "Abnormal Potassium Alert"
            identifiers = ["CQM-K-001"]
            description = "Creates a task recommendation when a potassium lab report shows hypokalemia or hyperkalemia."
            information = (
                "Detects clinically significant potassium abnormalities and surfaces follow-up tasks."
            )
            references = ["Potassium Guideline https://example.org/guideline/potassium"]
            source_attributes = {"Canvas Medical": "Canvas Medical https://www.canvasmedical.com"}
            types = ["CQM"]
            authors = ["Clinical Team"]
            show_in_chart = True
            show_in_population = True
            can_be_snoozed = False
            is_abstract = False
            is_predictive = False
        RESPONDS_TO = EventType.Name(EventType.LAB_REPORT_CREATED)
        def compute(self):
            # Resolve patient id (cached on first call)
            patient_id = self.patient_id_from_target()
            # Read the lab report values from the event target (avoid extra DB queries here)
            report = self.event.target
            potassium_value = report.get_value('potassium')  # simplified accessor
            # Use relative_float to safely parse any comparator-style values
            k = self.relative_float(str(potassium_value))
            if k < 3.5 or k > 5.5:
                # Emit an effect — e.g., create a task. Keep heavy work to platform handlers.
                task = TaskCommand(
                    title="Follow-up on abnormal potassium",
                    due_date=datetime.now().date(),
                )
                return [
                    ProtocolCard(
                        patient_id=patient_id,
                        title=f"Abnormal potassium: {k}",
                        due=datetime.now(),
                        key="abnormal_potassium",
                        narrative="Talk to patient about potassium",
                        recommendations=[task.recommend(title="Follow-up on abnormal potassium")],
                    ).apply()
                ]
            return []
    ```
![ProtocolCard]("/assets/images/sdk/handlers/protocol_card_example.png")
When a CQM protocol that returns a single ProtocolCard effect is uploaded to Canvas, you can select the protocol as an option in the Campaigns module and view the population of patients, create campaigns, etc. More details on Populations and Campaigns can be found [here](https://help.canvasmedical.com/articles/3097826946-campaigns-populations-patients).
###  Caveats & notes 
  - Timeframe: by default the protocol looks at the 1-year window prior to now. Override `timeframe` if your measure requires a broader or narrower lookback.
  - patient id resolution: `patient_id_from_target()` supports only the event types enumerated by the implementation; verify the event you plan to subscribe to maps to a supported model. When used heavily, this method avoids extra DB queries by caching the patient id on the instance.
  - Event-driven protocols should avoid expensive synchronous DB operations inside their event handler. When possible, emit Effects that are handled asynchronously by the platform.
----- END PAGE https://docs.canvasmedical.com/sdk/protocols/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/questionnaires/
Questionnaires are a structured set of questions intended to guide the collection of answers from end-users.
##  How to build and install a Questionnaire 
To include a questionnaire in your plugin, add a reference to its YAML template inside the `questionnaires` section of the `CANVAS_MANIFEST.json` file.
###  Example Manifest Configuration 
    ```json
    {
        "sdk_version": "0.1.4",
        "plugin_version": "0.0.1",
        "name": "example_questionnaire",
        "description": "Edit the description in CANVAS_MANIFEST.json",
        "components": {
            "protocols": [],
            "commands": [],
            "content": [],
            "effects": [],
            "views": [],
            "questionnaires": [
                {
                    "template": "templates/example_questionnaire.yml"
                }
            ]
        },
        "secrets": [],
        "tags": {},
        "references": [],
        "license": "",
        "diagram": false,
        "readme": "./README.md"
    }
    ```
###  Key Properties 
  - **`template`** : The relative path to the YAML file defining the questionnaire.
The questionnaire YAML file should adhere to the JSON schema found [here](https://raw.githubusercontent.com/canvas-medical/canvas-plugins/main/schemas/questionnaire.json) that is also listed below.
##  JSON Schema Reference 
###  Questionnaire Settings 
Property | Description | Required  
---|---|---  
`name` | Name of the Questionnaire. | Yes  
`form_type` | Specifies the use case: `QUES` (Questionnaire), `SA` (Structured Assessment), `EXAM` (Physical Exam), or `ROS` (Review of Systems). | Yes  
`code_system` | The coding system used for the questionnaire, e.g., `SNOMED`, `LOINC`, `INTERNAL`, `ICD-10`, `CPT`, `CANVAS`. | Yes  
`code` | The assigned code for the questionnaire (e.g., `72109-2`). | Yes  
`can_originate_in_charting` | Specifies if the questionnaire can be initiated from charting. Values: `TRUE` or `FALSE`. | Yes  
`prologue` | Text displayed at the beginning of the questionnaire to provide context to the user. | No  
`display_results_in_social_history_section` | Determines if completion information should be displayed in the Social History (SHX) section. Values: `TRUE` or `FALSE`. Default: `FALSE`. | No  
`questions` | List of questions in the questionnaire. See below. | Yes  
###  Question Settings 
Property | Description | Required  
---|---|---  
`code_system` | The coding system for the question. Options: `SNOMED`, `LOINC`, `INTERNAL`, `ICD-10`, `CPT`, `CANVAS`. | Yes  
`code` | The assigned code for the question. Example: `44250-9`. Codes should be unique within the same questionnaire. | Yes  
`content` | The text displayed when the command is printed. | Yes  
`responses_code_system` | The coding system for responses. Options: `SNOMED`, `LOINC`, `INTERNAL`, `ICD-10`, `CPT`. | Yes  
`responses_type` | Response type: `SING` (Single Select), `MULT` (Multi Select), `TXT` (Free Text). | Yes  
`display_result_in_social_history_section` | Determines if the response should be shown in the Social History (SHX) section. Values: `TRUE` or `FALSE`. Default: `FALSE`. | No  
`responses` | List of responses for the question. See below. | Yes  
###  Response Settings 
Property | Description | Required  
---|---|---  
`name` | For `SING`/`MULT`, this is the text that will be displayed for each response. For `TXT`, enter "TXT". | Yes  
`code` | The assigned code for the response. Example: `Z759`. No response codes should be reused within the same question. | Yes  
`value` | For `SING`/`MULT`, leave blank if no scoring is desired. If scoring is desired, insert the numerical value assigned. | No  
###  Example Questionnaire Definition 
    ```yaml
    name: Example Name
    form_type: QUES
    code_system: LOINC
    code: QUES_EXAMPLE_NAME
    can_originate_in_charting: true
    prologue: This is an example of a structured assessment with single select, multiselect, and free text responses.
    questions:
      - content: "This is question #1"
        code_system: CPT
        code: H0005
        responses_code_system: INTERNAL
        responses_type: SING
        display_result_in_social_history_section: true
        responses:
          - name: "Single select response #1"
            code: QUES_EXAMPLE_NAME_Q1_A1
            value: "1"
          - name: "Single select response #2"
            code: QUES_EXAMPLE_NAME_Q1_A2
            value: "0"
          - name: "Single select response #3"
            code: QUES_EXAMPLE_NAME_Q1_A3
            value: "0"
      - content: "This is question #2"
        code_system: INTERNAL
        code: QUES_EXAMPLE_NAME_Q2
        responses_code_system: ICD-10
        responses_type: MULT
        display_result_in_social_history_section: true
        responses:
          - name: "Multi select response #1"
            code: F1910
            value: "0"
          - name: "Multi select response #2"
            code: QUES_EXAMPLE_NAME_Q1_A1
            value: "2"
          - name: "Multi select response #3"
            code: QUES_EXAMPLE_NAME_Q1_A2
            value: "0"
      - content: "This is question #3"
        code_system: INTERNAL
        code: QUES_EXAMPLE_NAME_Q3
        responses_code_system: INTERNAL
        responses_type: TXT
        display_result_in_social_history_section: true
        responses:
          - name: "Free text response"
            code: QUES_EXAMPLE_NAME_Q3_A1
            value: "This is a default pre-populated free text response."
    ```
##  Load Questionnaire definition from YAML file 
You can use the `questionnaire_from_yaml` function from `canvas_sdk.questionnaires` within your plugin to load a questionnaire definition from a YAML file. The function takes the path to the YAML file as an argument and returns a dictionary containing the questionnaire definition.
    ```python
    def questionnaire_from_yaml(questionnaire_name: str, **kwargs):
        """Load a Questionnaire configuration from a YAML file.
        Args:
            questionnaire_name (str): The path to the questionnaire file, relative to the plugin package.
                If the path starts with a forward slash ("/"), it will be stripped during resolution.
            kwargs (Any): Additional keyword arguments.
        Returns:
            QuestionnaireConfig: The loaded Questionnaire configuration.
        Raises:
            FileNotFoundError: If the questionnaire file does not exist within the plugin's directory
                or if the resolved path is invalid.
            PermissionError: If the resolved path is outside the plugin's directory.
            ValidationError: If the questionnaire file does not conform to the JSON schema.
        """
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/questionnaires/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/sandboxing-and-allowed-imports/
Plugins developed with the Canvas SDK operate within a sandboxed environment. This sandbox strictly limits access to the host operating system, filesystem, and database. This security measure is designed to mitigate risks associated with accidental misconfigurations or malicious activities, thereby safeguarding sensitive patient data.
##  Standard Library Modules 
The following Python standard library modules and their allowed imports are available within the sandbox:
#####  `__future__`
Provides access to features from future Python versions for backwards compatibility. [read more](https://docs.python.org/3/library/__future__.html)
  - `annotations`
#####  `abc`
Provides infrastructure for defining Abstract Base Classes (ABCs) to enforce interfaces and create structured inheritance hierarchies. [read more](https://docs.python.org/3/library/abc.html)
  - `ABC`
  - `abstractmethod`
#####  `base64`
Provides functions for encoding and decoding data in base64 format, commonly used for data transmission and storage. [read more](https://docs.python.org/3/library/base64.html)
  - `b64decode`
  - `b64encode`
#####  `collections`
Provides specialized container datatypes that extend beyond the built-in types like lists and dictionaries. [read more](https://docs.python.org/3/library/collections.html)
  - `Counter`
  - `defaultdict`
#####  `dataclasses`
This module provides a decorator and functions for automatically adding generated special methods such as **init**() and **repr**() to user-defined classes. [read more](https://docs.python.org/3/library/dataclasses.html)
  - `asdict`
  - `astuple`
  - `dataclass`
  - `field`
  - `Field`
  - `fields`
  - `InitVar`
  - `replace`
#####  `datetime`
Provides classes for working with dates and times, essential for medical applications that need to track appointment schedules and patient timelines. [read more](https://docs.python.org/3/library/datetime.html)
  - `date`
  - `datetime`
  - `timedelta`
  - `timezone`
  - `UTC`
#####  `dateutil`
Extends Python's datetime capabilities with more flexible date parsing and arithmetic. [read more](https://dateutil.readthedocs.io/en/stable/)
  - `relativedelta`
#####  `dateutil.relativedelta`
Provides relative time delta calculations for more complex date arithmetic operations. [read more](https://dateutil.readthedocs.io/en/stable/relativedelta.html)
  - `relativedelta`
#####  `decimal`
Provides precise decimal arithmetic for financial and scientific calculations where floating-point accuracy is critical. [read more](https://docs.python.org/3/library/decimal.html)
  - `Decimal`
#####  `defusedxml.ElementTree`
The defusedxml package contains several Python-only workarounds and fixes for denial of service and other vulnerabilities in Python's XML libraries. [read more](https://pypi.org/project/defusedxml/)
  - `fromstring`
#####  `enum`
Provides support for enumerations, useful for defining sets of named constants such as status codes or categories. [read more](https://docs.python.org/3/library/enum.html)
  - `Enum`
  - `StrEnum`
#####  `functools`
Provides utilities for higher-order functions and operations on callable objects. [read more](https://docs.python.org/3/library/functools.html)
  - `reduce`
#####  `hashlib`
Provides secure hash and message digest algorithms for data integrity verification and security purposes. [read more](https://docs.python.org/3/library/hashlib.html)
  - `sha256`
#####  `hmac`
Provides hash-based message authentication code (HMAC) functions for secure message authentication. [read more](https://docs.python.org/3/library/hmac.html)
  - `compare_digest`
  - `new`
#####  `http`
Provides HTTP status codes and related constants for web API development and HTTP response handling. [read more](https://docs.python.org/3/library/http.html)
  - `HTTPStatus`
#####  `json`
Provides functions for parsing and generating JSON data, essential for API communication and data serialization. [read more](https://docs.python.org/3/library/json.html)
  - `dumps`
  - `loads`
#####  `operator`
Provides function equivalents of operators for functional programming and complex data operations. [read more](https://docs.python.org/3/library/operator.html)
  - `and_`
#####  `random`
Provides functions for generating random numbers and making random selections, useful for sampling and testing scenarios. [read more](https://docs.python.org/3/library/random.html)
  - `choices`
  - `uniform`
  - `randint`
#####  `re`
Provides regular expression matching operations for pattern matching and text processing. [read more](https://docs.python.org/3/library/re.html)
  - `compile`
  - `DOTALL`
  - `IGNORECASE`
  - `match`
  - `search`
  - `split`
  - `sub`
#####  `string`
Provides string constants and template classes for string manipulation and formatting operations. [read more](https://docs.python.org/3/library/string.html)
  - `ascii_lowercase`
  - `digits`
#####  `time`
Provides time-related functions for measuring execution time and adding delays in processing. [read more](https://docs.python.org/3/library/time.html)
  - `time`
  - `sleep`
#####  `typing`
Provides support for type hints and static type checking to improve code clarity and IDE support. [read more](https://docs.python.org/3/library/typing.html)
  - `Any`
  - `cast`
  - `Dict`
  - `Final`
  - `Iterable`
  - `List`
  - `Literal`
  - `NamedTuple`
  - `NotRequired`
  - `Protocol`
  - `Optional`
  - `Sequence`
  - `Tuple`
  - `Type`
  - `TypeGuard`
  - `TypedDict`
  - `TypeGuard`
  - `Union`
#####  `urllib`
Provides modules for working with URLs, including URL parsing and manipulation. [read more](https://docs.python.org/3/library/urllib.html)
  - `parse`
#####  `urllib.parse`
Provides URL parsing utilities for breaking apart and constructing URLs and query strings. [read more](https://docs.python.org/3/library/urllib.parse.html)
  - `urlencode`
  - `quote`
#####  `uuid`
Provides functions for generating universally unique identifiers (UUIDs) for creating unique record identifiers. [read more](https://docs.python.org/3/library/uuid.html)
  - `uuid4`
  - `UUID`
#####  `zoneinfo`
Provides timezone support for handling datetime objects across different time zones. [read more](https://docs.python.org/3/library/zoneinfo.html)
  - `ZoneInfo`
##  Third-Party Modules 
The following third-party modules and their allowed imports are available within the sandbox:
#####  `arrow`
A human-friendly approach to creating, manipulating, formatting and converting dates and times. [read more](https://arrow.readthedocs.io/en/latest/)
  - `get`
  - `now`
  - `utcnow`
#####  `django.db.models`
Django's database abstraction layer for defining database models and performing queries. [read more](https://docs.djangoproject.com/en/stable/topics/db/models/)
  - `Avg`
  - `BigIntegerField`
  - `Case`
  - `CharField`
  - `Count`
  - `Exists`
  - `IntegerField`
  - `Max`
  - `Min`
  - `Model`
  - `OuterRef`
  - `Prefetch`
  - `Q`
  - `Subquery`
  - `Sum`
  - `Value`
  - `When`
#####  `django.db.models.expressions`
Django's database expressions for complex query operations and conditional logic. [read more](https://docs.djangoproject.com/en/stable/ref/models/expressions/)
  - `Case`
  - `Exists`
  - `OuterRef`
  - `Subquery`
  - `Value`
  - `When`
#####  `django.db.models.query`
Django's QuerySet class for database query operations and result handling. [read more](https://docs.djangoproject.com/en/stable/ref/models/querysets/)
  - `Prefetch`
  - `QuerySet`
#####  `django.utils.functional`
Django's functional programming utilities including caching and lazy evaluation tools. [read more](https://docs.djangoproject.com/en/stable/ref/utils/)
  - `cached_property`
#####  `jwt`
A library for encoding and decoding JSON Web Tokens (JWT) for secure data transmission and authentication. [read more](https://pyjwt.readthedocs.io/en/stable/)
  - `decode`
  - `encode`
  - `ExpiredSignatureError`
  - `InvalidTokenError`
  - `PyJWKClient`
#####  `pydantic`
A data validation library using Python type annotations for parsing and validating data structures. [read more](https://docs.pydantic.dev/)
  - `BaseModel`
  - `conint`
  - `ConfigDict`
  - `constr`
  - `Field`
  - `RootModel`
  - `ValidationError`
#####  `rapidfuzz`
A fast string matching library for fuzzy string comparison and search operations. [read more](https://maxbachmann.github.io/RapidFuzz/)
  - `fuzz`
  - `process`
  - `utils`
#####  `requests`
A simple and elegant HTTP library for making web requests and API calls. [read more](https://docs.python-requests.org/en/latest/)
  - `delete`
  - `get`
  - `patch`
  - `post`
  - `put`
  - `request`
  - `RequestException`
  - `Response`
##  Canvas SDK Modules 
All Canvas SDK modules are available for import and use within your plugins:
  - `canvas_sdk.caching`
  - `canvas_sdk.commands`
  - `canvas_sdk.effects`
  - `canvas_sdk.events`
  - `canvas_sdk.handlers`
  - `canvas_sdk.protocols`
  - `canvas_sdk.questionnaires`
  - `canvas_sdk.templates`
  - `canvas_sdk.utils`
  - `canvas_sdk.v1.data`
  - `canvas_sdk.value_set`
  - `canvas_sdk.views`
  - `logger`
##  Builtin Functions 
The following Python builtin functions are available within the sandbox:
  - `all`
  - `any`
  - `classmethod`
  - `dict`
  - `enumerate`
  - `filter`
  - `getattr`
  - `hasattr`
  - `iter`
  - `list`
  - `map`
  - `max`
  - `min`
  - `next`
  - `property`
  - `reversed`
  - `staticmethod`
  - `sum`
  - `super`
  - `vars`
Plus all the standard safe builtins from RestrictedPython including basic types (`bool`, `int`, `float`, `str`, `tuple`, etc.) and safe operations.
##  Requesting Additional Imports 
If there is a library or function not on this list that you wish to import in your plugin, reach out on the [Canvas developer forum](https://github.com/canvas-medical/canvas-plugins/discussions). Additional imports can often be added after a security review.
The allowed imports are defined in the [Canvas Plugins repository](https://github.com/canvas-medical/canvas-plugins/blob/main/plugin_runner/sandbox.py) and are regularly updated to support common development needs while maintaining security.
##  Policy on Vendor-Specific Libraries: 
The current policy strongly discourages the inclusion of vendor-specific libraries. Introducing such libraries presents several challenges:
  - Vendor Prioritization: It risks implicitly favoring one vendor over others, which can be problematic in a multi-vendor ecosystem.
  - Dependency Bloat: Incorporating libraries for each vendor within a specific category (e.g., AI model providers like OpenAI, Anthropic) leads to a significant increase in overall dependencies.
##  Technical Implications of Excessive Dependencies: 
Adding a multitude of vendor-specific libraries can result in:
  - Increased Memory Usage: Each additional library contributes to the application's memory footprint.
  - Dependency Conflicts: Different libraries may require different versions of shared dependencies, leading to versioning conflicts and system instability.
Given these considerations, the platform maintains a strict and judicious approach to approving and incorporating external libraries or imports.
----- END PAGE https://docs.canvasmedical.com/sdk/sandboxing-and-allowed-imports/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/secrets/
Canvas provides a secure key-value secret store that allows your plugins to access sensitive information (such as API tokens) without hardcoding them into source files. This guide explains how to define, configure, and access secrets within your plugins.
###  Declaring Secrets in `CANVAS_MANIFEST.json`
Secrets are declared in your plugin's `CANVAS_MANIFEST.json` file under the top-level `secrets` field. These declared secrets become available for configuration in the Canvas Admin UI when the plugin is installed.
    ```json
    {
      "sdk_version": "0.1.4",
      "plugin_version": "0.0.1",
      "name": "live_notifications",
      "description": "Edit the description in CANVAS_MANIFEST.json",
      "components": {
        "protocols": [
          {
            "class": "live_notifications.protocols.my_protocol:Protocol",
            "description": "A protocol that does xyz..."
          }
        ]
      },
      "secrets": ["API_TOKEN"],
      "tags": {}
    }
    ```
###  Configuring Secrets in the Admin UI 
Once your plugin is installed, you can update secret values through the Admin interface:
Navigation path: `Home` › `Plugin_IO` › `Plugins` › `(your plugin)`
Or, go directly to:
    https://<your_canvas_instance>/admin/plugin_io/plugin/<plugin_id>/change/
On this page, you will find input fields for each secret defined in your manifest.
![Setting plugin secrets](/assets/images/sdk/secrets/plugins_secrets_settings_with_permissions.png)
Plugin secrets can be protected by managing user permissions. Only users explicitly assigned as "managing users" for a plugin can view or modify its secrets (as well as other sensitive settings like the plugin package file download link). Other users can see basic plugin details and enable or disable plugins, but they will not be able to access or change secret values. To add or remove managing users for a plugin, use the "Managing users" section on the plugin detail page in the Admin UI. This ensures that sensitive configuration, such as API tokens, remains visible only to authorized personnel.
###  Configuring Secrets in the CLI 
You can set secrets either after a plugin is installed or as part of the install. Secrets must be listed under the secrets field in the plugin's `CANVAS_MANIFEST.json`.
Set (or update) secrets on an installed plugin:
    ```console
    $ canvas config set <plugin_name> API_TOKEN=your_api_token_value
    ```
Provide secrets during install:
    ```console
    $ canvas install <plugin_name> --secret API_TOKEN=your_api_token_value
    ```
Set multiple secrets:
    ```console
    # Pass multiple key=value pairs. 
    $ canvas config set <plugin_name> API_TOKEN=abc123 OTHER_KEY=xyz
    # For installs, repeat --secret
    $ canvas install <plugin_name> \
      --secret API_TOKEN=abc123 \
      --secret OTHER_KEY=xyz
    ```
###  Accessing Secrets in Your Plugin 
Secrets defined in your manifest and configured in the admin UI are exposed to your plugin code through the `self.secrets`. This is a Python dictionary containing all secret values.
    ```python
    from canvas_sdk.protocols import BaseProtocol
    from canvas_sdk.effects import Effect
    class Protocol(BaseProtocol):
        def compute(self) -> list[Effect]:
            api_token = self.secrets["API_TOKEN"]
            ...
    ```
----- END PAGE https://docs.canvasmedical.com/sdk/secrets/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/testing-utils/
Canvas SDK provides a streamlined testing environment and local database support to help developers test their plugins with real data.
This guide covers two key capabilities:
  1. Plugin testing with pytest — `canvas[test-utils]` introduces a set of tools and dependencies for writing database-backed tests.
  2. Database seeding in CLI — populate or reset your local database when running plugins locally.
* * *
##  Project Structure 
The recommended layout for plugin development is now scaffolded automatically by the `canvas init` command. This structure ensures compatibility with Canvas testing tools and CLI features, and it's strongly encouraged for all new plugin projects. We also recommend to use [`uv`](https://docs.astral.sh/uv/getting-started/installation/) for managing dependencies.
    ```bash
    plugin-folder/
    ├── my_plugin/
    │   └── ...
    ├── tests/
    │   ├── __init__.py
    │   └── test_example.py
    └── pyproject.toml
    ```
##  Plugin Testing with Pytest 
Installing the `test-utils` extra provides everything needed to test plugins with pytest.
###  Features 
  - `pytest` with `factoryboy` style fixtures
  - Each test is wrapped in a transaction and rolled back automatically.
  - Use actual models or prebuilt factories to generate test data.
  - No need for mocks or fake database layers.
###  Installation 
Add the following to your `pyproject.toml`:
    ```toml
    [project]
    name = "canvas-plugins"
    version = "0.1.0"
    requires-python = ">=3.11,<3.13"
    dependencies = [
        "canvas[test-utils]",
        # other dependencies...
    ]
    ```
or install directly via `uv`:
    ```bash
    uv add "canvas[test-utils]"
    ```
You can now run your test suite using:
    ```bash
    uv run pytest
    ```
###  Using Factories 
Factories simplify test data creation and follow the [`factory_boy`](https://factoryboy.readthedocs.io/en/stable/) pattern.
    ```python
    from canvas_sdk.test_utils.factories import PatientFactory
    def test_factory() -> None:
        patient = PatientFactory.create()
        assert patient.id is not None
    ```
###  Using Models Directly 
You can also create records manually using the model classes:
    ```python
    from canvas_sdk.v1.data.discount import Discount
    def test_model() -> None:
        Discount.objects.create(
            name="10%",
            adjustment_group="30",
            adjustment_code="CO",
            discount=0.10,
        )
        assert Discount.objects.first().pk is not None
    ```
> Whether using a factory or model directly, your test will run inside a transaction and automatically roll back at the end.
###  Available Factories 
All factories are available from:
    ```python
    from canvas_sdk.test_utils import factories
    ```
Developers are encouraged to add new factories for their own models, and to submit PRs with contributions.
At this time, Canvas has factory support for the following models:
  - Claim
  - Claim Diagnosis Code
  - Facility
  - Medication History
  - Note
  - Organization
  - Patient
  - PracticeLocation
  - ProtocolCurrent
  - Staff
  - User
A complete list of available factories is located [here](https://github.com/canvas-medical/canvas-plugins/tree/main/canvas_sdk/test_utils/factories).
##  Local DB Seeding via `run-plugin`
You can run plugins locally with full access to the database using the CLI. Two options are available:
Option | Description  
---|---  
`--db-seed-file` | Path to a Python file that populates your database. _Warning_ : It resets the database before running the seed file.  
`--reset-db` | Clears and recreates the database before running the plugin  
###  Seed the Database 
To seed your plugin's database with test data:
    ```bash
    canvas run-plugin my_plugin --db-seed-file ./seed.py
    ```
Example `seed.py`:
    ```python
    from canvas_sdk.test_utils.factories import PatientFactory
    from canvas_sdk.v1.data.discount import Discount
    PatientFactory.create(first_name="Seeded", last_name="Patient")
    Discount.objects.create(
        name="20%",
        adjustment_group="X",
        adjustment_code="Y",
        discount=0.20
    )
    ```
###  Reset the Database 
To reset the database before running a plugin:
    ```bash
    canvas run-plugin my_plugin --reset-db
    ```
This will remove the existing database (if present) and recreate a clean version.
###  Simulate Events 
After your database is set up, simulate incoming events with:
    ```bash
    canvas emit
    ```
Run `canvas emit --help` for more info.
----- END PAGE https://docs.canvasmedical.com/sdk/testing-utils/


----- BEGIN PAGE https://docs.canvasmedical.com/sdk/utils/
##  Making requests with Http 
The Canvas SDK offers a helper class for completing HTTP calls.
    ```python
    from canvas_sdk.utils import Http
    http = Http()
    ```
###  get 
Sends a GET request.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`url` | _string_ | `true` | The url of the request.  
`headers` | _dict_ | `false` | The headers to include in the request.  
**Example** :
    ```python
    from canvas_sdk.utils import Http
    http = Http()
    http.get("https://my-url.com/", headers={"Authorization": f"Bearer token"})
    ```
###  post 
Sends a POST request.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`url` | _string_ | `true` | The url of the request.  
`headers` | _dict_ | `false` | The headers to include in the request.  
`json` | _dict_ | `false` | The json to include in the request.  
`data` | _dict_ or _string_ | `false` | The data to include in the request.  
**Example** :
    ```python
    from canvas_sdk.utils import Http
    http = Http()
    http.post(
        "https://my-url.com/",
        headers={"Authorization": f"Bearer token"},
        json={"post": "json"},
        data="this-is-my-data"
    )
    ```
###  put 
Sends a PUT request.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`url` | _string_ | `true` | The url of the request.  
`headers` | _dict_ | `false` | The headers to include in the request.  
`json` | _dict_ | `false` | The json to include in the request.  
`data` | _dict_ or _string_ | `false` | The data to include in the request.  
**Example** :
    ```python
    from canvas_sdk.utils import Http
    http = Http()
    http.put(
        "https://my-url.com/",
        headers={"Authorization": f"Bearer token"},
        json={"put": "json"},
        data="this-is-my-data"
    )
    ```
###  patch 
Sends a PATCH request.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`url` | _string_ | `true` | The url of the request.  
`headers` | _dict_ | `false` | The headers to include in the request.  
`json` | _dict_ | `false` | The json to include in the request.  
`data` | _dict_ or _string_ | `false` | The data to include in the request.  
**Example** :
    ```python
    from canvas_sdk.utils import Http
    http = Http()
    http.patch(
        "https://my-url.com/",
        headers={"Authorization": f"Bearer token"},
        json={"patch": "json"},
        data="this-is-my-data"
    )
    ```
##  Making concurrent requests with Http 
There is an interface for executing HTTP requests in parallel.
The `batch_requests` method will execute the requests in parallel using multithreading, and return once all the requests have completed.
The first parameter to the method is an iterable of `BatchableRequest` objects. These can be created with the following helper functions:
    batch_get
    batch_post
    batch_put
    batch_patch
The parameters that these helper functions accept match what the corresponding single-request methods accept.
The `timeout` parameter allows for specifying a timeout value in seconds; if a request has not completed before the timeout value, an error will be returned for that request. The maximum allowed value for `timeout` is 30 seconds. If `timeout` is not specified, it will be set to the maximum value.
The return value will be a list of responses to the requests. The order of the return value will correspond to the order of the provided requests.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`batch_requests` | _Iterable[BatchableRequest]_ | `true` | The list of batched requests.  
`timeout` | _integer_ | `false` | The timeout value in seconds.  
**Example** :
    ```python
    from canvas_sdk.utils import Http, batch_get, batch_post, batch_put, batch_patch
    http = Http()
    requests = [
        batch_get("https://my-url.com/", headers={"Authorization": f"Bearer token"}),
        batch_post("https://my-url.com/", headers={"Authorization": f"Bearer token"}, json={"post": "json"}),
        batch_put("https://my-url.com/", headers={"Authorization": f"Bearer token"}, data="this-is-my-data"),
        batch_patch("https://my-url.com/", headers={"Authorization": f"Bearer token"}, json={"patch": "json"})
    ]
    responses = http.batch_requests(requests, timeout=10)
    ```
##  Making requests to the Ontologies service 
Plugin authors can make requests to our Ontologies service using the `ontologies_http` wrapper.
In addition to the `json()` method of the response, which you'll use to access the response itself, you can also access the `status_code` to verify that the request was succcessful.
###  `fdb_code`
Elsewhere in the SDK there are commands that take an `fdb_code` or `new_fdb_code`, some examples being [`AdjustPrescriptionCommand`](/sdk/commands/#adjustprescription), [`MedicationStatementCommand`](/sdk/commands/#medicationstatement), [`PrescribeCommand`](/sdk/commands/#prescribe), and [`RefillCommand`](/sdk/commands/#refill). The value to be sent as the `fdb_code` is returned in the search payloads below as the `med_medication_id`.
###  Searching for medications 
Plugin authors can search for medications by NDC code, RxNorm RXCUI, FDB code, or full-text search.
    ```python
    from urllib.parse import urlencode
    from canvas_sdk.utils.http import ontologies_http
    # full text search of the medication name, description, and synonyms
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/?{urlencode({'search': 'tylenol'})}").json()
    # response_json contains a "results" key with this object as the first result:
    # {
    #   "results": [
    #     {
    #       "description_and_quantity": "Athenol 325 mg tablet",
    #       "med_medication_id": 436095,
    #       "search_rank": 0.082745634,
    #       "search_terms": "Athenol 325 mg tablet|ACETAMINOPHEN ORAL|ACETAMINOPHEN PO|ACETAMINOPHEN VIA FEEDING TUBE|TYLENOL|TYLENOL ORAL|TYLENOL PO|APAP|APAP ORAL|APAP PO|PANADOL|PANADOL ORAL|PANADOL PO|ATHENOL 325 MG TABLET|ACETAMINOPHEN 325 MG TABLET",
    #       "med_medication_description": "Athenol 325 mg tablet",
    #       "clinical_quantities": [
    #         {
    #           "erx_quantity": "1.0000000",
    #           "representative_ndc": "11822317640",
    #           "clinical_quantity_description": "tablet",
    #           "erx_ncpdp_script_quantity_qualifier_code": "C48542",
    #           "erx_ncpdp_script_quantity_qualifier_description": "Tablet"
    #         }
    #       ],
    #       "etc_path_id": [
    #         3645,
    #         574,
    #         578,
    #         577
    #       ],
    #       "etc_path_name": [
    #         "Analgesic, Anti-inflammatory or Antipyretic",
    #         "Analgesic, Anti-inflammatory or Antipyretic - Non-Opioid",
    #         "Analgesic or Antipyretic Non-Opioid and Combinations",
    #         "Analgesic or Antipyretic Non-Opioid"
    #       ],
    #       "rxnorm_rxcui": "313782"
    #     },
    #     ...
    #   ]
    # }
    # search for a specific RxNorm RXCUI
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/?{urlencode({'rxnorm_rxcui': 313782})}").json()
    # response_json contains the same general format as above
    # search for a specific FDB code (med_medication_id)
    med_medication_id = 123456
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/{med_medication_id}/").json()
    # response_json contains the same general format as above
    # search for multiple FDB codes (med_medication_ids)
    med_medication_ids = [123456, 123457]
    response_json = ontologies_http.get_json(f"/fdb/grouped-medication/{','.join(med_medication_ids)}/").json()
    # response_json contains the same general format as above
    # look up by NDC
    response_json = ontologies_http.get_json(f"/fdb/ndc-to-medication/76420037215/").json()
    # response_json contains this object:
    # {
    #   "description_and_quantity": "Aphen 325 mg tablet",
    #   "med_medication_id": 572345,
    #   "search_terms": "Aphen 325 mg tablet|APHEN 325 MG TABLET|ACETAMINOPHEN 325 MG TABLET",
    #   "med_medication_description": "Aphen 325 mg tablet",
    #   "clinical_quantities": [
    #     {
    #       "erx_quantity": "1.0000000",
    #       "representative_ndc": "76420037215",
    #       "clinical_quantity_description": "tablet",
    #       "erx_ncpdp_script_quantity_qualifier_code": "C48542",
    #       "erx_ncpdp_script_quantity_qualifier_description": "Tablet"
    #     }
    #   ],
    #   "etc_path_id": [
    #     3645,
    #     574,
    #     578,
    #     577
    #   ],
    #   "etc_path_name": [
    #     "Analgesic, Anti-inflammatory or Antipyretic",
    #     "Analgesic, Anti-inflammatory or Antipyretic - Non-Opioid",
    #     "Analgesic or Antipyretic Non-Opioid and Combinations",
    #     "Analgesic or Antipyretic Non-Opioid"
    #   ],
    #   "rxnorm_rxcui": "313782"
    # }
    # look up multiple NDCs
    response_json = ontologies_http.get_json(f"/fdb/ndcs-to-medications/76420037215,11822317640/").json()
    # response_json is a dictionary where each key is an NDC and each each attribute contains the
    # object formatted as the individual ndc-to-medication search above
    # look up by RxNorm RXCUI
    # response_json is a list containing objects of this type:
    # [
    #   {
    #     "med_medication_id": 156060,
    #     "clinical_formulation_id": {
    #       "clinical_formulation_id": 4489.0,
    #       "hierarchical_specific_therapeutic_class_code": "H3E",
    #       "dosage_form_code_2_character": "TA",
    #       "route_of_administration_code_1_character": "1",
    #       "drug_strength_description": "325 MG",
    #       "therapeutic_class_code_generic": 2.0,
    #       "therapeutic_class_code_standard": 41.0,
    #       "drug_category_code": "0",
    #       "gcn_seqno_level_multi_source_single_source_indicator": "1",
    #       "gender_specific_drug_indicator": "0",
    #       "hierarchical_specific_therapeutic_class_code_sequence_number": 271.0,
    #       "drug_strength_description_60": "325 mg",
    #       "ingredient_list_description": 1866.0,
    #       "interactions": [
    #         1674.0,
    #         27763.0,
    #         29424.0,
    #         30280.0,
    #         30534.0
    #       ]
    #     },
    #     "clinical_quantities": [
    #
    #     ],
    #     "med_routed_dosage_form_medication_id": 12758.0,
    #     "med_strength": "325",
    #     "med_strength_unit_of_measure": "mg",
    #     "med_medication_description": "Dolono 325 mg tablet",
    #     "med_gcn_seqno_assignment_code": "1",
    #     "med_medication_name_source_code": "1",
    #     "med_reference_federal_legend_indicator": "2",
    #     "med_reference_federal_dea_class_code": "0",
    #     "med_reference_multi_source_code": "1",
    #     "med_reference_generic_medication_name_code": "2",
    #     "med_reference_generic_comparative_price_code": "9",
    #     "med_reference_generic_price_spread_code": "9",
    #     "med_reference_innovator_indicator": "0",
    #     "med_reference_generic_therapeutic_equivalence_code": "4",
    #     "med_reference_desi_indicator": "9",
    #     "med_reference_desi2_indicator": "9",
    #     "med_medication_status_code": "3",
    #     "med_generic_medication_identifier": 160401.0
    #   },
    #   ...
    # ]
    ```
##  Making requests to the Pharmacy service 
Plugin authors can make requests to our Pharmacy service using the `PharmacyHttp` client. This client provides a simplified interface for searching pharmacies and retrieving pharmacy details.
    ```python
    from canvas_sdk.utils.http import pharmacy_http
    ```
Unlike the general Http client, PharmacyHttp only provides two specific methods for pharmacy operations. Direct HTTP methods (get, post, put, patch) are not available.
###  Searching for pharmacies 
Search for pharmacies by name, with optional location-based filtering.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`search_term` | _string_ | `true` | The search query for pharmacy name or organization.  
`latitude` | _string_ | `false` | Latitude coordinate for location-based search.  
`longitude` | _string_ | `false` | Longitude coordinate for location-based search.  
**Example** :
    ```python
    from canvas_sdk.utils.http import pharmacy_http
    # Basic search by name
    results = pharmacy_http.search_pharmacies("CVS")
    # Search with location filtering
    results = pharmacy_http.search_pharmacies(
        "pharmacy",
        latitude="40.7128",
        longitude="-74.0060"
    )
    # The results list contains pharmacy objects like:
    # [
    #   {
    #     "id": 123456,
    #     "distance_miles": 0.8,
    #     "ncpdp_id": "1234567",
    #     "store_number": "#1234",
    #     "organization_name": "CVS Pharmacy #1234",
    #     "address_line_1": "123 MAIN ST",
    #     "address_line_2": "",
    #     "city": "New York",
    #     "state": "NY",
    #     "zip_code": "10001",
    #     "phone_primary": "2125551234",
    #     "fax": "2125555678",
    #     "latitude": 40.7128,
    #     "longitude": -74.0060,
    #     "npi": "1234567890",
    #     "specialty_type": "Retail",
    #     ...
    #   },
    #   ...
    # ]
    ```
###  Looking up a pharmacy by NCPDP ID 
Retrieve detailed information about a specific pharmacy using its NCPDP (National Council for Prescription Drug Programs) identifier.
**Parameters** :
Name | Type | Required | Description  
---|---|---|---  
`ncpdp_id` | _string_ | `true` | The NCPDP identifier of the pharmacy.  
**Example** :
    ```python
    from canvas_sdk.utils.http import pharmacy_http
    # Look up a specific pharmacy
    pharmacy = pharmacy_http.get_pharmacy_by_ncpdp_id("1234567")
    # The response contains detailed pharmacy information:
    # {
    #   "id": 123456,
    #   "ncpdp_id": "1234567",
    #   "store_number": "#1234",
    #   "organization_name": "Example Pharmacy #1234",
    #   "address_line_1": "123 MAIN ST",
    #   "address_line_2": "",
    #   "city": "New York",
    #   "state": "NY",
    #   "zip_code": "10001",
    #   "country": "US",
    #   "standardized_address_line_1": "123 Main St",
    #   "standardized_city": "New York",
    #   "standardized_state": "NY",
    #   "standardized_zip_code": "100010000",
    #   "phone_primary": "2125551234",
    #   "fax": "2125555678",
    #   "email": "",
    #   "active_start_time": "2020-01-01T00:00:00Z",
    #   "active_end_time": "2099-12-31T23:59:59Z",
    #   "service_level": "New~Refill~Change~Cancel~ControlledSubstance",
    #   "npi": "1234567890",
    #   "specialty_type": "Retail",
    #   "dea_number": "",
    #   "organization_type": "Pharmacy",
    #   "organization_id": 1234567,
    #   "latitude": 40.7128,
    #   "longitude": -74.0060,
    #   ...
    # }
    ```
###  Response fields 
Both methods return pharmacy objects with the following key fields:
  - `ncpdp_id`: Unique NCPDP identifier for the pharmacy
  - `organization_name`: Name of the pharmacy
  - `address_line_1`, `address_line_2`, `city`, `state`, `zip_code`: Physical address
  - `phone_primary`: Primary phone number
  - `fax`: Fax number
  - `npi`: National Provider Identifier
  - `specialty_type`: Type of pharmacy (e.g., "Retail", "Mail Order")
  - `service_level`: Services available (e.g., "New~Refill~Change~Cancel~ControlledSubstance")
  - `latitude`, `longitude`: Geographic coordinates
  - `distance_miles`: Distance from search location (only present in search results when location is provided)
----- END PAGE https://docs.canvasmedical.com/sdk/utils/


