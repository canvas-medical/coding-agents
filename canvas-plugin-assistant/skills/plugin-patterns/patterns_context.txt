# Canvas Plugin Architecture Patterns

This document provides practical patterns and best practices for building Canvas plugins.

## Canonical Project Structure

**CRITICAL:** The `canvas init` command creates a specific nested folder structure. Understanding this structure is essential for correct plugin development.

### Container vs Inner Folder Pattern

When you run `canvas init` with a plugin name, it creates two levels:

```
example-plugin-name/              # Container folder (kebab-case)
├── pyproject.toml                # Container level - dev/test tooling only
├── tests/                        # Container level - mirrors inner structure
│   ├── __init__.py
│   ├── conftest.py
│   └── protocols/
│       └── test_handler.py       # Mirrors inner/protocols/handler.py
└── example_plugin_name/          # Inner folder (snake_case, same name converted)
    ├── CANVAS_MANIFEST.json      # MUST be inside inner folder
    ├── README.md                 # Plugin documentation
    └── protocols/
        ├── __init__.py
        └── my_protocol.py
```

### Key Rules

1. **Container folder** is kebab-case: `my-cool-plugin`
2. **Inner folder** is snake_case: `my_cool_plugin` (same name, different format)
3. **CANVAS_MANIFEST.json** MUST be inside the inner folder, never at container level
4. **tests/** MUST be at container level, parallel to inner folder
5. **pyproject.toml** is at container level (for local dev/test only)
6. **README.md** is inside the inner folder

### Name Conversion

The inner folder name is derived from the container name by replacing hyphens with underscores:

| Plugin Name (container) | Inner Folder |
|------------------------|--------------|
| `my-plugin` | `my_plugin` |
| `vitals-alert` | `vitals_alert` |
| `patient-chart-customizations` | `patient_chart_customizations` |

### Common Structure Mistakes

| Mistake | Problem | Fix |
|---------|---------|-----|
| `CANVAS_MANIFEST.json` at container level | Canvas CLI won't find it | Move inside inner folder |
| `tests/` inside inner folder | Import paths break | Move to container level |
| No inner folder (flat structure) | Plugin won't install | Re-run `canvas init` |
| Inner folder has kebab-case | Python imports fail | Rename to snake_case |
| Two levels of nesting inside inner | Over-complicated structure | Flatten to single inner folder |

### Verification Commands

After `canvas init`, verify the structure:

```bash
# Get inner folder name (convert kebab to snake)
INNER=$(basename "$PWD" | tr '-' '_')

# CANVAS_MANIFEST.json should be inside inner folder
test -f "$INNER/CANVAS_MANIFEST.json" && echo "OK: Manifest in correct location" || echo "ERROR: Manifest missing from $INNER/"

# tests/ should be at container level
test -d tests && echo "OK: tests/ at container level" || echo "ERROR: tests/ missing"

# pyproject.toml should be at container level
test -f pyproject.toml && echo "OK: pyproject.toml present" || echo "ERROR: pyproject.toml missing"
```

---

## Plugin Complexity Levels

### Simple Plugins (1-2 files, ~45 real-world examples)
Best for: Single event → single effect workflows

**Characteristics:**
- Single protocol handler
- 20-100 lines of code
- Direct event → effect mapping
- No external API calls
- No UI component

**When to use:**
- Creating alerts based on clinical data (e.g., high blood pressure alert)
- Creating tasks when specific events occur (e.g., lab order fasting reminder)
- Simple data validation or transformation
- Automated workflow triggers

**Structure:**
```
simple-plugin/
├── CANVAS_MANIFEST.json
├── protocols/
│   └── handler.py
└── README.md
```

**Example - Blood Pressure Alert:**
```python
from canvas_sdk.effects import Effect
from canvas_sdk.effects.banner_alert import AddBannerAlert
from canvas_sdk.events import EventType
from canvas_sdk.protocols import BaseProtocol

class BPAlertProtocol(BaseProtocol):
    RESPONDS_TO = [
        EventType.Name(EventType.VITALS_COMMAND__POST_COMMIT)
    ]

    def compute(self) -> list[Effect]:
        vitals = self.event.target.instance
        systolic = vitals.blood_pressure_systolic
        diastolic = vitals.blood_pressure_diastolic

        if not systolic or not diastolic:
            return []

        patient_id = self.event.context["patient"]["id"]

        # Stage 2 Hypertension
        if systolic >= 140 or diastolic >= 90:
            return [
                AddBannerAlert(
                    patient_id=patient_id,
                    key="bp-stage2",
                    narrative=f"Stage 2 Hypertension: {systolic}/{diastolic}",
                    placement=[AddBannerAlert.Placement.TIMELINE],
                    intent=AddBannerAlert.Intent.WARNING
                ).apply()
            ]

        return []
```

---

### Medium Plugins (8-15 files, ~3 real-world examples)
Best for: Multi-handler workflows or API-based plugins

**Characteristics:**
- Multiple protocol handlers with different responsibilities
- API endpoints (SimpleAPI routes)
- Utility modules for shared logic
- 500-2000 lines total
- May have simple UI served via API

**When to use:**
- Workflows requiring multiple event triggers
- Plugins needing HTTP endpoints for webhooks or UI
- Integration with external systems
- Complex business logic with shared utilities

**Structure:**
```
medium-plugin/
├── CANVAS_MANIFEST.json
├── protocols/
│   ├── __init__.py
│   ├── event_handler.py
│   └── webhook_handler.py
├── api/
│   ├── __init__.py
│   └── routes.py
├── utils/
│   ├── __init__.py
│   └── helpers.py
└── README.md
```

---

### Complex Plugins (15+ files, rare)
Best for: Full-featured applications with UI

**Characteristics:**
- Application handler for UI
- Multiple protocols and API endpoints
- Static assets (JS, CSS)
- HTML templates
- Possibly LLM integration
- 2000+ lines of code

**When to use:**
- Interactive UI applications (requires icon - use icon-generation skill)
- AI/LLM-powered features
- Complex multi-step workflows with user interaction
- Real-time data processing and display

**Structure:**
```
complex-plugin/
├── CANVAS_MANIFEST.json
├── applications/
│   ├── __init__.py
│   └── my_app.py
├── assets/                  # Required for Application icons
│   └── icon.png            # 48x48 PNG icon
├── protocols/
│   ├── __init__.py
│   └── listener.py
├── api/
│   ├── __init__.py
│   ├── routes.py
│   └── static.py
├── llms/                    # Optional
│   ├── __init__.py
│   └── client.py
├── static/
│   ├── css/
│   │   └── styles.css
│   └── js/
│       └── app.js
├── templates/
│   └── index.html
├── utils/
│   └── helpers.py
└── README.md
```

---

## Common Handler Patterns

### Pattern 1: Event Listener → Effect
The simplest and most common pattern.

```python
class MyProtocol(BaseProtocol):
    RESPONDS_TO = [EventType.Name(EventType.SOME_EVENT__POST_COMMIT)]

    def compute(self) -> list[Effect]:
        # 1. Extract data from event
        patient_id = self.event.context["patient"]["id"]
        data = self.event.target.instance

        # 2. Apply business logic
        if some_condition(data):
            # 3. Return effects
            return [SomeEffect(...).apply()]

        return []
```

### Pattern 2: Webhook Handler
For receiving data from external systems.

```python
class WebhookHandler(SimpleAPI):
    PREFIX = "/webhook"

    def authenticate(self, credentials: Credentials) -> bool:
        api_key = self.request.headers.get("X-API-Key")
        return api_key == self.secrets.get("WEBHOOK_API_KEY")

    @api.post("/receive")
    def receive_data(self) -> list[JSONResponse | Effect]:
        body = self.request.json()

        # Process incoming data
        # Create Canvas commands/effects

        return [JSONResponse({"status": "ok"}, status_code=HTTPStatus.OK)]
```

### Pattern 3: Application with API Backend
For interactive UI applications.

**CRITICAL: Applications REQUIRE an icon (48x48 PNG).**
- Generate the icon IMMEDIATELY after creating the Application class
- Invoke the icon-generation skill: `Skill(skill="icon-generation")`
- Create assets directory: `mkdir -p {plugin_name_snake}/assets`
- Save icon files to `{plugin_name_snake}/assets/`
- Update CANVAS_MANIFEST.json applications entry: `"icon": "assets/{filename}.png"`
- Verify icon exists: `ls -lh {plugin_name_snake}/assets/*.png`

```python
# applications/my_app.py
class MyApp(Application):
    def on_open(self) -> Effect:
        patient_id = self.context.get("patient", {}).get("id", "")
        return LaunchModalEffect(
            url=f"/plugin-io/api/my_plugin/ui/{patient_id}",
            target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
            title="My App"
        ).apply()

# api/routes.py
class MyAPI(SimpleAPI):
    PREFIX = "/my_plugin"

    @api.get("/ui/<patient_id>")
    def get_ui(self) -> list[HTMLResponse | Effect]:
        html = render_to_string("templates/index.html", {...})
        return [HTMLResponse(html, status_code=HTTPStatus.OK)]
```

---

## CANVAS_MANIFEST.json Patterns

### Minimal Manifest (Simple Plugin)
```json
{
    "sdk_version": "0.1.4",
    "plugin_version": "0.0.1",
    "name": "my_plugin",
    "description": "Brief description of what the plugin does",
    "components": {
        "protocols": [
            {
                "class": "my_plugin.protocols.handler:MyProtocol",
                "description": "Handles X events and creates Y effects"
            }
        ]
    },
    "secrets": [],
    "readme": "./README.md"
}
```

### Full Manifest (Complex Plugin)
```json
{
    "sdk_version": "0.74.1",
    "plugin_version": "0.0.1",
    "name": "my_plugin",
    "description": "Full description",
    "components": {
        "protocols": [
            {
                "class": "my_plugin.protocols.listener:EventListener",
                "description": "Listens for events"
            },
            {
                "class": "my_plugin.api.routes:MyAPI",
                "description": "API endpoints"
            }
        ],
        "applications": [
            {
                "class": "my_plugin.applications.my_app:MyApp",
                "name": "My Application",
                "description": "Interactive UI",
                "icon": "assets/icon-name.png",  # Required: 48x48 PNG
                "scope": "patient_specific",
                "show_in_panel": true,
                "panel_priority": 100
            }
        ]
    },
    "secrets": [
        "API_KEY",
        "WEBHOOK_SECRET"
    ],
    "readme": "./README.md"
}
```

---

## Event Types Reference

### Most Common Events

**Vitals:**
- `VITALS_COMMAND__POST_COMMIT` - Vitals saved
- `VITALS_COMMAND__POST_UPDATE` - Vitals modified

**Lab Orders:**
- `LAB_ORDER_COMMAND__POST_COMMIT` - Lab ordered
- `LAB_ORDER_COMMAND__POST_UPDATE` - Lab order modified

**Prescriptions:**
- `PRESCRIBE_COMMAND__POST_COMMIT` - Prescription created
- `PRESCRIBE_COMMAND__POST_UPDATE` - Prescription modified

**Diagnoses:**
- `DIAGNOSE_COMMAND__POST_COMMIT` - Diagnosis added
- `DIAGNOSE_COMMAND__POST_UPDATE` - Diagnosis modified

**Patient:**
- `PATIENT__POST_CREATE` - New patient created
- `PATIENT__POST_UPDATE` - Patient record modified

**Notes:**
- `NOTE__POST_SAVE` - Note saved
- `NOTE__POST_SIGN` - Note signed

---

## Effect Types Reference

### AddBannerAlert
Display alerts in patient timeline or chart header.

```python
AddBannerAlert(
    patient_id=patient_id,
    key="unique-key",           # Unique identifier
    narrative="Alert message",   # Display text
    placement=[
        AddBannerAlert.Placement.TIMELINE,    # In timeline
        AddBannerAlert.Placement.CHART_HEADER # At top of chart
    ],
    intent=AddBannerAlert.Intent.ALERT,  # ALERT, WARNING, INFO
    href="/some/url"            # Optional link
).apply()
```

### AddTask
Create tasks for staff members or teams.

```python
AddTask(
    patient_id=patient_id,
    title="Task title",
    team_id=team_id,           # Assign to team
    # OR
    assignee_id=staff_id,      # Assign to individual
    due=datetime_obj,          # Due date
    labels=["label1"]          # Optional labels
).apply()
```

### LaunchModalEffect
Open UI modals or panels.

```python
LaunchModalEffect(
    url="/plugin-io/api/my_plugin/ui",  # URL to load
    # OR
    content="<html>...</html>",          # Inline HTML
    target=LaunchModalEffect.TargetType.RIGHT_CHART_PANE,
    title="Modal Title"
).apply()

# Target types:
# - DEFAULT_MODAL: Centered modal
# - NEW_WINDOW: New browser window (requires URL)
# - RIGHT_CHART_PANE: Sidebar panel
# - RIGHT_CHART_PANE_LARGE: Wider sidebar
# - PAGE: Full page
```

---

## Best Practices

### 1. Use Absolute Imports

**CRITICAL:** Canvas plugins MUST use absolute imports with the full package path. Relative imports will fail in the Canvas runtime.

```python
# GOOD - absolute import with full package path
from my_plugin_name.protocols.handler import MyHandler
from my_plugin_name.utils.helpers import format_date

# BAD - relative imports (will fail in Canvas)
from .handler import MyHandler
from ...utils.helpers import format_date
```

The package name in the import must match the inner folder name (snake_case):
- Inner folder: `vitals_alert/`
- Import: `from vitals_alert.protocols.handler import ...`

### 2. Let Exceptions Propagate
**Do NOT wrap handler code in try-except blocks.** Exceptions must bubble up so they appear in Canvas logs with full tracebacks for debugging.

```python
# GOOD - exceptions propagate to logs with full traceback
def compute(self) -> list[Effect]:
    patient_id = self.event.context["patient"]["id"]
    vitals = self.event.target.instance

    # If something fails, the exception bubbles up and appears in logs
    if vitals.blood_pressure_systolic >= 140:
        return [AddBannerAlert(...).apply()]
    return []
```

Use explicit checks for **expected** missing data, not try-except:

```python
# GOOD - explicit guards for optional data
def compute(self) -> list[Effect]:
    patient = self.event.context.get("patient")
    if not patient:
        return []  # Expected: some events lack patient context

    patient_id = patient["id"]
    # Continue with logic...
```

### 2. Logging
Use the logger for debugging and monitoring.

```python
from logger import log

log.info(f"Processing event for patient {patient_id}")
log.warning("Unexpected condition encountered")
log.error(f"Failed to process: {error}")
```

### 3. Secrets Management
Never hardcode credentials. Use secrets.

```python
api_key = self.secrets.get("API_KEY")
if not api_key:
    log.error("API_KEY secret not configured")
    return []
```

### 4. Data Validation
Validate data before processing.

```python
def compute(self) -> list[Effect]:
    vitals = self.event.target.instance

    # Check required fields exist
    if not vitals.blood_pressure_systolic:
        return []

    # Validate data ranges
    if vitals.blood_pressure_systolic < 0 or vitals.blood_pressure_systolic > 300:
        log.warning(f"Invalid BP reading: {vitals.blood_pressure_systolic}")
        return []
```

### 5. Idempotency
Design handlers to be safe if called multiple times.

```python
# Use unique keys for alerts to prevent duplicates
AddBannerAlert(
    patient_id=patient_id,
    key=f"bp-alert-{patient_id}-{date.today()}",  # Unique per patient per day
    ...
)
```

---

## Anti-Patterns to Avoid

### 1. Swallowing Exceptions with try-except
**Never wrap handler code in try-except blocks.** This hides errors from logs and makes debugging impossible.

```python
# BAD - exceptions are swallowed, nothing useful in logs
def compute(self) -> list[Effect]:
    try:
        patient_id = self.event.context["patient"]["id"]
        # logic
    except Exception as e:
        log.error(f"Error: {e}")  # Only get message, no traceback!
        return []

# GOOD - let exceptions propagate with full traceback
def compute(self) -> list[Effect]:
    patient_id = self.event.context["patient"]["id"]
    # logic - failures appear in logs with full traceback
```

### 2. Blocking Operations
Don't perform long-running operations in event handlers.

```python
# BAD - blocks event processing
def compute(self):
    response = requests.get(slow_api, timeout=30)  # Too slow!

# BETTER - use async patterns or task queues
```

### 3. Not Guarding Optional Data
Use explicit checks for data that may not exist.

```python
# BAD - crashes on missing data without useful context
patient_id = self.event.context["patient"]["id"]

# GOOD - explicit guard with early return
patient = self.event.context.get("patient")
if not patient:
    return []
patient_id = patient["id"]
```

### 4. Hardcoded Values
Don't hardcode configuration.

```python
# BAD
api_url = "https://api.example.com"

# GOOD
api_url = self.secrets.get("API_URL")
```

### 5. Overly Complex Plugins
Start simple, add complexity only when needed.

```python
# BAD - building complex plugin for simple task
# 15 files for creating an alert

# GOOD - match complexity to requirements
# 2 files for alert, scale up if needed
```

---

## Testing Patterns

### Unit Testing Handlers

```python
import pytest
from unittest.mock import MagicMock, patch

def test_bp_alert_triggers_on_high_bp():
    # Mock the event
    mock_event = MagicMock()
    mock_event.context = {"patient": {"id": "test-123"}}
    mock_event.target.instance.blood_pressure_systolic = 150
    mock_event.target.instance.blood_pressure_diastolic = 95

    # Create handler with mocked event
    handler = BPAlertProtocol()
    handler.event = mock_event

    # Execute
    effects = handler.compute()

    # Assert
    assert len(effects) == 1
    # Verify effect properties
```

### Integration Testing

```bash
# Deploy to test instance
uv run canvas install my_plugin --host plugin-testing

# Monitor logs (use unbuffered for real-time output)
unbuffer uv run canvas logs --host plugin-testing

# Perform manual tests and verify behavior
```

---

## README Template

```markdown
# [Plugin Name]

## Description
[What problem does this plugin solve?]

## Features
- [Feature 1]
- [Feature 2]

## Triggers
- [Event that triggers this plugin]

## Effects
- [What the plugin creates/modifies]

## Configuration
Secrets required:
- `SECRET_NAME`: [Description]

## Installation
```bash
uv run canvas install [plugin_name] --host [target]
```

## Testing
[How to test the plugin]

## Demo
[Link to demo video if available]
```

---

## Quick Decision Guide

**Need to react to a clinical event?**
→ Simple plugin with BaseProtocol

**Need to receive data from external system?**
→ Medium plugin with SimpleAPI webhook

**Need interactive UI for users?**
→ Complex plugin with Application + API

**Need scheduled tasks?**
→ Use CronTask handler

**Need to customize search dropdowns?**
→ Use search result filter protocols

**Need to add buttons to notes?**
→ Use ActionButton handler

---

## Architectural Patterns (High-Level)

The number of handlers in a plugin is the best proxy for complexity.
Always start with `echo "plugin_name" | uv run canvas init` and adapt from there.

### Single Handler Plugins (1 protocol)

**When:** One trigger, one response, no user interaction

**Examples:**
- Event → Alert (vitals trigger banner)
- Event → Task (lab order creates follow-up task)
- Questionnaire response processing
- Webhook receiver (external system posts data)

**Architecture decisions:**
- One file in `protocols/`
- No `api/` directory needed
- No `applications/` directory needed
- 0-2 secrets (maybe API key for webhook auth)

---

### Multi-Handler Plugins (2-5 protocols)

**When:** Multiple triggers OR trigger + UI display OR inbound + outbound integration

**Examples:**
- Respond to multiple event types (vitals AND labs AND diagnoses)
- Event handler + API endpoint for external queries
- ActionButton + display handler pair
- Scheduled task + event-driven updates

**Architecture decisions:**
- Multiple files in `protocols/` or separate into `handlers/`
- May need `api/` for HTTP endpoints
- Consider `utils/` for shared logic
- 2-5 secrets typical

**Handler combinations:**
- BaseProtocol + BaseProtocol (multiple events)
- BaseProtocol + SimpleAPI (event + webhook)
- ActionButton + SimpleAPI (button + display)
- CronTask + BaseProtocol (scheduled + reactive)

---

### Application Plugins (1+ Application handlers)

**When:** Interactive UI that users launch from Canvas

**Examples:**
- Patient-specific tool launched from chart
- Global utility launched from app drawer
- Multi-step workflow with user interaction

**Architecture decisions:**
- `applications/` directory with Application handler
- `api/` directory for backend endpoints serving UI
- `templates/` for HTML
- `static/` for CSS/JS if needed
- Application opens modal/panel, API serves content
- Consider scope: `patient_specific` vs `global`

**Handler combinations:**
- Application + SimpleAPI (minimum for UI app)
- Application + SimpleAPI + BaseProtocol (UI + background processing)

---

### LLM-Integrated Plugins

**When:** AI/ML processing of clinical data, voice, or text

**Examples:**
- Voice transcription and command generation
- Clinical decision support with LLM reasoning
- Automated documentation from conversations

**Architecture decisions:**
- `llms/` directory for LLM client abstractions
- Support multiple providers (OpenAI, Anthropic, Google)
- Separate prompt management from LLM calls
- Heavy use of secrets for API keys and configuration
- Consider `structures/` for complex data models
- May need WebSocket for real-time streaming

**Typical secrets:** 10+ (LLM keys, configuration flags, feature toggles)

---

### Extreme Complexity (10+ handlers)

**Real-world example:** Hyperscribe (12 protocols, 1 application, 123 files, 26 secrets)

**When:** Full-featured product, not a simple integration

**Characteristics:**
- Multiple ActionButtons for different entry points
- Multiple display handlers for different views
- Background processing handlers
- WebSocket for real-time updates
- Extensive command/data structure libraries
- Custom tuning and configuration UIs

**Architecture decisions:**
- `handlers/` instead of `protocols/` (semantic clarity at scale)
- `commands/` for domain-specific command builders
- `structures/` for data models
- `libraries/` for shared utilities
- Version tagging in manifest
- Extensive secrets for configuration flexibility

---

## Pattern Selection from Spec

When reading a `.cpa-workflow-artifacts/plugin-spec.md`, map to patterns:

| Spec says... | Pattern |
|--------------|---------|
| Single event trigger, alert/task effect | Single Handler |
| Multiple event triggers | Multi-Handler |
| External webhook | Single Handler (SimpleAPI) |
| Questionnaire processing | Single Handler |
| Scheduled/periodic | Single Handler (CronTask) |
| "Interactive UI" or "panel" | Application Plugin |
| "Custom UI" with backend | Application + API |
| LLM/AI processing | LLM-Integrated |
| Multiple entry points | Multi-Handler with ActionButtons |

---

## Directory Evolution

As plugins grow, directory structure evolves:

```
Simple (1 handler):
plugin/
├── protocols/handler.py
├── CANVAS_MANIFEST.json
└── README.md

Medium (3-5 handlers):
plugin/
├── protocols/
│   ├── event_handler.py
│   ├── webhook.py
│   └── cron_task.py
├── utils/helpers.py
├── CANVAS_MANIFEST.json
└── README.md

Complex (Application + handlers):
plugin/
├── applications/app.py
├── api/routes.py
├── protocols/listener.py
├── templates/index.html
├── static/css/, js/
├── utils/
├── CANVAS_MANIFEST.json
└── README.md

Extreme (product-level):
plugin/
├── handlers/          # 10+ handler files
├── commands/          # Domain command builders
├── structures/        # Data models
├── libraries/         # Shared utilities
├── llms/              # LLM integrations
├── api/
├── applications/
├── templates/
├── static/
├── CANVAS_MANIFEST.json
└── README.md
```

---

## Secrets Complexity Guide

| Complexity | Typical Secrets |
|------------|-----------------|
| Simple | 0-2 (maybe webhook auth) |
| Medium | 2-5 (API keys, config) |
| Complex | 5-10 (LLM keys, feature flags) |
| Extreme | 10-30 (full configuration system) |

If a spec requires many configurable behaviors, plan for more secrets.

---

## pyproject.toml

**CRITICAL: Keep pyproject.toml minimal.** This file is only used for local development and testing—Canvas has its own plugin packaging process that ignores it.

### Correct pyproject.toml Structure

```toml
# This pyproject.toml is only used for local development and testing.
# The Canvas plugin has its own packaging process that doesn't use this file.

[project]
name = "my-plugin-name"
version = "0.0.0"
requires-python = ">=3.12"
dependencies = [
    "arrow>=1.3.0",
    "django>=4.2.0",
]

[dependency-groups]
dev = [
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
    "pytest-django>=4.7.0",
    "pytest-mock>=3.12.0",
]

[tool.coverage.run]
omit = ["tests/*"]
```

### What to Include

- **`[project]`**: Plugin name, version `0.0.0`, Python version
- **`dependencies`**: Only packages your plugin imports at runtime (arrow, django, httpx, etc.)
- **`[dependency-groups].dev`**: Test tooling only (pytest and plugins)
- **`[tool.coverage.run]`**: Exclude tests from coverage reports

### What NOT to Include

- Build system configuration (`[build-system]`, setuptools, hatch, etc.)
- Complex tool configurations (black, ruff, mypy settings)
- Scripts or entry points
- Optional dependencies groups beyond `dev`
- Package metadata (authors, license, classifiers, URLs)
- Any configuration Canvas won't use

### Anti-Pattern: Over-Configured pyproject.toml

```toml
# BAD - way too much unnecessary configuration
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "my-plugin"
version = "0.1.0"
description = "A Canvas plugin"
readme = "README.md"
license = "MIT"
authors = [{ name = "...", email = "..." }]
classifiers = [...]
urls = { Homepage = "...", Repository = "..." }
dependencies = [...]

[project.optional-dependencies]
dev = [...]
test = [...]
lint = [...]

[tool.hatch.build.targets.wheel]
packages = ["src/my_plugin"]

[tool.black]
line-length = 88

[tool.ruff]
line-length = 88
select = ["E", "F", "I"]

[tool.mypy]
strict = true
```

None of this is needed. Canvas doesn't use your build system, and you don't need linting configuration in the project file.

---

## Client Libraries

Pre-built client libraries are available in `skills/plugin-patterns/client-library/` for common integrations. **Copy these files into your plugin** when needed rather than writing from scratch.

### AWS S3 — Use the Canvas SDK Native Client

**Do NOT copy a custom S3 client.** The Canvas SDK provides a native S3 client. See the **canvas-sdk** skill (`https://docs.canvasmedical.com/sdk/clients-aws-s3/`) for full documentation.

**When to use:** Plugin needs to store or retrieve files, data persistence beyond Canvas, file uploads/downloads.

**Features:**
- AWS Signature Version 4 authentication (no boto3 dependency)
- Upload text and binary files
- Download, delete, and list objects
- Generate presigned URLs for temporary access

**Usage:**
```python
from canvas_sdk.clients.aws import S3, Credentials

credentials = Credentials(
    key=self.secrets["S3_ACCESS_KEY"],
    secret=self.secrets["S3_SECRET_KEY"],
    region=self.secrets["S3_REGION"],
    bucket=self.secrets["S3_BUCKET"],
)
client = S3(credentials)

if not client.is_ready():
    return []

# Upload text data
client.upload_text_to_s3("my-data.json", json.dumps(data))

# Download data
response = client.access_s3_object("my-data.json")
if response and response.status_code == 200:
    data = response.json()

# Upload binary data
client.upload_binary_to_s3("image.png", binary_data, "image/png")

# List objects
items = client.list_s3_objects("prefix/")

# Delete an object
client.delete_object("my-data.json")

# Generate a presigned URL (1 hour)
url = client.generate_presigned_url("my-data.json", 3600)
```

**Required secrets:** `S3_ACCESS_KEY`, `S3_SECRET_KEY`, `S3_REGION`, `S3_BUCKET`

**No extra dependency needed** — the S3 client is included in the Canvas SDK.

---

### Anthropic LLM Client (`llm_anthropic.py`)

**When to use:** Plugin needs AI/LLM capabilities, text generation, clinical recommendations, structured data extraction.

**Features:**
- Lightweight Anthropic Claude API wrapper (no anthropic SDK dependency)
- Conversation message management
- `chat()` for free-form responses
- `chat_with_json()` for structured JSON responses with automatic retry

**Usage:**
```python
from {plugin_name}.clients.llm_anthropic import LlmAnthropic

llm = LlmAnthropic(api_key=self.secrets["ANTHROPIC_API_KEY"])

# Simple chat
response = llm.chat(
    system_prompt="You are a clinical assistant.",
    user_prompt="Summarize these vitals..."
)
if response["success"]:
    summary = response["content"]

# JSON response with automatic retry
result = llm.chat_with_json(
    system_prompt="Return JSON with keys: recommendation, urgency",
    user_prompt="Analyze this lab result..."
)
if result["success"]:
    data = result["data"]  # Parsed dict
```

**Required secrets:** `ANTHROPIC_API_KEY`

**Required dependency:** `requests>=2.28.0`

---

### Twilio SMS Client (`twilio_client.py`)

**When to use:** Plugin needs to send SMS messages, patient notifications, appointment reminders.

**Features:**
- Simple Twilio API wrapper (no twilio SDK dependency)
- E.164 phone number format support
- Typed response with success status, message SID, or error details

**Usage:**
```python
from {plugin_name}.clients.twilio_client import TwilioClient

twilio = TwilioClient(
    account_sid=self.secrets["TWILIO_ACCOUNT_SID"],
    auth_token=self.secrets["TWILIO_AUTH_TOKEN"],
    from_number=self.secrets["TWILIO_FROM_NUMBER"]  # E.164 format: +15551234567
)

# Send SMS
response = twilio.send_sms(
    to="+15559876543",
    body="Your appointment is confirmed for tomorrow at 2pm."
)
if response.success:
    log.info(f"SMS sent: {response.message_sid}")
else:
    log.error(f"SMS failed: {response.error_message}")
```

**Required secrets:** `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`, `TWILIO_FROM_NUMBER`

**Required dependency:** `requests>=2.28.0`

---

### SendGrid Email Client (`sendgrid_client.py`)

**When to use:** Plugin needs to send emails, patient communications, reports, notifications.

**Features:**
- Simple SendGrid API wrapper (no sendgrid SDK dependency)
- HTML and plain text email support
- Typed response with success status, message ID, or error details

**Usage:**
```python
from {plugin_name}.clients.sendgrid_client import SendGridClient

sendgrid = SendGridClient(
    api_key=self.secrets["SENDGRID_API_KEY"],
    from_email="notifications@clinic.com"
)

# Send email
response = sendgrid.send_email(
    to="patient@example.com",
    subject="Your Lab Results Are Ready",
    html_body="<h1>Lab Results</h1><p>Your results are now available...</p>",
    plain_text_body="Your lab results are now available..."  # Optional fallback
)
if response.success:
    log.info(f"Email sent: {response.message_id}")
else:
    log.error(f"Email failed: {response.error_message}")
```

**Required secrets:** `SENDGRID_API_KEY`

**Required dependency:** `requests>=2.28.0`

---

### How to Add a Client Library to Your Plugin

1. **Copy the file** into your plugin's inner folder:
   ```bash
   # From inside the plugin container folder
   mkdir -p {inner_folder}/clients
   cp /path/to/skills/plugin-patterns/client-library/<client_file>.py {inner_folder}/clients/
   ```

2. **Add `__init__.py`** to make it a package:
   ```bash
   touch {inner_folder}/clients/__init__.py
   ```

3. **Add secrets** to `CANVAS_MANIFEST.json`:
   ```json
   "secrets": ["SECRET_1", "SECRET_2"]
   ```

4. **Add dependency** to `pyproject.toml`:
   ```toml
   dependencies = [
       "django>=4.2.0",
       "requests>=2.28.0",
   ]
   ```

5. **Import and use** in your handler:
   ```python
   from {plugin_name}.clients.<client_module> import ClientClass
   ```

**Note:** For AWS S3, do NOT copy a client file — use the Canvas SDK native client instead. See the "AWS S3" section above.
